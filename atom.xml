<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xu&#39;s Blog</title>
  
  
  <link href="http://xucoud.github.io/atom.xml" rel="self"/>
  
  <link href="http://xucoud.github.io/"/>
  <updated>2022-06-25T06:21:46.188Z</updated>
  <id>http://xucoud.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>js</title>
    <link href="http://xucoud.github.io/2022/06/25/js%E5%9F%BA%E7%A1%80/"/>
    <id>http://xucoud.github.io/2022/06/25/js%E5%9F%BA%E7%A1%80/</id>
    <published>2022-06-25T06:09:01.065Z</published>
    <updated>2022-06-25T06:21:46.188Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><span id="more"></span><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>JavaScript是一个web端使用的脚本语言，可以对HTML页面插入代码，并且可以被现代浏览器执行。</p><p><strong>功能</strong></p><ul><li>直接写入HTML输出流</li><li>对事件反应</li><li>对HTML内容做出修改</li><li>对HTML的内容样式做出修改</li><li>验证输入</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端" scheme="http://xucoud.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="js" scheme="http://xucoud.github.io/categories/%E5%89%8D%E7%AB%AF/js/"/>
    
    
    <category term="js" scheme="http://xucoud.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>设计模式期末</title>
    <link href="http://xucoud.github.io/2022/06/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB/"/>
    <id>http://xucoud.github.io/2022/06/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB/</id>
    <published>2022-06-04T11:24:30.566Z</published>
    <updated>2022-06-05T13:47:22.218Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><span id="more"></span><h2 id="面对对象的设计原则"><a href="#面对对象的设计原则" class="headerlink" title="面对对象的设计原则"></a>面对对象的设计原则</h2><ul><li><p>开闭原则</p><ul><li>定义：一个软件实体应当对扩展开放，对修改关闭。实现在不修改代码的情况下扩展模块的行为。</li><li>含义：使系统具备良好的灵活性和可扩展性。</li></ul></li><li><p>单一职责原则</p><ul><li>定义：一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中（就一个类而言，应该仅有一个引起他变化的原因）</li><li>含义：用于控制类的粒度大小。实现高内聚、低耦合的指导方针。</li></ul></li><li><p>里氏代换原则</p><ul><li>定义：所有引用基类（父类）的地方必须能透明地使用其子类的对象。</li></ul></li><li><p>依赖倒转原则</p><ul><li><p>定义：高层模块不应该依赖底层模块，他们都应该依赖抽象。抽象不依赖细节，细节依赖抽象。</p></li><li><p>要整对接口编程，不要针对实现编程。</p></li><li><p>类之间的耦合关系：</p><ul><li>零耦合关系：两个类之间没有任何耦合</li><li>具体耦合关系：具体耦合发生在两个具体类（可实例化的类）之间，一个类对另一个类实例的进行直接引用。</li><li>抽象耦合关系：抽象耦合关系发生在一个具体类和一个抽象类之间，也可以发生在两个抽象类之间，使两个发生关系的类之间存有最大的灵活性。</li></ul></li><li><p>依赖注入：</p><ul><li>构造注入：通过构造函数注入实例变量。</li><li>设值注入：通过Setter方法注入。</li><li>接口注入：通过接口方法注入实例变量。</li></ul></li></ul></li><li><p>接口隔离原则</p><ul><li>定义：客户端不应该依赖那些它不需要的接口（一旦一个接口太大，则需要将它分割成一些更细小的接口，使用该接口的客户端仅需要知道与之相关的方法即可）。</li></ul></li><li><p>合成复用原则</p><ul><li>定义：尽量使用对象组合，而不是继承来达到复用的目的。</li><li>方法：<ul><li>通过继承来实现复用：易于扩展，但是会破坏系统的封装性，灵活性不够。</li><li>通过组合/聚合来实现复用：将一个类的对象作为另一个类对象的一部分，灵活性高，耦合性降低。</li></ul></li></ul></li><li><p>迪米特法则（最少知识原则）</p><ul><li>定义：每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。</li><li>一个软件实体应当尽可能少的与其他的模块发生相互作用。</li></ul></li></ul><h2 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h2><p>​        简单工程模式又称为静态工厂方法模式，属于类创建型模式，简单工厂中可以根据参数的不同返回不同类的实例。专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</p><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><ul><li>Factory（工厂）</li><li>Product（抽象产品角色）</li><li>ConcreteProduct（具体产品角色）</li></ul><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>​        工厂方法模式又称为工厂模式，也叫虚拟构造器模式或者多态工厂模式，属于类创建型模式。</p><p>​        工厂父类负责定义创建产品对象的公共借口，而工厂子类则负责生成具体的产品对象。目的是将产品类的实例化操作延迟至工厂子类中完成。</p><h3 id="角色-1"><a href="#角色-1" class="headerlink" title="角色"></a>角色</h3><ul><li>Product（抽象产品）</li><li>ConcreteProduct（具体产品）</li><li>Factory（抽象工厂）</li><li>ConcreteFactory（具体工厂）</li></ul><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>​        提供一个创群一系列相关或互相依赖对象的接口，而无需指定他们具体的类。</p><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>​        单例模式确保，某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，提供全局访问的方法。</p><h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><ul><li>某个类只能有一个实例</li><li>它必须自行创建这个实例</li><li>它必须向整个系统提供这个实例</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="期末" scheme="http://xucoud.github.io/categories/%E6%9C%9F%E6%9C%AB/"/>
    
    
    <category term="期末" scheme="http://xucoud.github.io/tags/%E6%9C%9F%E6%9C%AB/"/>
    
  </entry>
  
  <entry>
    <title>Redis</title>
    <link href="http://xucoud.github.io/2022/04/07/Redis/"/>
    <id>http://xucoud.github.io/2022/04/07/Redis/</id>
    <published>2022-04-07T14:54:29.813Z</published>
    <updated>2022-04-08T09:10:51.887Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><span id="more"></span><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>​        <code>Redis</code>是一个使用C语言开发的一个基于内存的高性能 <code>key-value</code> 非关系型缓存数据库。因为Redis的数据都在内存中，所以Redis的效率非常高，每秒可以处理超过10W次的I/O操作。</p><p>​        <code>Redis</code> 也可以将数据存入到硬盘中，保证了数据的安全性，而且 <code>Redis</code> 的操作都是原子性的。</p><p>​        <code>Redis</code> 是单进程单线程的，使用队列技术将并发执行的操作转为串行操作，省去了很多上下文切换的时间以及CPU资源的消耗，不存在竞争问题，也就不需要加锁。</p><h2 id="数据存储方式"><a href="#数据存储方式" class="headerlink" title="数据存储方式"></a>数据存储方式</h2><p>​        <code>Redis</code> 是使用一个RedisDB的数据结构来当作一个数据库，在RedisDB中使用id来标明是几号数据库，所有的键值对都是存储在</p><p>在 <code>Redis</code> 中可以存储五种数据类型，这些数据类型在 <code>Redis</code> 中针对不同的情况在底层的数据结构上有不同的实现。</p><ul><li>String（字符串）</li><li>List（列表）</li><li>Set（无序集合）</li><li>Zset（有序集合）</li><li>Hash（哈希对象）</li></ul><p><code>Redis</code> 中的底层数据结构：</p><ul><li>SDS</li><li>双向链表</li><li>压缩链表</li><li>哈希表</li><li>整数集合</li><li>跳表</li><li>quicklist</li><li>listpack</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Redis" scheme="http://xucoud.github.io/categories/Redis/"/>
    
    
    <category term="Redis" scheme="http://xucoud.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>面试题</title>
    <link href="http://xucoud.github.io/2022/02/25/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://xucoud.github.io/2022/02/25/%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2022-02-25T15:19:52.237Z</published>
    <updated>2022-04-04T07:27:16.083Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>关于面试题的整理合集</p><span id="more"></span><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="协程，线程和进程的区别"><a href="#协程，线程和进程的区别" class="headerlink" title="协程，线程和进程的区别"></a>协程，线程和进程的区别</h3><ul><li>进程是系统进行资源分配的基本单位</li><li>线程是CPU调度的基本单位，是进程的一个执行单元</li><li>协程是一个比线程更加轻量级的存在，属于用户态</li><li>一个进程中可以包含一个或多个线程；一个线程中可以包含一个或多个协程</li><li>进程之间的资源是相互独立的，进程只能使用系统分配个它的资源；而线程之间可以共享所属进程的所有资源</li><li>一个线程可以创建和撤销另一个线程。</li><li>线程运行在处理机上。</li><li>多进程的健壮性强于多线程，一个进程崩溃后不会对其他进程产生影响；而一个线程崩溃后会使其所属的进程受到影响挂掉；</li><li>进程间的地址空间是独立的，而线程是共享进程的地址空间。</li><li>每一个进程都有其独立的执行程序和入口，所以执行的开销较大；而线程不可以独立运行，必须依赖进程，由进程来调度线程执行，执行开销较小。</li><li>进程和线程都可以做到并发执行</li><li>协程避免了无意义的线程切换消耗。协程的切换可以有程序员来决定，而线程的切换由系统来控制。</li></ul><h4 id="进程状态及其转换"><a href="#进程状态及其转换" class="headerlink" title="进程状态及其转换"></a>进程状态及其转换</h4><h5 id="状态：运行、阻塞、挂起阻塞、就绪、挂起就绪"><a href="#状态：运行、阻塞、挂起阻塞、就绪、挂起就绪" class="headerlink" title="状态：运行、阻塞、挂起阻塞、就绪、挂起就绪"></a>状态：运行、阻塞、挂起阻塞、就绪、挂起就绪</h5><blockquote><p> 状态之间的转换：准备就绪的进程，被CPU调度执行，变成运行态； 运行中的进程，进行I/O请求或者不能得到所请求的资源，变成阻塞态； 运行中的进程，进程执行完毕（或时间片已到），变成就绪态； 将阻塞态的进程挂起，变成挂起阻塞态，当导致进程阻塞的I/O操作在用户重启进程前完成（称之为唤醒），挂起阻塞态变成挂起就绪态，当用户在I/O操作结束之前重启进程，挂起阻塞态变成阻塞态； 将就绪（或运行）中的进程挂起，变成挂起就绪态，当该进程恢复之后，挂起就绪态变成就绪态；</p></blockquote><h4 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h4><p>每个进程各自有不同的用户地址空间,任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核,在内核中开辟一块缓冲区,进程A把数据从用户空间拷到内核缓冲区,进程B再从内核缓冲区把数据读走,内核提供的这种机制称为进程间通信。</p><h5 id="共享存储："><a href="#共享存储：" class="headerlink" title="共享存储："></a>共享存储：</h5><p>两个进程对共享空间的访问必须是互斥的（互斥访问通过操作系统提供的工具实现）</p><p>操作系统只负责提供共享空间和同步互斥工具（eg: P\V操作）</p><ol><li>基于数据结构的共享</li></ol><p>比如共享空间里之只能放一个长度为10的数组，</p><p>这种共享方式慢、限制多，是一种低级通信方式。</p><ol start="2"><li>基于存储区的共享：</li></ol><p>在内存中画出一块共享存储区，数据的形式、存放位置都由进程控制，而不是操作系统。</p><p>相比之下，这种共享方式速度更快，是一种高级通信方式。</p><h5 id="管道通信："><a href="#管道通信：" class="headerlink" title="管道通信："></a>管道通信：</h5><p>“管道”是指用于连接读写进程的一个共享文件，又名pipe 文件。</p><p>其实就是在内存中开辟一个大小固定的缓冲</p><ol><li>管道只能采用半双工通信，某一时间段内只能实现单向的传输。</li></ol><p>如果要实现双向同时通信，则需要设置两个管道。</p><ol start="2"><li><p>各进程要互斥地访问管道。</p></li><li><p>数据以字符流的形式写入管道，当管道写满时，写进程的write()系统调用将被阻塞，等待读进程将数据 取走。当读进程将数据全部取走后，管道变空，此时读进程的read()系统调用将被阻塞。</p></li><li><p>如果没写满，就不允许读。如果没读空，就不允许写。</p></li><li><p>数据一旦被读出，就从管道中被抛弃，这就意味着读进程最多只能有一个，否则可能会有读错数据的情况</p></li></ol><h5 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h5><p>进程间的数据交换以格式化的消息（Message)为单位。</p><p>进程通过操作系统提供的“发送消息/接受消息”两个原语进行数据交换。</p><p>消息分为消息头（发送进程ID、接受进程ID、消息类型、消息长度等格式化信息）</p><p>扩展：计网中发送报文其实就是一种格式化消息。</p><ol><li>直接通信方式：</li></ol><p>消息直接挂到接受进程的消息缓冲队列上</p><ol start="2"><li>间接通信方式</li></ol><p>消息要先发送到中间实体（信箱）中，因此，也称“信箱通信方式”。</p><h3 id="僵尸进程是什么"><a href="#僵尸进程是什么" class="headerlink" title="僵尸进程是什么"></a>僵尸进程是什么</h3><p>一个子进程调用exit()方法或者其他原因结束了（此时会释放该子进程占用的部分资源‘打开的文件，占用的内存等’，保留下一定的信息‘进程号，退出状态，运行时间等’），但是他的父进程并没有使用wait()方法回收这个子进程，那么这个子进程就会一直存在于系统中，占用部分资源，成为僵尸进程。</p><p>危害：</p><ul><li>造成资源的浪费</li><li>产生太多的僵尸进城后，可能会导致没有可用的进程号来创建新进程</li></ul><h3 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h3><p>一个父线程忽然退出，那么他的子进程都会成为孤儿进程。此时会找到一个父进程，如果其所在的进程组没有人收养，那么它就会成为init进程的子进程。init进程会为每一个子进程调用wait()方法，确保不会产生僵尸进程。</p><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="TCP，UDP报文"><a href="#TCP，UDP报文" class="headerlink" title="TCP，UDP报文"></a>TCP，UDP报文</h3><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/202202280955069.png" alt="image-20220228095534956" style="zoom: 67%;" /><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/202202280955542.png" alt="image-20220228095558492" style="zoom:67%;" /><h3 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h3><ul><li>TCP是可靠传输，UDP是不可靠传输</li><li>TCP面对对象是字节流，而UDP面对对象是报文</li><li>TCP只能是点对点的，而UDP支持一对一，一对多，多对一，多对多</li><li>TCP的安全性高，UDP的实时性高</li></ul><h3 id="TCP如何保证可靠性的"><a href="#TCP如何保证可靠性的" class="headerlink" title="TCP如何保证可靠性的"></a>TCP如何保证可靠性的</h3><ul><li><p>校验和：</p><ul><li>TCP会在发送方发送数据之前，会加上一个12字节的伪首部，并将整个报文段分成多个16位的段，将所有的段进行反码相加，将结果保存到校验和字段中。</li><li>接收端会用同样的方式计算出一个校验和，将两个校验和进行对比，如果发送发和接收方的校验和不相等，那么说明传输数据有误，丢弃这个段，重新发送。</li></ul></li><li><p>序列号/确认号</p><ul><li>序列号（ACK）：TCP为每一个数据包都分配了一个序列号，第一个数据包的序列号是随机的，之后的序列号是根据接收方的确认号来决定。<ul><li>保证可靠性（当接收到的数据总少了某个序号的数据时，能马上知道）</li><li>保证数据的按序到达</li><li>提高效率，可实现多次发送，一次确认</li><li>去除重复数据（由于网络拥塞和超时重传的原因，发送方可能将同一个数据包发送两次，但是发送方只需对一个数据包进行确认，下一个数据包就会被自动丢弃）</li></ul></li><li>确认号（seq）：接收端在接收到发送端发送来的数据包时，确认正确之后，会发送一个确认号（发送方数据包的序列号+1），这个确认号会是下一个发送端数据包的序列号。<ul><li>可靠的数据传输，Ack的值表示这个值之前的数据都已经按序到达了</li><li>延迟确认，如果连续收到两个TCP包，并不一定需要Ack两次，只要回复最终的Ack就可以了，可以降低网络流量。</li></ul></li></ul></li><li><p>超时重传</p><ul><li>发送端在发送数据包之后开始计时，如果在一定时间内没有接收到接收端的确认报文，就会进行重传</li><li>原因：<ul><li>发送端数据包丢失，导致接收端没有接收到数据包</li><li>接收端确认数据报文丢失，导致发送方一直没有接收到确认报文</li></ul></li><li>确认重传时间：<ul><li>TCP会根据网络情况动态的计算最大超时时间（RTO）。从发送端发送数据开始到收到接收端的确认报文之间的时间称为RTT（往返时间），RTO会略大于RTT。</li></ul></li><li>在重发的过程中，如果多次发送之后仍没有接收到确认包，那么发送端会认为网络或者接收端出现异常，强制关闭连接。</li></ul></li><li><p>连接管理：三握四挥</p></li><li><p>流量控制（解决因为传输速率导致的丢包问题）：接收端处理数据的速度是有限的，如果发送端发送的速度过快，会导致接收端的缓冲区溢出，出现丢包，以及超时重传等情况。为了避免这种情况，TCP会根据接收端的处理能力决定发送端发送数据的速度。</p><ul><li>TCP发送的数据包的头部中有一个16位的窗口大小，这个窗口的大小实际上是接收端实际剩余的缓冲区的大小，这个数字越大，证明接收端的缓冲区的剩余空间越大，网络的吞吐量越大，那么发送端就可以发送越多的数据。接收端在向发送端发送确认包时会将剩余的缓冲区大小填入这个字段，发送端就根据这个大小来发送数据。如果窗体的大小为0，那么发送端就会停止发送新的数据包。</li><li>16位的窗口大小实际只能发送65535字节（64K）的数据，但是TCP实际最大发送数据不止64K。TCP的头部选项中有一个窗口扩大因子M，代表窗口大小向左移M位，每移动一位，扩大两倍。</li></ul></li><li><p>滑动窗口</p><ul><li>接收端窗口只会对按序到达的最后一个数据包进行确认，发送端从确认号开始发送数据包。发送端只要收到接收端的确认报文就可以直到确认号之前的数据包都已经成功发送并被接收了。<ul><li>发送端发送{1，2，3，4，5}，接收端缺失了3，那么确认号就是3，代表{1，2}已经被成功接收，3未收到，发送端需要从3开始重新发送。</li></ul></li><li>发送窗口中的数据都是允许发送的，接收窗口内的数据包都允许被接收。发送窗口左边的数据包都是已经发送并被确认接收的，右边都是未发送的。如果发送窗口中左边的数据包被发送并被确认接受，那么发送窗口会向右滑动一段距离，直到发送窗口的左边数据包是未被发送或未被接收的。</li></ul></li><li><p>拥塞控制：当当前网路非常拥堵时，在发送数据可能会导致一个数据包在网络链路中传输时间超过最大生存时间也没有到达接收端，产生丢包的问题。</p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/202202281459101.png" alt="image-20220228145919053" style="zoom:67%;" /><ul><li><p>为了解决这个问题，TCP引入了慢启动机制，先发送少量的数据探路，然后根据情况来决定安装多大的速度来发送数据包。</p></li><li><p>在发送端开始时定义拥塞窗口大小为1，每次收到一个<code>ACK应答</code>，将拥塞窗口的值加1；每次发送数据时，发送窗口大小会取拥塞窗口和接收端的窗口大小中的最小值。</p></li><li><p><code>慢启动</code>、<code>拥塞避免</code>：在启动初期按照指数的方式增大拥塞窗口值，并设定一个阈值；当拥塞窗口大小达到阈值时，拥塞窗口按照线性的方式增长，直到达到网络拥塞；达到<code>网络拥塞</code>后进行<code>拥塞避免</code>，拥塞窗口大小重新变为1，<code>阈值</code>变为网络拥塞状态时拥塞窗口大小的一半，开启新一轮的慢启动。</p></li><li><p><code>快重传</code>，<code>快恢复</code>：在接收端需要对按序列接收到的报文中的最后一个进行确认。</p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/202202281514285.png" alt="image-20220228151442241" style="zoom:67%;" /><ul><li>假如发送端发送来 {M1，M2，M3，M4}，接收端接收到{M1，M2，M4}，那么接收端就会发送对{M2}的确认，重复三次，而发送端接收到同意报文段的三次确认后就知道下一报文段确实，进行快重传，重传下一个报文段M3。</li><li>此时发送端执行快恢复，将拥塞窗口的阈值设为当前拥塞窗口大小的一半，并将拥塞窗口大小设为当前阈值大小，直接进入拥塞避免。</li></ul></li></ul></li></ul><h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/202202272348807.png" alt="image-20220227232958154"></p><ul><li>客户端处于关闭状态，服务端处于监听状态</li><li>第一次握手，发送端向接收端发送连接请求，SYN=1, ACK=0,并选择一个初始序列号seq=x。<code>这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</code></li><li>第二次握手，接收端向发送端发送同意连接的确认报文，SYN=1，ACK=1，确认序列号ack=x+1,并选择一个初始序列号y。<code>这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。</code></li><li>第三次握手（避免错误的开启连接，同步双方的初始化序列号），发送端向接收端发送确认收到同意连接的报文，ACK=1，确认号=y+1, 序列号=x+1。<code>这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</code>第三次握手时也可以开始携带数据。</li><li>不是二次握手：防止A的请求连接报文在网络链路中滞留，这个已经失效的请求报文突然传送到B，B接收到A的请求连接时就会建立连接，但是A此时并没有请求连接，不会理会B的确认报文，此时A没有建立连接，B建立了连接。造成B的资源大量的浪费。</li><li>不是四次或更多的握手：三次握手就已经理论上最少可靠连接建立，之后更多次的握手也无法保证之后的连接的可靠性，会造成不必要的资源浪费。</li><li>三次握手的作用：<ol><li>确认双方的接受能力、发送能力是否正常。</li><li>指定自己的初始化序列号，为后面的可靠传送做准备。</li><li>如果是 https 协议的话，三次握手这个过程，还会进行数字证书的验证以及加密密钥的生成到。</li></ol></li></ul><blockquote><p><code>同步位SYN</code>：在建立连接时用来同步序号；当SYN=1，ACK=0时，表明这是一个连接请求报文段。当SYN=1，ACK=1时，表明这是一个连接接收报文段；</p><p><code>确认位ACK</code>：当ACK=1时，确认号ack才生效。在请求建立连接后（第一次握手后），所有的报文段都必须把ACK置1。</p><p><code>确认号ack</code>：期望收到的下一个报文段的第一个数据字节的序号，比如：B正确接收到了A发送过来的一个报文段，序号是501，数据长度是200字节；这表明B正确接收到了序号501-700的数据。所以，B期望的下一个序号是701，于是B在发送给A的确认报文段中确认号ack=701。</p></blockquote><blockquote><p><code>CLOSED</code>：初始关闭状态</p><p><code>LISTEN</code>：监听状态，等待客户连接</p><p><code>SYB-SENT</code>：同步已发送</p><p><code>SYN-RCVD</code>：同步已接收</p><p><code>ESTAB-LISHED</code>：已建立连接</p></blockquote><h3 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h3><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/202202281532662.png" alt="image-20220228153224623" style="zoom: 67%;" /><ul><li>初始状态双放都处于连接状态<code>ESTAB-LISHED</code></li><li>第一次挥手，客户端向服务端发送关闭连接请求，FIN=1， ACK=1，初始序列号seq=x</li><li>第二次挥手，接收端向客户端发送确认报文，ACK=1，确认序列号ack=x+1，选择初始序列号seq=y(用于客户端进行确认) 。此时TCP处于版关闭状态，B可以向A继续发送剩余未发送的数据，但是A不可以向B发送数据</li><li>第三次挥手，接收端向客户端发送关闭请求，FIN=1，ACK=1，确认号ack=x+1，选择初始序列号seq=w</li><li>第四次挥手，客户端向接收端发送确认关闭报文，ACK=1，确认报文ack=w+1，序列号seq=x+1。</li><li>A发出确认后，进入TIME-WAIT状态，等待2MSL（报文在网络链路中最大存活时间）后释放连接。<ul><li>确保最后一个报文可以到达。如果B没有收到A的确认报文，那么A就会进行重传确认报文，TIME-WAIT就是为了防止A关闭了，但是B还没有关闭。</li><li>等待一段时间让网络链路中的数据报文自动失效，防止下一个网络连接会获取到已失效的旧数据。</li></ul></li><li>B在收到A的确认报文后直接关闭</li></ul><blockquote><p><code>ESTAB-LISHED</code>：已建立连接</p></blockquote><blockquote><p><code>FIN-WAIT-1</code>：终止等待1</p><p><code>CLOSE-WAIT</code>：关闭等待</p><p><code>FIN-WAIT-2</code>：终止等待2</p><p><code>LAST-ACK</code>：最后确认</p><p><code>TIME-WAIT</code>：时间等待</p><p><code>CLOSED</code>：关闭</p></blockquote><h4 id="建立连接三次，释放连接四次"><a href="#建立连接三次，释放连接四次" class="headerlink" title="建立连接三次，释放连接四次"></a>建立连接三次，释放连接四次</h4><ol><li><p>建立连接时，确认ACK和同步SYN可以放在同一个报文中；而释放连接时，服务器肯还有数据需要传输，因此需要客户端先请求断开连接，避免服务端超时重传，当服务端没有数据发送之后，服务端请求断开连接。</p></li><li><p>断开比连接时多一次，是因为连接只需要处理连接，而断开需要处理连接+数据。</p></li><li><p>TCP时全双工通信，需要两边分别断开连接。</p></li></ol><h3 id="网络7层结构-各层作用"><a href="#网络7层结构-各层作用" class="headerlink" title="网络7层结构 各层作用"></a>网络7层结构 各层作用</h3><table><thead><tr><th align="center">OSI(七层网络模型)</th><th align="left">功能</th><th align="center">协议</th></tr></thead><tbody><tr><td align="center">应用层</td><td align="left">网络服务与程序的接口（人机交互页面），为特定的应用程序提供数据传输服务。</td><td align="center">HTTP，HTTPS，TFTP，SMTP，FTP，DNS</td></tr><tr><td align="center">表示层</td><td align="left">从应用层接收数据，数据的翻译、压缩和加密/解密</td><td align="center"></td></tr><tr><td align="center">会话层</td><td align="left">建立、解除、管理会话（连接）；完成通信进程的逻辑名字与物理名字间的对应；</td><td align="center"></td></tr><tr><td align="center">运输层</td><td align="left">为会话层实体提供透明、可靠的数据传输服务，保证端到端的数据完整性；选择网络层的最适宜的服务；提供建立、维护和拆除传输连接功能</td><td align="center">TCP、UDP</td></tr><tr><td align="center">网络层</td><td align="left">将接收到的数据段从一台计算机传输到位于不同网络中的另一台计算机</td><td align="center">IP、ARP（处于网络层和数据链路层之间）</td></tr><tr><td align="center">数据链路层</td><td align="left">负责在两个相邻结点间的线路上，无差错地传送以帧为单位的数据，并进行流量控制</td><td align="center">PPP，HDLC，CSMA/CD</td></tr><tr><td align="center">物理层</td><td align="left">提供建立、维护和拆除物理链路所需的机械、电气、功能和规程的特性；提供有关在传输介质上传输非结构的位流</td><td align="center">ISO2110，IEEE802</td></tr></tbody></table><h3 id="常用端口"><a href="#常用端口" class="headerlink" title="常用端口"></a>常用端口</h3><table><thead><tr><th align="center">应用</th><th align="center">应用层协议</th><th align="center">端口号</th><th align="center">传输层协议</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">域名解析</td><td align="center">DNS</td><td align="center">53</td><td align="center">UDP/TCP</td><td align="center">长度超过 512 字节时使用 TCP</td></tr><tr><td align="center">动态主机配置协议</td><td align="center">DHCP</td><td align="center">67/68</td><td align="center">UDP</td><td align="center"></td></tr><tr><td align="center">简单网络管理协议</td><td align="center">SNMP</td><td align="center">161/162</td><td align="center">UDP</td><td align="center"></td></tr><tr><td align="center">文件传送协议</td><td align="center">FTP</td><td align="center">20/21</td><td align="center">TCP</td><td align="center">控制连接 21，数据连接 20</td></tr><tr><td align="center">远程终端协议</td><td align="center">TELNET</td><td align="center">23</td><td align="center">TCP</td><td align="center"></td></tr><tr><td align="center">超文本传送协议</td><td align="center">HTTP</td><td align="center">80</td><td align="center">TCP</td><td align="center"></td></tr><tr><td align="center">简单邮件传送协议</td><td align="center">SMTP</td><td align="center">25</td><td align="center">TCP</td><td align="center"></td></tr><tr><td align="center">邮件读取协议</td><td align="center">POP3</td><td align="center">110</td><td align="center">TCP</td><td align="center"></td></tr><tr><td align="center">网际报文存取协议</td><td align="center">IMAP</td><td align="center">143</td><td align="center">TCP</td><td align="center"></td></tr><tr><td align="center">超文本传输安全协议</td><td align="center">HTTPS</td><td align="center">443</td><td align="center">TCP</td><td align="center"></td></tr></tbody></table><h3 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h3><p>DNS（域名系统），是将域名转为IP地址的网络协议</p><h4 id="DNS解析域名流程"><a href="#DNS解析域名流程" class="headerlink" title="DNS解析域名流程"></a>DNS解析域名流程</h4><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/202202282315913.png" alt="image-20220228231538797" style="zoom:80%;" /><ul><li>客户端通过浏览器访问 <a href="http://www.baidu.com(http//www.baidu.com)%EF%BC%8C%E5%8F%91%E8%B5%B7%E6%9F%A5%E8%AF%A2%E8%AF%A5%E5%9F%9F%E5%90%8D%E7%9A%84IP%E5%9C%B0%E5%9D%80%E7%9A%84DNS%E8%AF%B7%E6%B1%82%E3%80%82%E8%AF%B7%E6%B1%82%E4%BC%9A%E5%85%88%E5%8F%91%E9%80%81%E5%88%B0%E6%9C%AC%E5%9C%B0%E7%9A%84DNS%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E3%80%82%E6%9C%AC%E5%9C%B0DNS%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8E%B0%E5%9C%A8%E5%AE%83%E7%9A%84%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%E4%B8%AD%E6%9F%A5%E6%89%BE%E8%AF%A5%E5%9F%9F%E5%90%8D%E7%9A%84IP%E5%9C%B0%E5%9D%80%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%89%BE%E5%88%B0%E4%BA%86%E5%B0%B1%E4%BC%9A%E7%9B%B4%E6%8E%A5%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%EF%BC%8C%E5%90%A6%E5%88%99%E4%BC%9A%E5%90%91%E6%A0%B9%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9B%E8%A1%8C%E6%9F%A5%E8%AF%A2%E3%80%82">www.baidu.com(http://www.baidu.com)，发起查询该域名的IP地址的DNS请求。请求会先发送到本地的DNS服务器上。本地DNS服务器现在它的本地缓存中查找该域名的IP地址，如果找到了就会直接返回结果，否则会向根服务器进行查询。</a></li><li>本地服务器向根服务器发送查询该域名的IP地址的请求。</li><li>根服务器经过检查，如果有会向本地服务器返回结果，否则会给出顶级域名服务器（.com,.org,.cn）的地址。</li><li>本地服务器向顶级域名服务器（.com）发起该查询该域名的IP地址的请求。</li><li>顶级域名服务器收到请求后，不会直接返回域名和IP的对应关系，而是告诉本地DNS服务器，该域名可以在baidu.com域名服务器上进行解析获取IP地址，并将baidu.com域名服务器的地址返回给本地DNS服务器</li><li>本地服务器向baidu.com域名服务器发起该查询该域名的IP地址的请求。</li><li>baidu.com域名服务器收到查询请求后，在自己的缓存列表中发现了该域名和IP地址的对应关系，并将IP地址返回给本地DNS服务器</li><li>本地DNS服务器获得该域名对应的IP地址后，将其保存在本地缓存中，并返回给客户端</li></ul><h4 id="多级缓存系统"><a href="#多级缓存系统" class="headerlink" title="多级缓存系统"></a>多级缓存系统</h4><p>为了满足DNS的高效、快速的查询，整个DNS系统，需要按照分布式系统架构来设计，并且，前面提到的本地DNS查询服务器，它是离客户最近的DNS解析服务器，类似于CDN的边缘节点，除了直接把域名解析的结果缓存起来，也会试图把整个分布式的DNS管理服务器的数据，按照树型组织集中缓存在本地，这就是所谓的多级缓存！</p><p>用户查询<a href="http://www.baidu.com域名,会先到本地dns服务器中查找,有则直接返回结构,如果没有就查找/">www.baidu.com域名，会先到本地DNS服务器中查找，有则直接返回结构，如果没有就查找</a> .com，依次向上查找，如果都没有就会去根服务器查找。</p><p>用户在解析域名时，会先在本地域名服务器查找，如果没有就会去查找对应的缓存，如果没有就会依次去上级缓存中查找，如果顶级域名缓存中也没有就会去根服务器中查找，依次查询，直至找到该域名对应的IP地址。</p><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p><code>HTTP</code>：超文本传输协议（HyperText Transfer Protocol），是互联网上应用最广泛的一种网络协议之一，HTTP设计的最初目的是为了提供一种发布和接收HTML的方法，是一个专门在两点之间传输文本，音频，图片，视频等超文本数据的约定和规范。</p><ul><li><p>由三部分组成：超文本、传输、协议</p></li><li><p>目前广泛使用的是HTTP/1.1版本</p></li><li><p>HTTP是一个基于TCP/IP通信协议来传递信息的协议。</p></li></ul><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ul><li>客户端访问<a href="http://www.baidu.com,dns将域名解析为对应的ip地址/">www.baidu.com，DNS将域名解析为对应的IP地址</a></li><li>客户端发起TCP连接，与服务器进行三次握手建立连接</li><li>客户端发送HTTP请求到服务器</li><li>服务器发送HTTP响应到客户端</li><li>客户端将得到的对应的HTML代码和资源渲染到前端页面</li></ul><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li><p>支持 客户端/服务器 模式，也是一种 请求/响应模式的协议</p></li><li><p>简单快速。客户端向服务器发送请求时，只需要传送 请求方法和路径。</p></li><li><p>灵活。HTTP允许传输任意类型的数据。传输数据的类型可以通过 Content-Type来指定</p><ul><li><p>常见的媒体格式类型如下：</p><p>text/html ： HTML格式</p><p>text/plain ：纯文本格式</p><p>text/xml ： XML格式</p><p>image/gif ：gif图片格式</p><p>image/jpeg ：jpg图片格式</p><p>image/png：png图片格式</p></li><li><p>以application开头的媒体格式类型：</p><p>application/xhtml+xml ：XHTML格式</p><p>application/xml： XML数据格式</p><p>application/atom+xml ：Atom XML聚合格式</p><p>application/json： JSON数据格式</p><p>application/pdf：pdf格式</p><p>application/msword ： Word文档格式</p><p>application/octet-stream ： 二进制流数据（如常见的文件下载）</p><p>application/x-www-form-urlencoded ： <form encType="">中默认的encType，form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式）</p></li><li><p> 另外一种常见的媒体格式是上传文件之时使用的：</p></li></ul><p>  multipart/form-data ： 需要在表单中进行文件上传时，就需要使用该格式</p><ul><li><p> 无连接：限制每一个连接只能处理一个请求。服务器处理完客户请求，并收到客户的确认后，就断开连接。</p></li><li><p>采用这种方式可以节省传输时间，但是随着网页越来越复杂，需求越来越复杂，HTTP使用了一个 Keep-Alive的功能，使的客户端到服务器端的连接一直有效（超出规定的时间，或者意外断电等情况除外），避免了客户端发送多个请求时需要重复建立TCP连接，提高了效率，但是占用了更多的资源。</p></li><li><p>无状态：HTTP协议对于事物的处理没有记忆能力，服务器不知道客户端的情况。客户端每次发送请求，服务器将响应结果发送会给客户端后，不会记录任何信息。意味着每个HTTP请求都是独立的。</p><ul><li>无连接状态是的服务器不会占用过多的资源，但是在需要前面的信息时就需要重传前面的数据，导致数据量增大</li><li>为了保存状态，采用了Cookie和Session。Cookie时在客户端保存状态，通常是保存用户的基本信息，在一定的时间内都会保存在浏览器中，在下次发送请求时就可以简化操作，但是保存的数据大小有限。Session是在服务器端保存状态，服务器为Session设置一个过期时间，并分配一个SessionId，将Session保存在客户端的无过期时间Cookie中，每一次用户只需将sessionId传过来就可以在服务器中获取到状态信息，这种方式保存的状态数据大小没有限制，且当浏览器意外关闭后状态信息也不会立刻消失。</li></ul></li></ul></li></ul><h4 id="URI和URL"><a href="#URI和URL" class="headerlink" title="URI和URL"></a>URI和URL</h4><p>HTTP中使用URI（统一资源标识符）来建立连接和传输数据</p><ul><li>URI：Uniform Resource Identifier 统一资源<strong>标识</strong>符</li><li>URL：Uniform Resource Location 统一资源<strong>定位</strong>符</li></ul><p>URI 是用来标示 一个具体的资源的，我们可以通过 URI 知道一个资源是什么。不涉及规范协议</p><p>URL 则是用来定位具体的资源的，标示了一个具体的资源位置。互联网上的每个文件都有一个唯一的URL。需要指定对应的协议</p><h4 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h4><ul><li>请求报文</li></ul><ol><li>请求行：包括请求方法、URL、协议/版本</li><li>请求头(Request Header)</li><li>请求正文</li></ol><ul><li>响应报文</li></ul><ol><li>状态行</li><li>响应头</li><li>响应正文</li></ol><h4 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h4><ul><li>请求信息明文传输，容易被拦截监听。</li><li>数据没有校验，容易出现被篡改的情况</li><li>没有验证对方的身份，容易出现冒充的危险</li></ul><p>HTTP协议不适合传输一些敏感的信息，例如账号密码等。</p><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><h4 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h4><p><code>HTTPS</code>：相当于HTTP+SSL/TLS，是在HTTP的基础上加上了加密传输和身份认证等功能。</p><p><code>明文</code>：没有经过加密的原始数据。</p><p><code>密钥</code>：通常是一串字符或者数字，以供加密或解密算法使用。公钥和私钥都属于密钥，公钥被公开用于加密，私钥不会公开，用于解密</p><p><code>非对称加密算法</code>：公钥加密后只能由私钥解密，私钥加密后，只能由公钥加密，而且一方的加密内容只能由另一方来解密，通常用来加密密钥，防止泄露。</p><ul><li>机密算法：RSA、DSA/DSS、Elgamal、Rabin、D-H、ECC···</li></ul><p><code>加密算法</code>：加密和解密使用的是同一个密钥，通常用来加密消息体。</p><ul><li>加密算法：AES、DES、3DES、TDEA、Blowfish、RC4、RC5、IDEA···</li></ul><p><code>数字证书</code>：包含证书的发布机构，证书有效期，公钥，证书所有人，签名使用的算法，指纹和指纹算法。数字证书可以保证里面的的公钥一定是证书所有人的。</p><p><code>数字签名</code>：数据明文通过HASH算法加密生成摘要，再将摘要通过客户端私钥通过非对称加密算法加密后，生成数据签名。下级证书或者客户端需要时就返回这个整体，数字签名的主要作用是配合HASH算法保证信息没有被修改，当HTTP的身份验证通过之后，一般会改用对称加密的方式通信。</p><p><code>证书链</code>：证书是分级的，证书链由多个证书一级一级的组成，拿到上级证书的公钥才能解密本机证书。只有最底层的证书才是自己颁发给自己的自签证书。</p><h4 id="数字签名流程"><a href="#数字签名流程" class="headerlink" title="数字签名流程"></a>数字签名流程</h4><p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/202203021644446.png" alt="image-20220302164406356"></p><h4 id="HTTPS请求的流程"><a href="#HTTPS请求的流程" class="headerlink" title="HTTPS请求的流程"></a>HTTPS请求的流程</h4><p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/202203022038780.gif" alt="HTTPS请求流程"></p><ul><li>服务器在提供服务前在本地生成公钥和私钥</li><li>服务器将公钥发送给CA机构</li><li>CA机构使用自己的私钥对服务器的公钥进行签名，向服务器提供数字证书，并将证书添加到证书链中</li><li>用户向服务器发送请求，告知自己的加密算法</li><li>服务器确认用户的加密算法后，提供自己的CA数字证书</li><li>客户的浏览器中会预装CA机构的根证书，浏览器对服务器发送过来的CA数字证书进行验证<ul><li>解析证书，获取发布机构，在系统预装的信任机构中查找</li><li>找到但验证无效和未找到都会提示风险</li><li>验证流程：<ul><li>使用CA公钥解密算法，解密出数字签名（s1），使用签名算法对s1进行签名，获得s2</li><li>将s2和s1进行对比</li><li>相同则有效，不同则无效</li></ul></li><li>找到并有效则会直接生成随机的密钥（R），并使用服务器的公钥对其加密</li></ul></li><li>客户端将加密后的密钥R发送给服务器</li><li>服务器用自己的私钥将R解密出来</li><li>服务器使用R将要发送给客户端的数据使用对称加密算法加密后发送给客户端</li><li>客户端使用R将服务器发送来的数据进行解密</li><li>之后双方达成一致，开始使用对称加密算法进行通信</li></ul><h3 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h3><ul><li>HTTP的安全性低，数据在网络中是明文传输的</li><li>HTTPS的安全性高，每次处理请求之前都会对发送方的身份进行验证。</li><li>HTTP的效率高，HTTP建立来连接只需要三次握手即可，但是HTTPS不仅需要三次握手，还需要进行身份认证，多出了9个包。</li><li>HTTP的默认端口是80，HTTPS的默认端口是443。</li><li>HTTPS 相当于 HTTP + TSL/SSL，在HTTP和TCP之间加了一层SSL/TSL，消耗的资源更多。</li></ul><h3 id="Http-协议中get-和-post-方法的根本区别是什么"><a href="#Http-协议中get-和-post-方法的根本区别是什么" class="headerlink" title="Http 协议中get 和 post 方法的根本区别是什么"></a>Http 协议中get 和 post 方法的根本区别是什么</h3><ul><li><p>GET请求不会修改信息（查询），POST可能涉及到信息的写入或修改</p></li><li><p>GET的请求参数都在URL中，POST的请求参数在请求体中。GET请求的安全性更差，不适合提交敏感信息</p></li><li><p>GET请求的参数大小受到浏览器的限制（常见1K，一般2~8K），POST的可以使用更大的参数（无限制）</p></li><li><p>GET和POST都是HTTP请求方式，基于TCP/IP协议。GET请求在TCP第三次握手时就会将请求头和数据一起发送给服务器；而POST请求，在发送数据之前，会在TCP第三次握手时将请求头先发送给服务区用于确认（等到服务器发送100 Continue响应时才会开始发送数据），所以GET请求的响应时间比POST请求的响应时间更快</p></li><li><p>POST可以发送更多的数据类型（multipart/form-data等），GET只能发送ASCII码（application-x-www-form-urlencoded）</p></li><li><p>GET请求会将获取到的资源缓存在本地（根据浏览器不同，缓存的数据也不同），减少下次访问花费的时间，POST则不会将资源缓存</p></li><li><p>GET请求时幂等的，即发送一个请求和发送多次请求的结构都是一样的，而POST调用多次每次都会增加记录。</p></li></ul><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p>索引的作用是快速的在一张表中找到目标数据。如果不使用索引的话，就需要从表的第一条记录一直向后查找，找到相关的数据，表越大，查询话费的时间也会越久。当表中的已和列有索引时，就会根据索引去索引表中查找，避免从头遍历，节省时间。</p><p><strong>优点</strong>：</p><ul><li>可以给表中任意字段设置索引</li><li>大大加快查询的时间</li></ul><p><strong>缺点</strong>：</p><ul><li>创建索引和维护索引需要耗费时间。表中的数据量越大，花费的时间也会越大。</li><li>索引也会占用空间。随着数据量的增大，索引占用的空间也会越大</li><li>当对表中的数据进行增删改操作时，索引表也会做出修改，降低了数据的维护速度</li></ul><p>索引需要合理使用，并不是每个字段都设置索引好，索引也不是越多越好。</p><ul><li>经常进行更新的表就要避免设置过多的索引，对于经常用于查询的字段应该创建索引</li><li>数据量较小的数据库可以不创建索引。遍历数据库表的时间可能比使用索引更快</li><li>对于相同值较多的字段不要建立索引，在不同值较多的字段建议创建索引。</li></ul><p><strong>分类</strong>：</p><blockquote><p>索引实在存储引擎中实现的，所以不同的存储引擎会使用不同的索引</p><p><code>InnoDB</code>、<code>MyISAM</code>：只支持<code>BTREE</code>索引</p><p><code>MEMORY/HEAP</code>：支持<code>HASH</code>和<code>BTREE</code>索引</p></blockquote><ul><li>单列索引<ul><li>普通索引：是基本索引类型，没有什么限制，允许在定义索引的列中插入重复数据和空数据，单纯为了加快查询速度</li><li>唯一索引：索引的列值只能是唯一的，但是可以为空</li><li>主键索引：索引列中的值不允许为空，并且只能唯一</li></ul></li><li>组合索引：在表中的多个字段上建立索引，只有在查询条件使用了组合索引的左边字段时。所以才会被使用，使用索引时，遵循最左前缀集合。</li><li>全文索引：只有在MyISAM引擎上才能使用，并且只能在CHAR，VARCHAR，TEXT类型的字段上才能建立索</li><li>空间索引：只有MyISAM引擎上才能用，只能对空间类型且NOT NULL的字段建立索引。MYSQL的空间类型只有GEOMETRY、POINT、LINESTRING、POLYGON。建立索引时需要使用SPACE关键字。</li></ul><h4 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h4><ul><li>InnoDB：支持实务操作（rollback，begin，commit等），支持行级锁。行级锁相对于表级锁的粒度更细，可以支持更多的并发。这也是MYSQL5.7之后的默认存储引擎，缺点是占用的空间会比较大</li><li>MyISAM：占用的空间相对于MyISAM较小，但是不支持事务，只支持表级锁，并发性能较低。通常用于只读模式。是最原始的存储引擎 </li><li>Memory/Heap：所有的数据都保存在内存中（不安全）。通常用于保存一些非关键数据且需要快速访问的。</li><li>CSV</li><li>Archive：存档文件。主要用于存储很少用到的引用文件</li><li>Blackhole：</li><li>Merge：</li><li>Federated：</li><li>Example</li></ul><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p>事务是一条或者一组SQL语句，这些语句要么全部执行，要么全部不执行。</p><p>四个特性（ACID）：</p><ul><li><p>A(原子性)：指一个事务不可以再分割。</p></li><li><p>C(一致性)：事务使数据库需要从一个一制状态到另一个一致状态</p></li><li><p>I(隔离性)：指一个事务的执行不会受到另一个事务的干扰</p></li><li><p>D(持久性)：事务一旦提交，那么对数据库的更改就是永久的</p></li></ul><h4 id="事务并发导致的问题"><a href="#事务并发导致的问题" class="headerlink" title="事务并发导致的问题"></a>事务并发导致的问题</h4><ul><li>更新丢失：当两个事物并发操作同一个数据时，双方不知道对方的存在，最后一个修改的人会覆盖前一个修改</li><li>读脏数据：一个事务修改了某一条数据，还没有提交，此时一个事务读取了这条数据，由于修改事务没有提交，会导致读取事务读到的是失效的旧数据。</li><li>不可重复读：一个事务读取了是个数据后，另一个事务对这个数据进行了修改，导致这个事务再次读取这个数据后，发现数据发生了改变。</li><li>幻读：一个事务开始时查询一个数据没有查到，此时一个事务添加了数据，导致这个事务再次读取时，查询到了数据，就像产生了幻觉。</li></ul><h4 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h4><ul><li>读未提交：在一个事务还没有提交时就可以读取数据，会导致读脏数据，容易出现数据错乱的情况，很难追踪</li><li>读提交：在事务提交之后才能读数据。解决了读脏数据，但是没有解决不可重复读</li><li>可重复读：事务A一旦开始执行，无论B怎么修改数据，A读取到的都是第一次读取到的值。解决了不可重复读，解决不了幻读</li><li>串行化：将一个个事务串行执行。因为没有了并发，所以就没有并发导致的所有问题，但是性能较低。</li></ul><table><thead><tr><th>事务隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交（read-uncommitted）</td><td>是</td><td>是</td><td>是</td></tr><tr><td>读提交（read-committed）</td><td>否</td><td>是</td><td>是</td></tr><tr><td>可重复读（repeatable-read）</td><td>否</td><td>否</td><td>是</td></tr><tr><td>串行化（serializable）</td><td>否</td><td>否</td><td>否</td></tr></tbody></table><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p>B Tree（Balance Tree） 是平衡树。平衡树是查找树，所有的叶子结点都在同一层。</p><p>B+ Tree 是在B Tree的基础上增加了通过叶子结点顺序访问指针进行实现的。它具有平衡数的平衡新，同时也使用顺序访问指针提高了区间查询的性能。</p><p>在B+ Tree中，一个节点中的Key呈现非递减的顺序排列。当前位置右侧的key一定大于等于当前key。</p><p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/202203041058318.png" alt="image-20220304105830855"></p><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul><li>每一个节点可以存储更多的关键字</li><li>进行全库或全表扫描的能力更强，只需要遍历叶子结点即可，无需遍历整棵B+Tree</li><li>磁盘读写能力更强，只有叶子结点才存储数据，所以内存一次性可以读取更多的索引，减少了I/O次数</li><li>范围查询和排序能力强，每一个叶子结点上都有下一个区的指针</li><li>效率稳定。因为每一次查询的效率都是O(log(N)) (N是数据量)</li></ul><h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><p>在进行查找操作时，会在根节点进行二分查找，找到一个Key所在的指针，再指针递归的在当前指针指向的结点中查找。找到查找到叶子结点，在叶子节点中进行二分查找，找出Key对应的Data。</p><p>在进行插入和删除操作是都会破坏平衡树的平衡性，因此在进行插入删除操作后，需要对当前树进行分类、合并、旋转等操作来保持平衡性。</p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>B+Tree 是 <strong>稳定的</strong> O(log(n))</p><p>B-Tree <strong>最好</strong>是O(1)，<strong>最差</strong>是O(log(n))</p><h4 id="与B-Tree的区别"><a href="#与B-Tree的区别" class="headerlink" title="与B-Tree的区别"></a>与B-Tree的区别</h4><ul><li>B-Tree的每一个节点都带有数据,只要找到目标,就可以直接返回；B+Tree只有叶子结点才带有数据，所以找到目标之后，还需要继续向下到叶子结点中去返回数据。B-Tree每一次加载到内存的数据少于B+Tree，在需要进行大量与磁盘进行I/O操作的时候，B+Tree相对来说比较稳定。</li><li>B-Tree是直接将索引和数据一起分区，B+Tree只将索引进行分区。</li><li>B+Tree的分支节点中有m个关键字，那么其叶子结点中也只有m个关键字；B-Tree有m个子节点，但是只有m-1个关键字</li><li>B+Tree的分支节点中存储的是关键字信息和儿子节点的指针，内部节点结构只包含关键字；B-Tree的子节点存储关键字和其对应的数据和儿子节点的指针，内部包含关键字和数据。</li><li>B+Tree建立了顺序访问指针，可以在区间之间访问</li></ul><h4 id="与红黑树的区别"><a href="#与红黑树的区别" class="headerlink" title="与红黑树的区别"></a>与红黑树的区别</h4><p>红黑树也是平衡树，但是在文件系统和数据库系统中，多采用B+Tree来作为索引结构，因为使用B+Tree来访问磁盘会有更高的性能。</p><ul><li>B+Tree的树的高度要小于红黑树，因为B+Tree的节点出度可以很大，而红黑树的出度只能是2.</li><li>操作系统一般将内存和磁盘分为固定大小的块，每一块称为一页，内存和磁盘按照页来交换数据。内存中存储的数据是有限的，所以在访问大量的数据时，内存只会读取相关的部分数据，当涉及到修改数据时，红黑树的结构会发生大量的改动，可能会频繁的和磁盘交换数据，导致效率低下。所以B+Tree更适合磁盘读取。</li></ul><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>当用户需要对数据库中的一张或多张表中的数据进行频繁的查询的话,可以定义一个视图，视图同样包含行和列，但是视图的数据都来自基表，视图的数据在使用时都是动态从基表中获取的。</p><p>视图是一个虚拟的表。数据库中只存储了视图的结构，数据都在基表中。所以当基表中的数据发生改变后，视图中获取到的数据也会发生改变。</p><p>视图的作用：</p><ul><li>简单性。简化用户对数据的理解，简化用户的操作。可以将一些经常使用或复杂的查询操作定义为一个视图，以后再次查询的时候就不要指定复杂的条件，简化SQL语句。</li><li>安全性。可以隐藏一些数据，可以防止未授权的用户查看特定的列或行，使有权限的用户只获取到特定的行或列。<ul><li>在表中加上一个标志用户的列</li><li>简历视图后，用户只能获取到标有自己用户名的数据</li></ul></li><li>逻辑数据独立性。视图可以使数据库和应用程序之间在一定程度上独立。没有视图的时候，应用程序一定是建立在数据表上，有了视图之后，应用程序可以建立在视图之上，将数据库表和应用程序分隔开。</li><li>在视图中可以指定一些计算列。例如基础表中有商品数量和单价，视图中可以直接计算总销售额并保存为一个字段</li></ul><p>视图的缺点：</p><ul><li>性能可能会比较差，尤其是引用其他视图的时候</li><li>在数据库表的结构发生修改后，视图也需要做出相应的修改</li></ul><blockquote><p>创建，修改和删除视图都需要相对应的权限</p></blockquote><p>通过视图修改数据库表的数据需要满足一定的条件：</p><ul><li>视图只能基于一张基础表</li><li>视图中包含可更新列，这些列是基础表的引用</li><li>视图定义不能包含WITH、DISTINCT、GROUP BY、ORDER BY、FOR UPDATE、FOR SHARE、HAVING、TABLESAMPLE、LIMIT、OFFSET子句。</li><li>视图定义不能包含UNION、INTERSECT、EXCEPT集合操作。</li><li>视图定义的选择列表不能包含聚集函数、窗口函数、返回集合的函数。</li><li>视图上不能有触发时机为INSTEAD OF的触发器。</li></ul><h3 id="数据库中delete和drop的区别"><a href="#数据库中delete和drop的区别" class="headerlink" title="数据库中delete和drop的区别"></a>数据库中delete和drop的区别</h3><ul><li>delete是DML（数据操纵型语言），对数据进行操作；而drop是DDL（数据定义型语言），直接对表进行操作</li><li>delete操作会被记录在<code>redo</code>和<code>undo</code>表空间中，方便后续的重做和回滚操作，而且只有执行commit后，操作才会真正生效。</li><li>drop是隐式commit的，所以不需要手动提交，同时也不支持回滚和重做操作。</li><li>delete删除的是表中的记录，不会改变表的结构，同时支持使用where进行条件过滤，删除部分数据。</li><li>drop不仅会会删除对应的记录也会删除表的结构，并将表的那一部分空间释放掉，同时删除掉该表的结构依赖的约束，触发器，索引，依赖于该表的约束，触发器，索引会变为invalid状态。</li><li>一般来说，drop的速度比delete快</li></ul><h3 id="手写SQL-查找平均分大于60的学生"><a href="#手写SQL-查找平均分大于60的学生" class="headerlink" title="手写SQL 查找平均分大于60的学生"></a>手写SQL 查找平均分大于60的学生</h3><p>select stu_id from score group by stu_id having avg(score) &gt; 60;</p><h3 id="SQL注入问题"><a href="#SQL注入问题" class="headerlink" title="SQL注入问题"></a>SQL注入问题</h3><p>用户在传入的参数中夹杂着恶意的SQL语句或条件</p><p>例如：执行select * from user where id=?</p><p>在这里用户输入了 1; delete from user</p><p>最终执行的SQL语句就变成了 <code>select * from user where id=1; delete from user</code></p><p>由于MYSQL将会执行两条SQL语句，将user表中的数据全部删除掉。</p><h4 id="预防"><a href="#预防" class="headerlink" title="预防"></a>预防</h4><ul><li>检查传入参数的类型和格式</li><li>过滤特殊符号</li><li>使用参数化的SQL语句，绑定变量进行预编译</li><li>给用户进行权限限制</li></ul><h4 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h4><p>MYSQL的mysqli驱动提供了预编译的功能。不同的编程语言也有对应的预编译函数。</p><p>在执行SQL语句的时候，会进行三个流程：</p><ul><li>词法和语义解析</li><li>优化SQL语句，制定执行计划</li><li>执行，并返回结构</li></ul><p>预编译是将变量部分先空着，执行前两个步骤，最后再将参数填入进去</p><p>这样可以实现一次编译，多次运行的目的，同时也加快了SQL的执行效率</p><p>这样也是最好的避免SQL注入的方式 </p><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>在每一次操作数据库的时候，都认为他不会对数据进行修改，不会对数据加锁，而是增加一个version字段。</p><p>每次发现数据发生修改后，会进行一个版本号的改变。当一个进程对数据进行修改后，另一个进程发现版本号发生改变，就会操作失败，避免了并发造成的错误。</p><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>在每一次操作数据库的时候，都认为他会对数据进行修改，会对数据加锁。</p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>两个或两个以上的进程进行资源争夺，导致每个进行都在等待其他进程是释放资源，造成一种相互等待的现象。</p><p>死锁的四个必要条件（只要一个不满足都不会发生死锁）：</p><ul><li>互斥条件：一个资源每次只能被一个进程使用</li><li>请求与保持条件：进程因资源请求而阻塞时，会保持资源的占有状态</li><li>不可剥夺条件：进程获得资源之后，在进程结束之前，不是释放已有资源</li><li>循环等待条件：若干进程之间形成一个头尾相连的循环资源等待现象。</li></ul><p>死锁的产生原因：</p><ul><li>资源分配不当</li><li>进程的推进顺序不当</li><li>系统资源不足</li></ul><h3 id="如何进行范围查找的"><a href="#如何进行范围查找的" class="headerlink" title="如何进行范围查找的"></a>如何进行范围查找的</h3><ul><li>(not) in</li><li>&lt;、&gt;、&gt;=、&lt;=</li><li>(not) between···and···</li><li>is null / is not null</li></ul><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><ul><li><code>Redis</code>是使用C语言编写的一个基于内存的 高性能key-value 非关系型缓存数据库。</li><li>因为Redis的数据都在内存中，所以Redis的效率非常高，每秒可以处理超过10W次的I/O操作。</li><li>Redis也可以将数据存入到硬盘中，保证了数据的安全性，而且Redis的操作都是原子性的。</li><li>Redis是单进程单线程的，使用队列技术将并发执行的操作转为串行操作，省去了很多上下文切换的时间以及CPU资源的消耗，不存在竞争问题，也就不需要加锁。</li><li>一个String类型的值最大存储空间是 512MB</li></ul><h4 id="基础数据结构"><a href="#基础数据结构" class="headerlink" title="基础数据结构"></a>基础数据结构</h4><ul><li>String：Redis最基本的数据类型，一个键对应一个值，一个键值最大存储512MB</li><li>set：是String字符串类型的无序集合，也不可重复</li><li>zset：是String类型的有序集合，也不可重复。有序集合中的每个元素都需要指定一个分数，根据分数对元素进行升序排序</li><li>hash：hash是一个键值对的集合，是一个String类型的field和value的映射表，适合用于存储对象</li><li>list：是redis的简单的字符串列表，按插入顺序排序</li></ul><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li>缓存（session，token···）</li><li>消息队列</li><li>计数，热评</li><li>发布订阅消息通知</li><li>···</li></ul><h4 id="持久化机制"><a href="#持久化机制" class="headerlink" title="持久化机制"></a>持久化机制</h4><h5 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h5><p>RDB是Redis Database缩写快照，它是Redis默认的持久化方式。按照一定的时间间隔将Redis中的数据以快照的形式保存到硬盘中，对应的数据快照文件是 <code>dump.rdb</code>。可以通过配置文件中的save参数来设置保存快照的周期。</p><p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/202204022354547.png" alt="image-20220402235353453"></p><ul><li>优点：<ul><li>快照文件只会有<code>dump.rdb</code>这一个，保存和恢复方便。</li><li>容灾性好，快照文件可以保存到安全的硬盘中。</li><li>性能最大化，使用fork子进程来执行持久化，主进程不会进行任何的I/O操作，保证了Redis的高性能</li><li>在数据集较大时，启动速度会比AOF快</li></ul></li><li>缺点：<ul><li>数据安全性低，在Redis保存快照之前发生故障的话，可能会发生数据丢失的情况</li></ul></li></ul><h5 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h5><p>AOF是 Append Only File持久化，将Redis的每一条写命令都记录到一个日志文件中，当重启Redis时，会从持久化的日志文件中恢复数据。</p><p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/202204030003502.png" alt="image-20220403000343422"></p><ul><li>优点：<ul><li>数据安全，AOF持久化可以在配置文件中设置 Appendfsync 属性为 always，即每进行一次操作都会将其添加到日志文件中</li><li>通过append模式记录操作，及时服务器中途宕机，日志文件也会保存下来，通过Redis-check-aof工具来解决数据一致性的问题</li><li>AOF有rewrite模式。在日志文件没有被rewrite之前（日志文件过大会将日志文件进行重写），可以删除其中的一些操作。</li></ul></li><li>缺点：<ul><li>AOF文件比RDB文件大，恢复时的速度较慢</li><li>数据集较大时，启动速度比RDB慢</li></ul></li></ul><h4 id="雪崩"><a href="#雪崩" class="headerlink" title="雪崩"></a>雪崩</h4><p>​        如果缓存在某一时刻出现大量的key失效，导致大量的请求发送给数据库，是数据库的压力骤增。在高并发的情况下可能出现数据库宕机的。这就是缓存雪崩。</p><p>原因：</p><ul><li>Redis宕机</li><li>同一时刻出现大量时效的key</li></ul><p>解决方案：</p><ul><li><p>事前</p><ul><li><p>均匀过期：为缓存设置不同的过期时间，尽量避免同一时刻出现大量的过期数据。</p></li><li><p>分级缓存：第一级缓存失效的情况下去访问二级缓存，每一级的缓存过期时间均不相同</p></li><li><p>热门数据永不过期</p></li><li><p>保证Redis的高可用，防止Redis宕机导致的缓存雪崩。使用 主从模式+ 哨兵机制的模式搭建Redis，使用Redis集群，避免Redis全盘崩溃。</p></li></ul></li><li><p>事中</p><ul><li>使用熔断机制，限流降级。当一时间访问数据库的请求达到一个阈值之后，直接返回“系统拥挤”的消息，防止过多的请求访问数据库。</li></ul></li><li><p>事后</p><ul><li>开启缓存的持久化操作，在缓存崩溃之后快速的恢复数据。</li></ul></li></ul><h4 id="击穿"><a href="#击穿" class="headerlink" title="击穿"></a>击穿</h4><p>缓存击穿与缓存雪崩相似，雪崩是同一时间大量的key失效，而击穿是某一个热点key失效，大量的请求没有获取缓存，导致大量的请求打在数据库上，大量并发请求，使得数据库压力骤增。</p><p>解决方法：</p><ul><li>热点key永不失效</li><li>使用熔断机制，控制同一时间数据库的请求的数量。</li></ul><h4 id="穿透"><a href="#穿透" class="headerlink" title="穿透"></a>穿透</h4><p>缓存穿透是用户请求的key在Redis中没有，在数据库中也没有，导致用户每一次发起该请求都需要到数据库中查询一次。如果同一时间大量的请求落在数据库之上可能会导致数据库宕机。</p><p>解决方法：</p><ul><li>将无效的key存入Redis中<ul><li>Redis没遇到一个无效的key都将其放入缓存中面，并将过期时间设置的极短。当用户再次请求该key时，就会直接从Redis中知道该key是无效的。</li><li>当用户发出的key都是随机的时候，该方法就不适用了</li></ul></li><li>使用布隆过滤器<ul><li>将所有的key都存入布隆过滤器中，用户在获取缓存之前会先经过布隆过滤器判断key是否有效。如果布隆过滤器中存在则说明该key存在，如果布隆过滤器中不存在，那么极大的概率数据库中也不存在。避免了对数据库的访问压力。</li></ul></li></ul><h3 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h3><p>Redis3.0之后加入了Redis的集群模式，实现了缓存的分布式存储，对数据进行分片，将不同的数据存放到不同的Master节点中</p><h4 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h4><ol><li>启动节点：将节点以集群的方式启动，此时节点是独立的</li><li>节点握手：将独立的节点连成网络</li><li>hash槽指派：将16384个槽分配给每一个节点，达到分片存储数据的目的</li><li>主从复制：为从节点指定主节点</li></ol><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><p>​        Redis的单实例模式下，实现了读写分离，解决了读操作的负载均衡，但是写操作都是由master节点来实现，在海量数据高并发的情况下会导致master节点的压力骤增。</p><p>​        Redis的单例模式实际上只有一台master节点来存储数据，当存储的数据量过大时，一台服务器可能就不够用了。数据量过大会使持久化的成本过高，可能会阻塞服务器，降低服务的稳定性</p><p>​        Redis集群很好的解决了这两个问题。</p><h4 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h4><p>Redis集群中的节点使用gossip协议进行通信</p><h4 id="数据分布算法"><a href="#数据分布算法" class="headerlink" title="数据分布算法"></a>数据分布算法</h4><p>Redis集群采用哈希槽分区算法对数据进行分区。Redis集群中有16384个哈希槽，将不同的哈希槽分布在不同的节点上进行存储，每一个节点只负责一部分哈希槽。对数据进行操作时，集群会使用CRC16算法对数据进行计算，并将结果对16384进行取模，得到的结果就是该键值对要放入的哈希槽。</p><h4 id="使用哈希槽好处"><a href="#使用哈希槽好处" class="headerlink" title="使用哈希槽好处"></a>使用哈希槽好处</h4><p>使用哈希槽可以方便集群中节点的添加和删除。无论是添加或删除节点都不会造成集群不可用，添加节点只需将每个节点的部分哈希槽挪给该节点即可；删除哈希槽只需将该节点的哈希槽挪给其他节点即可</p><ul><li>解耦数据与节点之间的关系，简化了扩容和收缩的难度</li><li>节点自身维护槽的映射关系，不需要客户端代理服务维护槽分区的元数据</li><li>支持槽，节点，键之间的映射查询</li></ul><h4 id="集群扩容"><a href="#集群扩容" class="headerlink" title="集群扩容"></a>集群扩容</h4><ul><li>启动新节点</li><li>使用 cluster meet 命令将节点加入集群中</li><li>为节点分配和指定哈希槽，并将对应的数据迁移过来</li></ul><h4 id="集群收缩"><a href="#集群收缩" class="headerlink" title="集群收缩"></a>集群收缩</h4><ul><li>迁移哈希槽</li><li>忘记节点。 cluster forget {NodeID}</li></ul><h3 id="哨兵机制"><a href="#哨兵机制" class="headerlink" title="哨兵机制"></a>哨兵机制</h3><p>在Redis的主从模式下，master节点负责写数据，然后同步给从节点，从节点负责对数据进行读操作。如果master节点宕机了，需要手动将从节点调整为主节点，还需要调整客户端的数据连接源信息，无法达到高可用的目的。</p><p>哨兵机制是实现Redis高可用的模式，不提供读写服务，主要用于监视Redis的实例结点。客户端第一次连接会通过哨兵来获取主节点，后续就会直接访问主节点。当主节点宕机之后，哨兵会第一时间感知到，并从从节点中选出一个新的master节点，然后将新的master节点通知给客户端，实现Redis的高可用，这里客户端一般都实现了订阅功能，用于接受哨兵的通知。</p><h4 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h4><ul><li>监控：哨兵会不断的监控master和从节点的状态是否正常</li><li>提醒：当某一个Redis节点宕机之后，哨兵会通过客户端的API将消息发送给管理员</li><li>自动故障迁移：当一个master不能正常工作之后，哨兵会自动将一个从节点提升为master节点，并复制失效master节点的从节点到新的master节点下。当客户端访问失效的master节点时，哨兵会将新的master节点的地址返回给客户端，下次就直接访问新节点，实现高可用。</li></ul><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><ul><li>心跳机制，每隔一段时间 向Redis节点确认是否在线</li><li>判断master节点是否在线</li><li>基于Raft算法选举新的master节点</li><li>故障转移</li><li>修改配置</li></ul><h3 id="Redis-如何实现消息队列的？"><a href="#Redis-如何实现消息队列的？" class="headerlink" title="Redis 如何实现消息队列的？"></a>Redis 如何实现消息队列的？</h3><p>Redis可以使用list这个数据结构来实现消息队列，生产的消息使用 rpush 放入list中，获取消息使用 lpop。</p><p>当lpop没有获取到消息时可以使用sleep睡眠一段时间然后再获取消息。也可以使用 blpop 来获取消息，当没有消息时，他会一直阻塞直至获取到新的消息。</p><p>如果想要一次生产多次消费的话可以使用消息订阅模式（pub/sub），实现 1：N的消息队列，但是当消费者下线之后，生产的消息可能会丢失。</p><h3 id="Redis-如何实现分布式锁的？"><a href="#Redis-如何实现分布式锁的？" class="headerlink" title="Redis 如何实现分布式锁的？"></a>Redis 如何实现分布式锁的？</h3><h3 id="服务端如何处理客户端的并发请求的"><a href="#服务端如何处理客户端的并发请求的" class="headerlink" title="服务端如何处理客户端的并发请求的"></a>服务端如何处理客户端的并发请求的</h3><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;关于面试题的整理合集&lt;/p&gt;</summary>
    
    
    
    <category term="面试题" scheme="http://xucoud.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="面试" scheme="http://xucoud.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Go内存逃逸</title>
    <link href="http://xucoud.github.io/2022/01/28/Go%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8/"/>
    <id>http://xucoud.github.io/2022/01/28/Go%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8/</id>
    <published>2022-01-28T14:31:08.699Z</published>
    <updated>2022-01-28T15:48:15.983Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Go 语言内存逃逸的简单理解</p><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;p&gt;Go 语言内存逃逸的简单理解&lt;/p&gt;</summary>
    
    
    
    <category term="Go" scheme="http://xucoud.github.io/categories/Go/"/>
    
    <category term="内存逃逸" scheme="http://xucoud.github.io/categories/Go/%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8/"/>
    
    
    <category term="Go" scheme="http://xucoud.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="http://xucoud.github.io/2022/01/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%9C%9F%E6%9C%AB/"/>
    <id>http://xucoud.github.io/2022/01/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%9C%9F%E6%9C%AB/</id>
    <published>2022-01-26T06:44:09.650Z</published>
    <updated>2022-01-10T16:06:39.646Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><span id="more"></span><h2 id="第一章-概述"><a href="#第一章-概述" class="headerlink" title="第一章-概述"></a>第一章-概述</h2><h3 id="计算机网络概念"><a href="#计算机网络概念" class="headerlink" title="计算机网络概念"></a>计算机网络概念</h3><p>​        计算机网络主要是由一些通用的，可编程的硬件互联而成的，而这些硬件并非专门来实现某一特定目的（例如：传送数据和uo视频信号）。这些可编程的硬件能够用来传送多种不同类型的数据，并能支持广泛的和日益增长的应用。</p><blockquote><ol><li>计算机网络所连接的硬件，并不局限于计算机，而是包括了智能手机。</li><li>计算机网络并非专门用来传送数据，而是支持很多种的应用。</li></ol></blockquote><h3 id="计算机网络的组成"><a href="#计算机网络的组成" class="headerlink" title="计算机网络的组成"></a>计算机网络的组成</h3><p>由若干结点和链接这些节点的链路组成。</p><blockquote><p><code>结点</code>：计算机，集线器，交换机，路由器等。</p></blockquote><h3 id="计算机网络的工作方式"><a href="#计算机网络的工作方式" class="headerlink" title="计算机网络的工作方式"></a>计算机网络的工作方式</h3><ul><li><p>C/S——&gt;客户-服务器方式</p><ul><li>客户向服务器发送请求；服务器处理请求后，向客户提供服务。</li><li>客户程序特点：<ol><li>主动向服务器程序发起通信，必须知道服务器程序的地址</li><li>不需要特殊的硬件和复杂的操作系统</li></ol></li><li>服务器程序程序：<ol><li>专门提供某种服务的程序，可<code>同时处理</code>多个远程或本地客户的请求</li><li>系统启动后即自动调用并一直不断的运行，被动的等待并接受来自各地客户的通信请求，不需知道客户程序的地址。</li><li>一般需要强大的硬件和高级的操作系统的支持。</li></ol></li></ul></li><li><p>P2P——&gt;对等方式</p><ul><li>不区分服务器请求方和服务提供方</li><li>只要两台主机都运行了对等连接软件，就可以进行平等的对等连接通信</li><li>双方都可以下载对方已存储的共享文件</li></ul></li></ul><h3 id="数据交换方式"><a href="#数据交换方式" class="headerlink" title="数据交换方式"></a>数据交换方式</h3><ul><li>分组交换：单个分组（报文的一部分）传送到相邻节点，存储下来后查表转发到下一节点。</li><li>报文交换：整个报文先传送到相邻节点，全部存储下来后查找转发表，转发到下一个节点。</li><li>电路交换：整个报文的比特流连续的从源点直达终点</li></ul><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220107221418.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220107221418.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220107211736032" style="zoom:80%;" /><h3 id="网络分类"><a href="#网络分类" class="headerlink" title="网络分类"></a>网络分类</h3><h4 id="按照网络的作用的范围分类"><a href="#按照网络的作用的范围分类" class="headerlink" title="按照网络的作用的范围分类"></a>按照网络的作用的范围分类</h4><ul><li>广域网：几十到几千公里</li><li>城域网：一个城市，或几个街区，5~50km</li><li>局域网：一般用于微型计算机或工作站通过高速通信线路相连，1km左右</li><li>个人区域网：在个人工作的地方把属于个人的电子设备通过无线技术连接起来——无线个人区域网       （WPAN），10m左右</li></ul><h4 id="按照使用者分类"><a href="#按照使用者分类" class="headerlink" title="按照使用者分类"></a>按照使用者分类</h4><ul><li>公用网：电信公司建造的大型网络，所有给该公司交钱的人都可以使用</li><li>专用网：某个部门为满足特殊业务工作需要而建立的网络，仅供该部门的人使用。</li></ul><h3 id="计算公式"><a href="#计算公式" class="headerlink" title="计算公式"></a>计算公式</h3><p><strong>K：</strong>表示数据大小时用<code>2^10</code>，表示传输速率时用<code>10^3</code></p><p><strong>M：</strong>表示数据大小时用<code>2^20</code>，表示传输速率时用<code>10^6</code></p><h4 id="往返时间（RTT）"><a href="#往返时间（RTT）" class="headerlink" title="往返时间（RTT）"></a>往返时间（RTT）</h4><p>从发送方发送数据开始，到发送方接收到接收方的确定（接收方收到数据后立即发送确定）共经历的时延。</p><p>RTT=往返传播时延（传播时延 X 2）+ 末端处理时间（有时会忽略或题目中给出）</p><p>发送时间 = 数据长度/发送速率</p><p>有效数据率 = 数据长度/（发送时间+RTT）</p><h4 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h4><p>时延带宽积 = 传播时延 X 带宽</p><h4 id="传输时延"><a href="#传输时延" class="headerlink" title="传输时延"></a>传输时延</h4><p>传输时延（发送时延）=  数据帧长度（bit） / 发送速率（bit/s）</p><h4 id="传播时延"><a href="#传播时延" class="headerlink" title="传播时延"></a>传播时延</h4><p>传播时延 = 信道长度(m) / 电磁波在信道上的传播速率(m/s)</p><h4 id="最大吞吐率"><a href="#最大吞吐率" class="headerlink" title="最大吞吐率"></a>最大吞吐率</h4><p>一个RTT时间内发送所有窗口数据</p><h4 id="线路效率"><a href="#线路效率" class="headerlink" title="线路效率"></a>线路效率</h4><p>线路效率 = 吞吐率/网络速率</p><h3 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h3><p>计算机网络体系结构分为3种：<code>OSI体系结构（七层）</code>，<code>TCP/IP体系结构（四层）</code>，<code>五层体系结构</code>。</p><ul><li>OSI体系结构: 概念清楚，理论也比较完整，但是它既复杂又不实用。</li><li>TCP/IP体系结构:TCP/IP是一个四层体系结构，得到了广泛的运用。</li><li>五层体系结构:为了方便学习，折中OSI体系结构和TCP/IP体系结构，综合二者的优点，这样既简洁，又能将概念讲清楚。</li></ul><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220108195603.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220108195603.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220108195533033" style="zoom:67%;" /><h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><p>为进行网络中的数据交换建立的规则，标准或约定。</p><p>组成<code>三要素</code>：</p><ul><li>语法</li><li>语义</li><li>同步</li></ul><p>协议通常有两种不同的形式</p><ol><li>使用便于人来阅读和理解的文字描述</li><li>使用让计算机能够理解的程序代码</li></ol><p>协议是<code>水平的</code>，即协议是控制对等实体之间通信的规则</p><p>服务是<code>垂直的</code>，即服务是由下层向上层通过层间接口提供的。</p><p>在<code>协议的控制</code>下，两个对等实体间的通信使得本层能够向上一层级提供服务。要实现本层协议，还需要使用下面一层所提供的服务。</p><p>协议保证了能够向上一层提供服务 。</p><p>下面的协议对上面的实体是透明的。</p><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>任务：通过应用进程之间的交互来完成特点网络应用</p><p>报文：交互的数据单元</p><p>协议：应用进程间通信和交互的规则。</p><ul><li>域名系统DNS</li><li>支持万维网应用的HTTP协议</li><li>支持电子邮件的SMTP协议</li></ul><h4 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h4><p>任务：负责向两台主机中进程之间的通信提供通用的数据传输服务</p><p>协议：</p><ul><li>传输控制协议（TCP）—— 提供面向连接的，可靠的数据传输服务，其数据传输的单位是报文段</li><li>用户数据报协议（UDP）—— 提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性），其传输的单位是用户数据报</li></ul><h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p>任务：负责为分组交换网上的不同主机提供通信服务（源主机到目的主机）</p><p>协议：</p><ul><li>无连接的网际协议IP</li><li>许多种路由选择协议</li></ul><h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h4><p>任务：将网络层交下来的IP数据博爱组装成帧，在两个相邻节点间的链路上传送帧</p><p>协议：可靠传输协议</p><h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><p>任务：传输比特流数据</p><h2 id="第二章-物理层"><a href="#第二章-物理层" class="headerlink" title="第二章-物理层"></a>第二章-物理层</h2><h3 id="传输模式"><a href="#传输模式" class="headerlink" title="传输模式"></a>传输模式</h3><ul><li>单工通信（单向通信）—— 只有一个方向的通信，没有反方向的交互（广播）</li><li>半双工通信（双向交替通信）—— 双方都可以发送信息，但是不能同时 发送/接收</li><li>全双工通信（双向同时通信）—— 双方可以同时发送和接收（传输效率最高）</li></ul><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li>机械特性</li><li>电气特性</li><li>功能特性</li><li>过程特性</li></ul><h3 id="奈式准则"><a href="#奈式准则" class="headerlink" title="奈式准则"></a>奈式准则</h3><p>在任何信道中， 码元的传输速率是有上限的， 传输速率超过此上限，就会出现严重的码间串扰的问题，使接收端对码元的判决（识别）成为不可能。</p><h3 id="香农公式"><a href="#香农公式" class="headerlink" title="香农公式"></a>香农公式</h3><p>信噪比是信号的平均功率和噪声的平均功率之比</p><p>信噪比（dB）= 10 log10(S/N) （dB)</p><p>信道的极限信息传输速率 C = W log2（1 + S/N）（bit/s）</p><p><strong>香农公式表明：</strong>信道的带宽或信道中的信噪比越大，信息的极限传输速率就越高</p><p><strong>香农公式的意义：</strong>只要信息的传输速率低于信道的极限信息传输速率，就一定存在某种办法来实现无差错的传输</p><h3 id="CRC校验"><a href="#CRC校验" class="headerlink" title="CRC校验"></a>CRC校验</h3><p>CRC校验中有两个关键点，一是预先确定一个发送送端和接收端都用来作为除数的二进制比特串（或多项式），可以随机选择，也可以使用国际标准，但是最高位和最低位必须为1；二是把原始帧与上面计算出的除数进行模2除法运算，计算出CRC码。</p><p>具体步骤：</p><ol><li>选择合适的除数</li><li>看选定除数的二进制位数，然后再要发送的数据帧上面加上这个位数-1位的0，然后用新生成的帧以模2除法的方式除上面的除数，得到的余数就是该帧的CRC校验码。注意，余数的位数一定只比除数位数少一位，也就是CRC校验码位数比除数位数少一位，如果前面位是0也不能省略。</li><li>将计算出来的CRC校验码附加在原数据帧后面，构建成一个新的数据帧进行发送；最后接收端在以模2除法方式除以前面选择的除数，如果没有余数，则说明数据帧在传输的过程中没有出错。</li></ol><p>以一个题目为例：设待校验的数据为。D8～D1 = 10101011，若采用CRC，且生成多项式为 10011，则其 CRC 码为：<br> 这里首先要注意题目中的一个表述——“多项式”，该题目中写作“10011”，在有的题目中往往写作“x^4+x+1”<br> 首先，在数据位后加<strong>多项式最高幂次</strong>个0，比如这里的多项式最高次项为x^4，那就在数据位后加四个0，变成：101010110000，作为被除数<br> 然后，将多项式 10011 作为除数进行断除。需要注意的是，图中所框的部分，对应位只做xor运算，也就是做减法但不影响其他位</p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220108233156.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220108233156.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220108233143040" style="zoom:50%;" /><p>最后得到的余数：1010，即是校验位。那么整个CRC码为：10101011 1010</p><h3 id="接收端校验"><a href="#接收端校验" class="headerlink" title="接收端校验"></a>接收端校验</h3><p>以上一节例题为例，假设收到的CRC码变成了10001011 1010，第10位（右边为低位）发生了错误。<br> 现在尝试用CRC码与多项式 10011 进行短除：</p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220108233335.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220108233335.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220108233331822" style="zoom:50%;" /><p>得到余数为 1010(2) = 8+2 = 10(10) ，即第10位发生错误，只需要反转第10位的值，便可获得正确的值</p><h3 id="曼彻斯特编码"><a href="#曼彻斯特编码" class="headerlink" title="曼彻斯特编码"></a>曼彻斯特编码</h3><p>​        在曼彻斯特编码中，每一位的中间有一跳变，位中间的跳变既作时钟信号，又作数据信号;从低到高跳变表示”1”，从高到低跳变表示”0”。还有一种是差分曼彻斯特编码，每位中间的跳变仅提供时钟定时，而用每位开始时有无跳变表示”0”或”1”，有跳变为”0”，无跳变为”1”。</p><p>​        其中非常值得注意的是，在每一位的”中间”必有一跳变，根据此规则，可以得出曼彻斯特编码波形图的画法。例如:传输二进制信息0，若将0看作一位，我们以0为中心，在两边用虚线界定这一位的范围，然后在这一位的中间画出一个电平由高到低的跳变。后面的每一位以此类推即可画出整个波形图。</p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220108234444.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220108234444.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220108233736457" style="zoom:50%;" /><h3 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h3><ul><li>频分复用（FDM）</li><li>时分复用（TDM）</li><li>统计时分复用（STDM）</li><li>波分复用（WDM）</li><li>码分复用（CDM）</li></ul><h3 id="码分多址-CDMA"><a href="#码分多址-CDMA" class="headerlink" title="码分多址(CDMA)"></a>码分多址(CDMA)</h3><p>每一个用户可以在同样的时间使用同样的频带进行通信。由于个用户使用经过特殊挑选的不同码型，因此各用户之间不会造成干扰。可以提高通信的话音质量和数据传输的可靠性，减少干扰对通信的影响，增大通信的容量，降低手机的平均发射功率……</p><h2 id="第三章-数据链路层"><a href="#第三章-数据链路层" class="headerlink" title="第三章-数据链路层"></a>第三章-数据链路层</h2><h2 id="第四章-网络层"><a href="#第四章-网络层" class="headerlink" title="第四章-网络层"></a>第四章-网络层</h2><h2 id="第五章-运输层"><a href="#第五章-运输层" class="headerlink" title="第五章-运输层"></a>第五章-运输层</h2><h2 id="第六章-应用层"><a href="#第六章-应用层" class="headerlink" title="第六章-应用层"></a>第六章-应用层</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="期末" scheme="http://xucoud.github.io/categories/%E6%9C%9F%E6%9C%AB/"/>
    
    <category term="计算机网络" scheme="http://xucoud.github.io/categories/%E6%9C%9F%E6%9C%AB/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="期末" scheme="http://xucoud.github.io/tags/%E6%9C%9F%E6%9C%AB/"/>
    
  </entry>
  
  <entry>
    <title>算法设计与分析</title>
    <link href="http://xucoud.github.io/2022/01/26/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"/>
    <id>http://xucoud.github.io/2022/01/26/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/</id>
    <published>2022-01-26T06:44:09.636Z</published>
    <updated>2022-01-10T16:06:30.875Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><span id="more"></span><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><h2 id="递归与分治"><a href="#递归与分治" class="headerlink" title="递归与分治"></a>递归与分治</h2><h3 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h3><p>递归：直接或间接的调用自身的函数</p><p>分治：将一个规模为n的问题分解为k个规模较小的子问题，这些子问题互相独立且与原问题相同，递归的求解这些子问题，然后将各个子问题的解合并到原问题的解。</p><h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><ol><li>分解：分解原问题为结构相同的子问题。</li><li>解决：分解到某个容易求解的边界之后，进行递归求解。</li><li>合并：将子问题的解合并成原问题的解。</li></ol><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：结构清晰、可读性强</p><p>缺点：运行时效率较低，耗费较多的时间、空间资源</p><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ol><li>规模如果很小，则很容易解决。//一般问题都能满足</li><li>大问题可以分为若干规模小的相同问题。//前提   </li><li>利用子问题的解，可以合并成该问题的解。//关键    </li><li>分解出的各个子问题相互独立，子问题不再包含公共子问题。 //效率高低</li></ol><h3 id="众数问题"><a href="#众数问题" class="headerlink" title="众数问题"></a>众数问题</h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>给定含有n个元素的多重集合s,每个元素在S中出现的次数称为该元素的重数。多重集S中重数最大的元素称为众数。例如， S-(1, 2, 2, 2, 3, 3, 5).多重集S的众数是2,其重数为3,对于给定的由n个自然数组成的多重集s,计算S的众数及其重数。如果出现多个众数，请输出最小的那个。</p><h4 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h4><p>输入数据的第1行是多重集S中元素个数n (n&lt;1 300000) ;接下来的n行中，每行有一个最多含有5位数字的自然数。输出数据的第1行给出众数，第2行是重数。<br>样例为：</p><blockquote><p>Sample input<br>6<br>1<br>2<br>2<br>2<br>3<br>5</p></blockquote><blockquote><p>Sample output<br>2<br>3</p></blockquote><h4 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h4><p>取中位数的个数为重数，中位数为众数，确定左界、右界。</p><p>在往左界递归取中位数为众数，个数为重数，比较</p><p>往右界递归取中位数为众数，个数为重数，比较</p><p>如果中位数的个数大于左界个数，那左边一定没有该组数据的众数；反之，右边一样。</p><p>该程序要求数据有序（从小到大），本程序未写排序算法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdlib.h&quot;</span></span></span><br><span class="line">define N <span class="number">100</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Split</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n,<span class="keyword">int</span> &amp;l,<span class="keyword">int</span> &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//以中间数字为界，确定左右界</span></span><br><span class="line"><span class="keyword">int</span> mid = n/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span>(l = <span class="number">0</span>;l &lt;= mid;++l)<span class="comment">//找左界</span></span><br><span class="line"><span class="keyword">if</span>(a[l] == a[mid])</span><br><span class="line"><span class="keyword">break</span>;<span class="comment">//此时l为左界</span></span><br><span class="line"><span class="keyword">for</span>(r = mid + <span class="number">1</span>;r &lt; n;++r)<span class="comment">//找右界</span></span><br><span class="line"><span class="keyword">if</span>(a[r] !=a[mid])</span><br><span class="line"><span class="keyword">break</span>;<span class="comment">//此时r为右界</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getMaxNum</span><span class="params">(<span class="keyword">int</span> &amp;num,<span class="keyword">int</span> &amp;maxnum,<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//求众数和重数</span></span><br><span class="line"><span class="keyword">int</span> l,r,s;</span><br><span class="line"><span class="keyword">int</span> mid = n/<span class="number">2</span>;</span><br><span class="line">Split(a,n,l,r);</span><br><span class="line">s = r - l;</span><br><span class="line"><span class="keyword">if</span>(s &gt; maxnum)</span><br><span class="line">&#123;<span class="comment">//如果中间数字的个数大于现在的重数，则更新</span></span><br><span class="line">num = a[mid];</span><br><span class="line">maxnum = s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(s == maxnum)<span class="comment">//如果出现多个众数，输出最小的那个</span></span><br><span class="line">    <span class="keyword">if</span>(num &gt; a[mid])</span><br><span class="line">&#123;</span><br><span class="line">num = a[mid];</span><br><span class="line">    maxnum = s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(l+<span class="number">1</span> &gt; maxnum)</span><br><span class="line"><span class="comment">//如果左边的个数&gt;maxnum,则搜索左边</span></span><br><span class="line">getMaxNum(num,maxnum,a,l+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(n - r &gt; maxnum)</span><br><span class="line"><span class="comment">//如果右边的个数&gt;maxnum,则搜索右边</span></span><br><span class="line">getMaxNum(num,maxnum,a+r,n-r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,n,a[N];</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;<span class="comment">//num为众数</span></span><br><span class="line"><span class="keyword">int</span> maxnum = <span class="number">0</span>;<span class="comment">//maxnum为重数</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);<span class="comment">//输入数据个数</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);<span class="comment">//输入数据</span></span><br><span class="line">    <span class="comment">//sort(a[i]);//将数据排序</span></span><br><span class="line">getMaxNum(num,maxnum,a,n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n%d&quot;</span>,num,maxnum);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="集合划分"><a href="#集合划分" class="headerlink" title="集合划分"></a>集合划分</h3><h4 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h4><p>n个元素的集合{1,2,?, n }可以划分为若干个非空子集。例如，当n=4 时，集合{1，2，3，4}可以划分为15 个不同的非空子集如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;1&#125;，&#123;2&#125;，&#123;3&#125;，&#123;4&#125;&#125;，</span><br><span class="line">&#123;&#123;1，2&#125;，&#123;3&#125;，&#123;4&#125;&#125;，</span><br><span class="line">&#123;&#123;1，3&#125;，&#123;2&#125;，&#123;4&#125;&#125;，</span><br><span class="line">&#123;&#123;1，4&#125;，&#123;2&#125;，&#123;3&#125;&#125;，</span><br><span class="line">&#123;&#123;2，3&#125;，&#123;1&#125;，&#123;4&#125;&#125;，</span><br><span class="line">&#123;&#123;2，4&#125;，&#123;1&#125;，&#123;3&#125;&#125;，</span><br><span class="line">&#123;&#123;3，4&#125;，&#123;1&#125;，&#123;2&#125;&#125;，</span><br><span class="line">&#123;&#123;1，2&#125;，&#123;3，4&#125;&#125;，</span><br><span class="line">&#123;&#123;1，3&#125;，&#123;2，4&#125;&#125;，</span><br><span class="line">&#123;&#123;1，4&#125;，&#123;2，3&#125;&#125;，</span><br><span class="line">&#123;&#123;1，2，3&#125;，&#123;4&#125;&#125;，</span><br><span class="line">&#123;&#123;1，2，4&#125;，&#123;3&#125;&#125;，</span><br><span class="line">&#123;&#123;1，3，4&#125;，&#123;2&#125;&#125;，</span><br><span class="line">&#123;&#123;2，3，4&#125;，&#123;1&#125;&#125;，</span><br><span class="line">&#123;&#123;1，2，3，4&#125;&#125;</span><br></pre></td></tr></table></figure><p>给定正整数n，计算出n个元素的集合{1,2,?, n }可以划分为多少个不同的非空子集。 </p><h4 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h4><p>定义F(n,m)=此题的解<br>当m=1时，F(n,m)=1;<br>当n=m时，F(n,m)=1;</p><p>假设原集合有m个元素，后输入了n-m个元素，此时将输入的元素和原集合的1个元素合并成一个子集，则此时集合依旧有m个元素，或者将原集合的n-m+1个元素合并成一个子集，此时集合也是m个元素，则这两种合并方法，合并出来的集合的不同种类之和，则是我们需要想要得出的答案。<br>（上面一段话用了逆向的思维方式）<br>这两种方法所得到的表达式则为：<br>F(n-1,m-1)和F(n,m-1)*m<br>答案就等于： F(n-1,m-1)+F(n,m-1)*m<br>这样，则可以用递归的方法求出答案(在得出任一个递归的返回值之前，调用次数为2^n次)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">F</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(m==<span class="number">1</span>||m==n)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">F</span>(n<span class="number">-1</span>,m<span class="number">-1</span>)+m*<span class="built_in">F</span>(n<span class="number">-1</span>,m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">if</span>(m==<span class="number">1</span>||m==n)</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;1&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">if</span>(m==<span class="number">0</span>||n==<span class="number">0</span>||n&lt;m)</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;ÊäÈë´íÎó£¡&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout&lt;&lt;<span class="built_in">F</span>(n<span class="number">-1</span>,m<span class="number">-1</span>)+m*<span class="built_in">F</span>(n<span class="number">-1</span>,m)&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="设计思想-1"><a href="#设计思想-1" class="headerlink" title="设计思想"></a>设计思想</h3><p>将待求解的问题分解成若干的子问题，先去求解子问题，再结合这些子问题的解得到原问题的解。动态规划中的子问题往往不是相互独立的。</p><h3 id="解题步骤-1"><a href="#解题步骤-1" class="headerlink" title="解题步骤"></a>解题步骤</h3><ol><li>找出最优解的性质，并刻画其结构特征</li><li>递归的定义最优值</li><li>以自底向上的方式设计最优值</li><li>根据计算最优值时得到的信息，构造最优解</li></ol><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ol><li>能够得到全局最优解；</li><li>可以得到一族最优解；</li><li>由于动态规划方法反映了动态过程演变的联系和特征，在计算时可以利用实际知识和经验提高求解效率。</li></ol><p>缺点：</p><ol><li>没有统一的标准模型；</li><li>数值方法求解时存在维数灾。（需要额外的内存空间，并且一维问题可能需要二维空间）</li></ol><h3 id="特征-1"><a href="#特征-1" class="headerlink" title="特征"></a>特征</h3><ol><li>最优子结构</li><li>重叠子问题</li></ol><h3 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0 1背包问题"></a>0 1背包问题</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p><strong>有n个物品，它们有各自的体积和价值，现有给定容量的背包，如何让背包里装入的物品具有最大的价值总和？</strong></p><p>为方便讲解和理解，下面讲述的例子均先用具体的数字代入，即：eg：number＝4，capacity＝8<br><img src="https://img-blog.csdnimg.cn/20190810164615141.png" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/20190810164615141.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述"></p><h4 id="总体思路"><a href="#总体思路" class="headerlink" title="总体思路"></a>总体思路</h4><p>根据动态规划解题步骤（问题抽象化、建立模型、寻找约束条件、判断是否满足最优性原理、找大问题与小问题的递推关系式、填表、寻找解组成）找出01背包问题的最优解以及解组成，然后编写代码实现。</p><h4 id="动态规划的原理"><a href="#动态规划的原理" class="headerlink" title="动态规划的原理"></a>动态规划的原理</h4><p>动态规划与分治法类似，都是把大问题拆分成小问题，通过寻找大问题与小问题的递推关系，解决一个个小问题，最终达到解决原问题的效果。但不同的是，分治法在子问题和子子问题等上被重复计算了很多次，而动态规划则具有记忆性，<strong>通过填写表把所有已经解决的子问题答案纪录下来，在新问题里需要用到的子问题可以直接提取，避免了重复计算，从而节约了时间，所以在问题满足最优性原理之后，用动态规划解决问题的核心就在于填表，表填写完毕，最优解也就找到。</strong></p><p>最优性原理是动态规划的基础，最优性原理是指“多阶段决策过程的最优决策序列具有这样的性质：<strong>不论初始状态和初始决策如何，对于前面决策所造成的某一状态而言，其后各阶段的决策序列必须构成最优策略”。</strong></p><h4 id="背包问题的解决过程"><a href="#背包问题的解决过程" class="headerlink" title="背包问题的解决过程"></a>背包问题的解决过程</h4><p>在解决问题之前，为描述方便，首先定义一些变量：<strong>Vi表示第 i 个物品的价值，Wi表示第 i 个物品的体积，定义V(i,j)：当前背包容量 j，前 i 个物品最佳组合对应的价值</strong>，同时背包问题抽象化（X1，X2，…，Xn，其中 Xi 取0或1，表示第 i 个物品选或不选）。</p><p><em>1、建立模型，即求max(V1X1+V2X2+…+VnXn)；</em></p><p><em>2、寻找约束条件，W1X1+W2X2+…+WnXn&lt;capacity；</em></p><p><em>3、寻找递推关系式，面对当前商品有两种可能性：</em></p><ul><li><strong>包的容量比该商品体积小，装不下，此时的价值与前i-1个的价值是一样的，即V(i,j)=V(i-1,j)；</strong></li><li><strong>还有足够的容量可以装该商品，但装了也不一定达到当前最优价值，所以在装与不装之间选择最优的一个，即V(i,j)=max｛V(i-1,j)，V(i-1,j-w(i))+v(i)｝。</strong></li></ul><hr><p>其中V(i-1,j)表示不装，V(i-1,j-w(i))+v(i) 表示装了第i个商品，背包容量减少w(i)，但价值增加了v(i)；</p><p>由此可以得出递推关系式：</p><ul><li>j&lt;w(i) V(i,j)=V(i-1,j)</li><li>j&gt;=w(i) V(i,j)=max｛V(i-1,j)，V(i-1,j-w(i))+v(i)｝</li></ul><hr><p>这里需要解释一下，为什么能装的情况下，需要这样求解（这才是本问题的关键所在！）：</p><p>可以这么理解，<strong>如果要到达V(i,j)这一个状态有几种方式</strong>？</p><p><strong>肯定是两种，第一种是第i件商品没有装进去，第二种是第i件商品装进去了</strong>。没有装进去很好理解，就是V(i-1,j)；装进去了怎么理解呢？如果装进去第i件商品，那么装入之前是什么状态，肯定是V(i-1,j-w(i))。由于最优性原理（上文讲到），V(i-1,j-w(i))就是前面决策造成的一种状态，后面的决策就要构成最优策略。两种情况进行比较，得出最优。</p><p>4、填表，首先初始化边界条件，V(0,j)=V(i,0)=0；</p><p><img src="https://img-blog.csdnimg.cn/20190810165633366.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NzY3NDU1,size_16,color_FFFFFF,t_70" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/20190810165633366.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NzY3NDU1,size_16,color_FFFFFF,t_70" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述"></p><p>然后一行一行的填表：</p><ul><li>如，i=1，j=1，w(1)=2，v(1)=3，有j&lt;w(1)，故V(1,1)=V(1-1,1)=0；</li><li>又如i=1，j=2，w(1)=2，v(1)=3，有j=w(1),故V(1,2)=max｛<br>V(1-1,2)，V(1-1,2-w(1))+v(1) ｝=max｛0，0+3｝=3；</li><li>如此下去，填到最后一个，i=4，j=8，w(4)=5，v(4)=6，有j&gt;w(4)，故V(4,8)=max｛<br>V(4-1,8)，V(4-1,8-w(4))+v(4) ｝=max｛9，4+6｝=10……</li></ul><hr><p>所以填完表如下图：</p><p><img src="https://img-blog.csdnimg.cn/20190810165740701.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NzY3NDU1,size_16,color_FFFFFF,t_70" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/20190810165740701.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NzY3NDU1,size_16,color_FFFFFF,t_70" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述"></p><p>5、表格填完，最优解即是V(number,capacity)=V(4,8)=10。</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>为了和之前的动态规划图可以进行对比，尽管只有4个商品，但是我们创建的数组元素由5个。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> w[<span class="number">5</span>] = &#123; <span class="number">0</span> , <span class="number">2</span> , <span class="number">3</span> , <span class="number">4</span> , <span class="number">5</span> &#125;;<span class="comment">//商品的体积2、3、4、5</span></span><br><span class="line"><span class="keyword">int</span> v[<span class="number">5</span>] = &#123; <span class="number">0</span> , <span class="number">3</span> , <span class="number">4</span> , <span class="number">5</span> , <span class="number">6</span> &#125;;<span class="comment">//商品的价值3、4、5、6</span></span><br><span class="line"><span class="keyword">int</span> bagV = <span class="number">8</span>;        <span class="comment">//背包大小</span></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">5</span>][<span class="number">9</span>] = &#123; &#123; <span class="number">0</span> &#125; &#125;;        <span class="comment">//动态规划表</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= bagV; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (j &lt; w[i])</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - w[i]] + v[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//动态规划表的输出</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">cout &lt;&lt; dp[i][j] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="矩阵连乘问题"><a href="#矩阵连乘问题" class="headerlink" title="矩阵连乘问题"></a>矩阵连乘问题</h3><p>输入：n个矩阵A1,A2,…,An，其中Ai的维数为pi-1×pi<br>Ai 和Ai+1是可乘的</p><p>输出：连乘积A1A2A3…An</p><p>优化目标：最小计算代价（最优的计算次序）</p><p>矩阵乘法的代价：乘法次数<br>若A 是p ×q 矩阵，B 是q ×r 矩阵，则A ×B 的代价是pqr<br>因为矩阵乘法满足结合律，因此矩阵连乘可以由不同的计算次序，这种计算次序可以用加括号来表示。<br>1<br>2<br>3<br>三个矩阵A1: 10×100, A2: 100×5，A3: 5×50<br>(A1A2)A3<br>代价：10×100×5＋10×5×50＝7500<br>A1(A2A3)<br>代价：100×5×50＋10×100×50＝75000</p><p>可见不同的计算次序会导致不同的计算代价，我们要做的就是让这个代价最小。</p><p>我们自然可以用穷举法计算每次不同的结合次序带来的不同代价，然后取最小值，但是这样我们得到的复杂度将达到<img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220110233227.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220110233227.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220110233219445" style="zoom: 50%;" /></p><h4 id="分析最优解结构"><a href="#分析最优解结构" class="headerlink" title="分析最优解结构"></a>分析最优解结构</h4><p>将矩阵连乘积AiAi+1…Aj，记为A[i:j]</p><p>设AiAi+1…Aj的最优计算次序在矩阵Ak和Ak+1之间将矩阵链断开得到：(Ai… Ak) (Ak+1 …Aj)</p><p>总的计算量就是：A[i:k]的计算量＋A[k+1: j]的计算量+A[i:k]和A[k+1:j]相乘的计算量</p><p>建立的递归关系就是</p><p>计算A[i:j]所需的最小乘法次数为m（i，j）</p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220110233204.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220110233204.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220110233201035" style="zoom:67%;" /><p>其中Ai是Pi-1 x Pi的矩阵</p><p>接下来我们借助填表过程理解递归的过程，现在给出下列矩阵：</p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220110233151.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220110233151.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220110233147786" style="zoom:67%;" /><p>填表过程是按对角线填写的，只利用到了二维数组的右上角一部分。</p><p>根据地推公式，我们可以知道，在i=j时m=0，所以先构造出最长的对角线部分的数据，如下图：</p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220110233133.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220110233133.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220110233130168" style="zoom:67%;" /><p>现在我们继续构造，<br>m（1,2）=min{m[1][1]+m[2][2]+p0p1p2}={0+0+303515}=15750</p><p>m(2,3) = min(m[2][2]+m[3][3]+p1p2p3=0+0+35155）=2625</p><p>同理，后面不再一一列举；</p><p>再多说一点，有时我们会遇到有多个划分，我们取最小值就可以了，</p><p>例如：m（1,4）=min{m[1][2]+m[3][4]+p0p2p4 或者是 m[1][1]+m[2][4]+p0p1p4或者是m[1][3]+m[4][4]+p0p3p4}，其中的值已经在前面求出来了，这也是动态规划要记录所有值的原因。</p><p>结果图如下：读者可以自行计算验证。</p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220110233114.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220110233114.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220110233110648" style="zoom:67%;" /><p>那么，我们最后如何得知是哪个地方要加括号呢？<br>根据最后的公式。</p><p>例如，假设最后的m[1:6]=m[1,1]+m[2][6]+p0p2p6（笔者构造的，跟上面的例子没关系），那么我们就知道是（A1(A2A3A4A5A6)）,再看m[2:6],根据公式找退出括号位置，一直推到最后即可。</p><p>我们不难发现，加括号的位置其实就是k 的对应序号的矩阵，在写算法时我们就可以用另外的数组记录下对应位置的k值。在最后输出时把这个数组按逻辑输出。</p><p>最终这个算法的复杂度</p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220110233056.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220110233056.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220110233043532" style="zoom:50%;" /><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> A[N];<span class="comment">//矩阵规模</span></span><br><span class="line"><span class="keyword">int</span> m[N][N];<span class="comment">//最优解</span></span><br><span class="line"><span class="keyword">int</span> s[N][N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MatrixChain</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> r, i, j, k;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= n; i++)<span class="comment">//初始化对角线</span></span><br><span class="line">&#123;</span><br><span class="line">m[i][i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (r = <span class="number">2</span>; r &lt;= n; r++)<span class="comment">//r个矩阵连乘</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n - r + <span class="number">1</span>; i++)<span class="comment">//r个矩阵的r-1个空隙中依次测试最优点</span></span><br><span class="line">&#123;</span><br><span class="line">j = i + r - <span class="number">1</span>;</span><br><span class="line">m[i][j] = m[i][i]+m[i + <span class="number">1</span>][j] + A[i - <span class="number">1</span>] * A[i] * A[j];</span><br><span class="line">s[i][j] = i;</span><br><span class="line"><span class="keyword">for</span> (k = i + <span class="number">1</span>; k &lt; j; k++)<span class="comment">//变换分隔位置，逐一测试</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> t = m[i][k] + m[k + <span class="number">1</span>][j] + A[i - <span class="number">1</span>] * A[k] * A[j];</span><br><span class="line"><span class="keyword">if</span> (t &lt; m[i][j])<span class="comment">//如果变换后的位置更优，则替换原来的分隔方法。</span></span><br><span class="line">&#123;</span><br><span class="line">m[i][j] = t;</span><br><span class="line">s[i][j] = k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (i == j)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;]&quot;</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;(&quot;</span>;</span><br><span class="line"><span class="built_in">print</span>(i, s[i][j]);</span><br><span class="line"><span class="built_in">print</span>(s[i][j] + <span class="number">1</span>, j);<span class="comment">//递归1到s[1][j]</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;<span class="comment">//n个矩阵</span></span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; A[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">MatrixChain</span>(n);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;最佳添加括号的方式为：&quot;</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span>, n);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;\n最小计算量的值为：&quot;</span> &lt;&lt; m[<span class="number">1</span>][n] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><h3 id="设计思想-2"><a href="#设计思想-2" class="headerlink" title="设计思想"></a>设计思想</h3><p>​        贪心算法总是作出在当前看来最好的选择。也就是说贪心算法并不从整体最优考虑，它所作出的选择只是在某种意义上的局部最优选择。当然，希望贪心算法得到的最终结果也是整体最优的。虽然贪心算法不能对所有问题都得到整体最优解，但对许多问题它能产生整体最优解。如单源最短路经问题，最小生成树问题等。在一些情况下，即使贪心算法不能得到整体最优解，其最终结果却是最优解的很好近似。</p><h3 id="解题步骤-2"><a href="#解题步骤-2" class="headerlink" title="解题步骤"></a>解题步骤</h3><ol><li>建立数学模型来描述问题。</li><li>把求解的问题分成若干个子问题。</li><li>对每个子问题求解，得到子问题的局部最优解。</li><li>把子问题的解局部最优解合成原来解问题的一个解。</li></ol><h3 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ol><li>算法简单</li><li>时间和空间复杂度低</li></ol><p>缺点：</p><ol><li>一些情况下不能得到最优解</li></ol><h3 id="特征-2"><a href="#特征-2" class="headerlink" title="特征"></a>特征</h3><ol><li><p>贪心选择性质：局部最优解能够得到整体最优解。（通常需要证明）</p></li><li><p>最优子结构性质：该问题可以分解为若干个规模较小的相同问题</p></li></ol><h3 id="与动态规划"><a href="#与动态规划" class="headerlink" title="与动态规划"></a>与动态规划</h3><ol><li><p>共同点：</p><ol><li><p>都需要最优子结构性质，</p></li><li><p>都用来求有优化问题。</p></li></ol></li><li><p>不同点：</p><ol><li>动态规划：每一步作一个选择—依赖于子问题的解。<br>贪心方法：每一步作一个选择—不依赖于子问题的解。</li><li>动态规划方法的条件：子问题的重叠性质。<br>可用贪心方法的条件：最优子结构性质；贪心选择性质。</li><li>动态规划：自底向上求解；<br>贪心方法： 自顶向下求解。</li><li>可用贪心法时，动态规划方法可能不适用；<br>可用动态规划方法时，贪心法可能不适用。</li></ol></li></ol><h3 id="会场安排问题"><a href="#会场安排问题" class="headerlink" title="会场安排问题"></a>会场安排问题</h3><h4 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h4><p>设有n个会议的集合C={1,2,…,n}，其中每个会议都要求使用同一个资源（如会议室），而在同一时间内只能有一个会议使用该资源。每个会议i都有要求使用该资源的起始时间bi和结束时间ei，且bi &lt; ei 。如果选择了会议i使用会议室，则它在半开区间[bi, ei)内占用该资源。如果[bi, ei)与[bj , ej)不相交，则称会议i与会议j是相容的。会场安排问题要求在所给的会议集合中选出最大的相容活动子集，也即尽可能地选择更多的会议来使用资源。</p><h4 id="贪心策略"><a href="#贪心策略" class="headerlink" title="贪心策略"></a>贪心策略</h4><p>选择最早开始时间且不与已安排会议重叠的会议</p><p>选择使用时间最短且不与已安排会议重叠的会议</p><p>选择具有最早结束时间且不与已安排会议重叠的会议  </p><p>这里，我们要尽可能多的安排会议，显然采取贪最早结束时间的策略。</p><h4 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h4><p>步骤1：初始化。开始时间存入数组B；结束时间存入数组E中且按照结束时间的非减序排序，B相应调整；集合A存储解，会议i如果在集合A中，当且仅当A[i]=true；</p><p>步骤2：根据贪心策略，首令A[1]=true；</p><p>步骤3：依次扫描每一个会议，如果会议i的开始时间不小于最后一个选入A中的会议的结束时间，则将会议i加入A中；否则，放弃，继续检查下一个会议与A中会议的相容性。</p><p>示例：设有11个会议等待安排，用贪心法找出满足目标要求的会议集合。这些会议按结束时间的非减序排列如表所示。</p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220110233558.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220110233558.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220110233549281" style="zoom: 33%;" /><h4 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h4><p>设会议i的起始时间bi和结束时间ei的数据类型为整形（限制在整点）；则GreedySelector算法描述如下：</p><p>Void GreedySelector(int n,int b[ ],int e[ ],bool A[ ])<br>{<br>    e中元素按非递减序排列，b中对应元素做相应调整;<br>    int I,j;<br>    A[1]=true;                    //初始化选择会议的集合A，只包含会议1；<br>    j=1;i=2;                       //从第二(i)个会议开始寻找与会议1(j)相容的会议；<br>    while(i&lt;=n)<br>            if(b[i]&gt;=e[j])<br>                {A[i]=true;j=I;}<br>            else<br>                  A[i]=false;<br>}                                      </p><p>该算法的时间复杂度为排序的复杂度：O(nlogn)，空间复杂度为常数阶：O(1)</p><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GreedySelector</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> B[], <span class="keyword">int</span> E[], <span class="keyword">bool</span> A[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">time</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> B[], <span class="keyword">int</span> E[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;请输入会议总数:&quot;</span>;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">int</span> B[n],E[n];</span><br><span class="line"><span class="keyword">bool</span> A[n];</span><br><span class="line"> </span><br><span class="line">cout&lt;&lt;<span class="string">&quot;请输入所有会议开始时间和结束时间：例如 1 4&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    cin&gt;&gt;B[i];</span><br><span class="line">    cin&gt;&gt;E[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    A[i] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">time</span>(n,B,E);</span><br><span class="line"><span class="built_in">GreedySelector</span>(n,B,E,A);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">time</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> B[],<span class="keyword">int</span> E[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,temp1,temp2;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;n+<span class="number">1</span>;j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n+<span class="number">1</span>-j;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(E[i]&gt;E[i+<span class="number">1</span>])&#123;</span><br><span class="line">                temp1 = E[i];</span><br><span class="line">                E[i] = E[i+<span class="number">1</span>];</span><br><span class="line">                E[i+<span class="number">1</span>] = temp1;</span><br><span class="line">                temp2 = B[i];</span><br><span class="line">                B[i] = B[i+<span class="number">1</span>];</span><br><span class="line">                B[i+<span class="number">1</span>] = temp2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;按结束时间排序后的会议排列表:&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cout&lt;&lt;i&lt;&lt;<span class="string">&quot;  &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cout&lt;&lt;B[i]&lt;&lt;<span class="string">&quot;  &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cout&lt;&lt;E[i]&lt;&lt;<span class="string">&quot;  &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GreedySelector</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> B[], <span class="keyword">int</span> E[], <span class="keyword">bool</span> A[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    A[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">    j=<span class="number">1</span>;i=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(B[i]&gt;=E[j])&#123;</span><br><span class="line">            A[i] = <span class="literal">true</span>;</span><br><span class="line">            j = i;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            A[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;会议集合为&#123;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i])&#123;</span><br><span class="line">            cout&lt;&lt;i&lt;&lt;<span class="string">&quot;,&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;&#125;&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="程序存储问题"><a href="#程序存储问题" class="headerlink" title="程序存储问题"></a>程序存储问题</h3><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220110233929.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220110233929.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220110233922801" style="zoom:67%;" /><h4 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h4><p>条件：磁盘空间有限；程序大小不同。</p><p>在有限的磁盘上存放尽可能多的程序，就要求选择的程序尽可能小。</p><h4 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h4><p>贪心算法：总是从可选程序中选择最小的试放入磁盘。</p><p>\1. 排序：对程序按大小升序排；</p><p>\2. 循环添加：从i = 1开始，选择排序后序列的第 i 个（即a[i]，1 &lt;= i &lt;= n）个加入暂存（sum，初始为0），判断是否满足sum小于磁盘空间，是则计数（count++），否则跳出循环；</p><p>反证法证明贪心选择可以推出最优解：</p><p>\1. 证明选择可以从贪心（最小程序）开始：选择从最小程序开始即解不为空时可以选择最小程序。假设解不为空，从这样得到的选择序列中任选一个，用最小程序替换，放入程序数（count）不变；</p><p>\2. 证明最优子结构性质：在解不为空、第一次可以选择最小程序的前提下，假设在最优解中去掉第一次选择的最小程序后得到的子问题的最优解的count_0大于原问题最优解的count_1-1，那么将最小程序加入选择产生的解的count_2大于count_1，此时count_1不是最优解，这不成立。故此问题具有最优子结构性质。</p><h4 id="时间和空间复杂度分析"><a href="#时间和空间复杂度分析" class="headerlink" title="时间和空间复杂度分析"></a>时间和空间复杂度分析</h4><p>时间复杂度：程序进行了一次快排（O(nlogn)）和循环（O(n)），故时间复杂度为O(nlogn)；</p><p>空间复杂度：程序new了一个一维数组（a[n]）用于存放每个程序的大小，故时间复杂度为O(n)。</p><h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Greedy</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n,<span class="keyword">int</span> L)</span></span>&#123;</span><br><span class="line"><span class="built_in">sort</span>(a,a+n);</span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;<span class="comment">//最后一个元素为下标n-1的元素</span></span><br><span class="line">temp = temp + a[i];</span><br><span class="line"><span class="keyword">if</span> (temp&gt;L) <span class="keyword">return</span> i;</span><br><span class="line"><span class="keyword">if</span>(i==(n<span class="number">-1</span>)) <span class="keyword">return</span> n;<span class="comment">//就是缺了这里搞了很久，没有想到还有存得完的情况。也可以为return i+1 保持上下统一性。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">int</span> L;</span><br><span class="line">cin&gt;&gt;L;</span><br><span class="line"><span class="keyword">int</span> *a=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">cin&gt;&gt;a[i];</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;<span class="built_in">Greedy</span>(a,n,L); </span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h2><h3 id="设计思想-3"><a href="#设计思想-3" class="headerlink" title="设计思想"></a>设计思想</h3><p>回溯法也称为试探法，首先暂时放弃关于问题规模大小的限制，并将问题的候选解按某种顺序逐一枚举和检验。</p><ol><li><p>【回溯】当发现当前候选解不可能是解时，就选择下一个候选解；</p></li><li><p>【向前试探】倘若当前候选解除了还不满足问题规模要求外，满足所有其他要求时，继续扩大当前候选解的规模，并继续试探。</p></li><li><p>【找到解】如果当前候选解满足包括问题规模在内的所有要求时，该候选解就是问题的一解。</p></li></ol><blockquote><p>在解空间中搜索可行解或最优解的技术<br>以深度优先遍历进行搜索以避免遗漏可行解<br>以跳跃式搜索改善算法的运行效率 （剪枝：不满足约束条件的内节点的子树）</p></blockquote><h3 id="解题步骤-3"><a href="#解题步骤-3" class="headerlink" title="解题步骤"></a>解题步骤</h3><ol><li>针对具体问题，定义问题的解空间；</li><li>确定易于搜索的解空间结构（数据结构的选择）。</li><li>一般以DFS的方式搜索解空间。</li><li>在搜索过程中，可以使用剪枝函数等来优化算法。</li></ol><h3 id="算m点问题"><a href="#算m点问题" class="headerlink" title="算m点问题"></a>算m点问题</h3><h4 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h4><p>给定k个正整数，用算术运算符+，-，*，/将这个k接起来，使最终的复数恰为m</p><p>算法设计：对于任意给定的k个整数，给出计算m的算术表达式。若无解，则输出“No solution!”</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>在进行回溯的时候对于每一个数都可以选择用或者不用，如果用的话则有加、减、乘、除四种情况</p><p>用的时候分别对这四种进行回溯，如果最终有解的话则把当前计算的式子保存到栈中，最后一次性输出</p><p>用visit数组标记每个数是否使用过，用flag标记是否有解</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;             <span class="comment">//数的个数</span></span><br><span class="line"><span class="keyword">int</span> m;             <span class="comment">//目标数</span></span><br><span class="line"><span class="keyword">int</span> *nums;         <span class="comment">//n个数</span></span><br><span class="line"><span class="keyword">bool</span> *visit;       <span class="comment">//标记是否使用</span></span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">false</span>; <span class="comment">//标记是否有解</span></span><br><span class="line"></span><br><span class="line">stack&lt;string&gt; s;</span><br><span class="line">string str;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> dept, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dept &gt; n - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == m)</span><br><span class="line">        &#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (visit[i] == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            stringstream ss;</span><br><span class="line">            visit[i] = <span class="literal">true</span>; <span class="comment">//使用该数</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">backtrack</span>(dept + <span class="number">1</span>, value + nums[i]) &amp;&amp; dept != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ss &lt;&lt; value &lt;&lt; <span class="string">&quot;+&quot;</span> &lt;&lt; nums[i] &lt;&lt; <span class="string">&quot;=&quot;</span> &lt;&lt; value + nums[i];</span><br><span class="line">            ss &gt;&gt; str;</span><br><span class="line">            s.<span class="built_in">push</span>(str);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">backtrack</span>(dept + <span class="number">1</span>, value - nums[i]) &amp;&amp; dept != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ss &lt;&lt; value &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; nums[i] &lt;&lt; <span class="string">&quot;=&quot;</span> &lt;&lt; value - nums[i];</span><br><span class="line">            ss &gt;&gt; str;</span><br><span class="line">            s.<span class="built_in">push</span>(str);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">backtrack</span>(dept + <span class="number">1</span>, value * nums[i]) &amp;&amp; dept != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ss &lt;&lt; value &lt;&lt; <span class="string">&quot;*&quot;</span> &lt;&lt; nums[i] &lt;&lt; <span class="string">&quot;=&quot;</span> &lt;&lt; value * nums[i];</span><br><span class="line">            ss &gt;&gt; str;</span><br><span class="line">            s.<span class="built_in">push</span>(str);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">backtrack</span>(dept + <span class="number">1</span>, value / nums[i]) &amp;&amp; dept != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ss &lt;&lt; value &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; nums[i] &lt;&lt; <span class="string">&quot;=&quot;</span> &lt;&lt; value / nums[i];</span><br><span class="line">            ss &gt;&gt; str;</span><br><span class="line">            s.<span class="built_in">push</span>(str);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visit[i] = <span class="literal">false</span>; <span class="comment">//不使用该数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    nums = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    visit = <span class="keyword">new</span> <span class="keyword">bool</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; nums[i];</span><br><span class="line">        visit[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">backtrack</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!s.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; s.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No solution!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] nums;</span><br><span class="line">    <span class="keyword">delete</span>[] visit;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="世界名画陈列馆"><a href="#世界名画陈列馆" class="headerlink" title="世界名画陈列馆"></a>世界名画陈列馆</h3><h4 id="Description"><a href="#Description" class="headerlink" title="Description:"></a>Description:</h4><p> 世界名画陈列馆由m´n个排列成矩形阵列的陈列室组成。为了防止名画被盗，需要在陈列室中设置警卫机器人哨位。每个警卫机器人除了监视它所在的陈列室外，还可以监视与它所在的陈列室相邻的上、下、左、右4 个陈列室。试设计一个安排警卫机器人哨位的算法，<br>使得名画陈列馆中每一个陈列室都在警卫机器人的监视之下，且所用的警卫机器人数最少。</p><p>设计一个优先队列式分支限界法，计算警卫机器人的最佳哨位安排，使得名画陈列馆中每一个陈列室都在警卫机器人的监视之下，且所用的警卫机器人数最少。</p><p>Input:<br>第一行有2 个正整数m和n (1≤m,n≤20)<br>Output:<br> 将计算出的警卫机器人数及其最佳哨位安排输出。第一行是警卫机器人数；接下来的m行中每行n个数，0 表示无哨位，1 表示哨位。<br>Sample Input:<br>4 4<br>Copy<br>Sample Output:<br>4<br>0 0 1 0<br>1 0 0 0<br>0 0 0 1<br>0 1 0 0</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>当y[i][j+1]==1时，以q为根的子树的解，不优于以p为根的子树的解，</p><p>当y[i][j+1]==1且y[i][j+2]==1时，以r为根的子树的解，不优于以p为根的子树的解。</p><p>搜索时应按照p、q、r或p、r、q的顺序来扩展结点。</p><p><strong>剪枝策略:</strong></p><p>放置的机器人个数不会超过n<em>m/3+1个(按每个机器人仅辐射左右或上下考虑，堆叠这样的小长条可得)。以n</em>m/3+2为初始最优值，当放置的个数超过当前最优值时，剪去。<br>(当前最优值ans-当前已放置个数p)<em>5（最多能增加5个监视点）。如果小于未监视的格点数（n</em>m-spys），则一定达不到比当前最优值更好的情况，剪去。</p><h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n,m,f[<span class="number">5</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;; <span class="comment">//自己本身+上下左右 </span></span><br><span class="line"><span class="keyword">int</span> anx[<span class="number">30</span>][<span class="number">30</span>],ans; <span class="comment">//最优结果 ans-警卫个数 anx-警卫位置 </span></span><br><span class="line"><span class="keyword">int</span> put[<span class="number">30</span>][<span class="number">30</span>],p; <span class="comment">//暂时存储 p-警卫个数 put-警卫位置 </span></span><br><span class="line"><span class="keyword">int</span> spy[<span class="number">30</span>][<span class="number">30</span>],spys; <span class="comment">//spy-被监视的展柜位置 spys-被监视的展柜个数 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">puta</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(p&gt;=ans) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=n&amp;&amp;spy[i][j]) <span class="comment">//已放置的不再被搜索</span></span><br><span class="line">&#123;</span><br><span class="line">j++;</span><br><span class="line"><span class="keyword">if</span>(j&gt;m)i++,j=<span class="number">1</span>; <span class="comment">//换行 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i&gt;n) <span class="comment">//更新答案</span></span><br><span class="line">&#123;</span><br><span class="line">ans=p;</span><br><span class="line"><span class="built_in">memcpy</span>(anx, put, <span class="keyword">sizeof</span>(put)); <span class="comment">//把put内容复制给anx </span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//剪枝</span></span><br><span class="line">    <span class="keyword">if</span>((ans-p)*<span class="number">5</span>&lt;=n*m-spys) <span class="keyword">return</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span>(i&lt;n) puta(i+<span class="number">1</span>,j,i,j);</span><br><span class="line">    <span class="keyword">if</span>(spy[i][j+<span class="number">1</span>]==<span class="number">0</span>) puta(i,j,i,j);</span><br><span class="line">    <span class="keyword">if</span>(j&lt;m&amp;&amp;(spy[i][j+<span class="number">1</span>]==<span class="number">0</span>||spy[i][j+<span class="number">2</span>]==<span class="number">0</span>)) puta(i,j+<span class="number">1</span>,i,j);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">puta</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> c,<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">put[x][y]=<span class="number">1</span>;</span><br><span class="line">p++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> xx=x+f[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> yy=y+f[i][<span class="number">1</span>];</span><br><span class="line">        spy[xx][yy]++;</span><br><span class="line">        <span class="keyword">if</span>(spy[xx][yy]==<span class="number">1</span>) spys++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">search(c,d+<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">put[x][y] = <span class="number">0</span>;</span><br><span class="line">p--;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> xx=x+f[i][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> yy=y+f[i][<span class="number">1</span>];</span><br><span class="line">    spy[xx][yy]--;</span><br><span class="line">    <span class="keyword">if</span>(spy[xx][yy]==<span class="number">0</span>) spys--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">ans=n*m/<span class="number">3</span>+<span class="number">2</span>;</span><br><span class="line">p=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//设置边界 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n+<span class="number">1</span>;i++)</span><br><span class="line">spy[i][<span class="number">0</span>]=spy[i][m+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m+<span class="number">1</span>;i++)</span><br><span class="line">spy[<span class="number">0</span>][i]=spy[n+<span class="number">1</span>][i]=<span class="number">1</span>;</span><br><span class="line">search(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,anx[i][j]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="加法链"><a href="#加法链" class="headerlink" title="加法链"></a>加法链</h3><h4 id="问题描述-5"><a href="#问题描述-5" class="headerlink" title="问题描述"></a>问题描述</h4><p>最优求幂问题:给定一个正整数n和一个实数x，如何用最少的乘法次数计算出xn 。 例如，可以用 6 次乘法逐步计算 x23 如下: x，x2，x3，x5，x10，x20，x23 。可以证明 计算 x23 最少需要 6 次乘法。计算 x23 的幂序列中各幂次 1，2，3，5，10，20，23 组成了一 个关于整数 23 的加法链。在一般情况下，计算 xn 的幂序列中各幂次组成正整数 n 的一个加法链：<br>1=a0&lt;a1&lt;a2&lt;…&lt;ar=n</p><p>ai=aj+ak,k≤j&lt;i,i=1,2,…,r</p><p>上述最优求幂问题相应于正整数 n 的最短加法链问题，即求 n 的一个加法链使其长度 r 达到最小。正整数n的最短加法链长度记为l(n)。</p><p>对于给定的正整数 n ，编程计算相应于正整数 n 的最短加法链。</p><p>数据输入：<br>第 1 行有 1 个正整数 n。</p><h4 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h4><p>使用深搜相对于广搜的有点之处在于空间复杂度上会有优化，每一条深度上的路径只需要保存该路径即可。但是当加法链扩散出去后，时间复杂度上会程指数增长，所以得加以剪枝函数。<br>一开始考虑较为简单的剪枝函数，即当当前搜索的层数小于已经搜出的最短答案时返回。即当l&gt;=ans的时候返回。<br>但是该剪枝效果也不是很好，当n大于200时，时间明显增长。之后我选择了另一种剪枝，剪枝效果更好。<br>假设当前搜到的层数为l，当前搜到的数为t目标数为n，则从t到n最短的加法链则是t-&gt;t<em>2-&gt;t</em>4..-&gt;n，即每次都乘2，长度是,所以当l+log2(n/t)&lt;=ans,就可以返回了。没必要每次都运算，而对于这个长度，可以实现打出从i到j的最短路径长度以供每次直接以o(1)复杂度获取。</p><h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 10005 </span></span><br><span class="line"><span class="keyword">int</span> a[MAX],r[MAX], b[<span class="number">2</span>*MAX];</span><br><span class="line"><span class="keyword">int</span> n,ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    ans = n;</span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=n; i&lt;=n+n; i++)</span><br><span class="line">    b[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=n<span class="number">-1</span>; i&gt;<span class="number">0</span>; i--)</span><br><span class="line">    b[i]=b[i+i]+<span class="number">1</span>;               <span class="comment">//b[i]中记录着到当前数最短的距离数</span></span><br><span class="line">&#125; </span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">printf</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> i;</span><br><span class="line">      <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;ans; i++)</span><br><span class="line">      cout&lt;&lt;r[i]&lt;&lt;” “;</span><br><span class="line">      cout&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">  cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> l)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> i, k;</span><br><span class="line">      <span class="keyword">if</span>(l+b[a[l]]&gt;=ans)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">if</span>(a[l]==n)</span><br><span class="line">      &#123;</span><br><span class="line">       ans = l;</span><br><span class="line">      <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;l; i++)</span><br><span class="line">      r[i]=a[i];</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span>(i=l; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">      <span class="keyword">for</span>(k=i; k&gt;=<span class="number">0</span>; k--)</span><br><span class="line">      &#123;</span><br><span class="line">       a[l+<span class="number">1</span>]=a[i]+a[k];</span><br><span class="line">        <span class="keyword">if</span>(a[l+<span class="number">1</span>]&gt;a[l]&amp;&amp;a[l+<span class="number">1</span>]&lt;=n)</span><br><span class="line">        <span class="built_in">dfs</span>(l+<span class="number">1</span>);</span><br><span class="line">      &#125; </span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="built_in">init</span>(n);</span><br><span class="line">     <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">     <span class="built_in">printf</span>();</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分支限界法"><a href="#分支限界法" class="headerlink" title="分支限界法"></a>分支限界法</h2><h3 id="设计思想-4"><a href="#设计思想-4" class="headerlink" title="设计思想"></a>设计思想</h3><p>分支是使用广度优先策略，依次生成扩展结点的所有分支。</p><p>限界是在结点扩展过程中，计算结点的上界，搜索的同时剪掉某些分支。</p><p>分支限界法就是把问题的可行解展开，再由各个分支寻找最佳解。</p><p>与回溯法类似，分支限界法也是在解空间中搜索得到解；</p><p>不同的是，分支限界法会生成所有扩展结点，并舍弃不可能通向最优解的结点，然后根据广度优先/最小耗费优先，从活结点中选择一个作为扩展结点，使搜索向解空间上有最优解的分支推进。</p><h3 id="搜索策略"><a href="#搜索策略" class="headerlink" title="搜索策略"></a>搜索策略</h3><ol><li>队列式(FIFO)分支限界法<ul><li>按照队列先进先出（FIFO）原则选取下一个节点为扩展节点。</li></ul></li><li>优先队列式分支限界法<ul><li>按照优先队列中规定的优先级选取优先级最高的节点成为当前扩展节点。</li></ul></li></ol><h3 id="分支限界法与回溯法的不同"><a href="#分支限界法与回溯法的不同" class="headerlink" title="分支限界法与回溯法的不同"></a>分支限界法与回溯法的不同</h3><ol><li>求解目标：回溯法的求解目标是找出解空间树中满足约束条件的所有解，而分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出在某种意义下的最优解。</li><li>搜索方式的不同：回溯法以深度优先的方式搜索解空间树，而分支限界法则以广度优先或以最小耗费优先的方式搜索解空间树。</li></ol><h3 id="求解步骤"><a href="#求解步骤" class="headerlink" title="求解步骤"></a>求解步骤</h3><ol><li>针对所给问题，定义问题的解空间（对解进行编码）；</li><li>确定易于搜索的解空间结构（按树或图组织解） ；</li><li>以广度优先或以最小耗费（最大收益）优先的方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。</li></ol><h3 id="单源最短路径"><a href="#单源最短路径" class="headerlink" title="单源最短路径"></a>单源最短路径</h3><p>给定一个带权有向图G=(V,E)，其中每条边的权是非负数。给定V中的一个顶点，成为源。现在要计算从源到所有其他个顶点的最短路径长度，这里路径长度指的是各边权之和。这个问题通常被称作单源最短路径问题。</p><p>如图所示，每一边都有一非负权值。求图G到原点s的到t的最短路径。</p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220110235242.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220110235242.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220110235238624" style="zoom:50%;" /><h4 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h4><p>  算法从G的源点s和空队列开始。结点s被扩展之后，他的儿子结点2,3,4倍一次插入队列当中。然后取出队头元素，进行下一步扩展。保证每一次扩展时，源到当前节点的和都是最小的。具体的解空间图如下:</p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220110235256.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220110235256.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220110235253026" style="zoom:50%;" /><h4 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h4><p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220110235319.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220110235319.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220110235316515"></p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcCell</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> adj;<span class="comment">//保存权值</span></span><br><span class="line">    <span class="keyword">int</span> info;<span class="comment">//存储最短路径长度</span></span><br><span class="line">&#125;ArcCell,AdjMaxtrix[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;VerType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    VerType vexs[<span class="number">100</span>];<span class="comment">//顶点向量</span></span><br><span class="line">    AdjMaxtrix arcs;</span><br><span class="line">    <span class="keyword">int</span> vexnum;<span class="comment">//顶点数</span></span><br><span class="line">    <span class="keyword">int</span> arcnum;<span class="comment">//弧数</span></span><br><span class="line">&#125;Graph;</span><br><span class="line"></span><br><span class="line">Graph G;</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateGraph</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m,n,t;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入顶点数和弧数:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;G.vexnum,&amp;G.arcnum);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入顶点:&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=G.vexnum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;G.vexs[i].data);</span><br><span class="line">        G.vexs[i].length=<span class="number">10000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=G.vexnum;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=G.vexnum;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            G.arcs[i][j].adj=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入弧及权重:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=G.arcnum;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;m,&amp;n,&amp;t);</span><br><span class="line">            G.arcs[m][n].adj=<span class="number">1</span>;</span><br><span class="line">            G.arcs[m][n].info=t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NextAdj</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=w+<span class="number">1</span>;i&lt;=G.vexnum;i++)</span><br><span class="line">        <span class="keyword">if</span>(G.arcs[v][i].adj)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//not found;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShortestPaths</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;<span class="comment">//从首个节点开始访问</span></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    G.vexs[v].length=<span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(G.vexs[v].data);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        t=q.<span class="built_in">front</span>();</span><br><span class="line">        k=<span class="built_in">NextAdj</span>(t,k);</span><br><span class="line">        <span class="keyword">while</span>(k!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(G.vexs[t].length+G.arcs[t][k].info&lt;=G.vexs[k].length)<span class="comment">//减枝操作</span></span><br><span class="line">            &#123;</span><br><span class="line">                G.vexs[k].length=G.vexs[t].length+G.arcs[t][k].info;</span><br><span class="line">                q.<span class="built_in">push</span>(G.vexs[k].data);</span><br><span class="line">            &#125;</span><br><span class="line">            k=<span class="built_in">NextAdj</span>(t,k);</span><br><span class="line">        &#125;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=G.vexnum;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d------%d\n&quot;</span>,G.vexs[i].data,G.vexs[i].length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">CreateGraph</span>();</span><br><span class="line">    <span class="built_in">ShortestPaths</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">Print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最小权顶点覆盖"><a href="#最小权顶点覆盖" class="headerlink" title="最小权顶点覆盖"></a>最小权顶点覆盖</h3><h4 id="问题描述-6"><a href="#问题描述-6" class="headerlink" title="问题描述"></a>问题描述</h4><p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220110235555.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220110235555.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220110235552781"></p><p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220110235608.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220110235608.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220110235605386"></p><h4 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h4><p>我们先简明介绍一下题目，我们仍然需要将所有点分成U、V两个集合。什么叫做顶点覆盖呢？即为V 集合中的每个点，至少与一个U集合中的点直接相连。如图所示（红色点表示U集合中的点）：</p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220110235627.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220110235627.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220110235623779" style="zoom:50%;" /><p>我们可以看到V集合中的顶点2、5、6，都与至少一个U集合中的顶点直接相连。反而如果按照下图分配则不满足条件：</p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220110235648.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220110235648.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220110235644843" style="zoom:50%;" /><p>图中V集合的顶点2、5并没有U集合中的点与其直接相连，所以不是一种顶点覆盖。</p><p>那我们应该如何判断图是否被覆盖了呢？可以开辟一个数组c，如果c[j]==0，则表示U集合中没有任何一个顶点与其直接相连。<br><strong>优先级</strong><br>说完如何判断是否覆盖之后，我们来确定一下优先级。由于所有顶点都是带权的，我们的目的也是找到最小权覆盖，所以我们可以直接用权重作为优先级建立一个最小堆，从而实现优先队列。<br><strong>界限函数</strong><br>我们找的是最小点权，无法使用界限函数来对右孩子进行约束，因为如果当前结点不加入U集合中(即走右孩子路径)，一定点权和更小，但是不一定会覆盖，所以不经过判断，我们也要将右孩子加入到队列中。<br><strong>将活结点加入队列中</strong><br>将活结点加入队列时，要对点的优先级、结果向量以及cover数组进行更新。</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeapNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">VC</span>;</span><span class="comment">//求解最小权覆盖问题的类,融合了所有函数和所需的参数</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in"><span class="keyword">operator</span></span> ()(<span class="keyword">int</span> x,<span class="keyword">int</span> y) <span class="keyword">const</span>&#123;<span class="keyword">return</span> x &lt; y;&#125;<span class="comment">//定义优先级</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> i,cn,*x,*c;<span class="comment">//i表示结点序号,cn表示当前权重,x表示结果数组,c数组表示此时是否有一点i属于U,且i与j相连,如果有,则c[j]!=0</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//解最小权顶点覆盖大类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VC</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="title">MinCover</span><span class="params">(<span class="keyword">int</span> **,<span class="keyword">int</span> [],<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">BBVC</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">cover</span><span class="params">(HeapNode E)</span></span>;<span class="comment">//判断图是否已经被全部覆盖了</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">AddLiveNode</span><span class="params">(priority_queue&lt;HeapNode&gt; &amp;H,HeapNode E,<span class="keyword">int</span> cn,<span class="keyword">int</span> i,<span class="keyword">bool</span> ch)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> **a,n,*w,*bestx,bestn;<span class="comment">//邻接矩阵,节点数目,每个点的权重,结果向量,最优解</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VC::BBVC</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">priority_queue&lt;HeapNode&gt; <span class="title">H</span><span class="params">(<span class="number">100000</span>)</span></span>;</span><br><span class="line">    HeapNode E<span class="comment">//扩展结点</span></span><br><span class="line">    E.x = <span class="keyword">new</span> <span class="keyword">int</span> [n+<span class="number">1</span>];<span class="comment">//开辟结果向量</span></span><br><span class="line">    E.c = <span class="keyword">new</span> <span class="keyword">int</span> [n+<span class="number">1</span>];<span class="comment">//开辟一数组,用于判断图是否被完全覆盖</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        E.x[j] = E.c[j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>,cn = <span class="number">0</span>;<span class="comment">//初始化当前点权总和为0</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">cover</span>(E))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)</span><br><span class="line">                    bestx[j]=E.x[j];</span><br><span class="line">                bestn = cn;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">cover</span>(E))<span class="comment">//如果当前没有完全覆盖,就将这个点加入到U集合中</span></span><br><span class="line">                <span class="built_in">AddLiveNode</span>(H,E,cn,i,<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">AddLiveNode</span>(H,E,cv,i,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(H.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        E = H.<span class="built_in">top</span>();</span><br><span class="line">        H.<span class="built_in">pop</span>();</span><br><span class="line">        cn = E.cn;</span><br><span class="line">        i = E.i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断图是否完全覆盖</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">VC::cover</span><span class="params">(HeapNode E)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(E.x[j]==<span class="number">0</span> &amp;&amp; E.c[j]==<span class="number">0</span>)<span class="comment">//如果此时j结点既不是U中的点,而且也没有U中的点与其相连,则至少这个点未被覆盖</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VC::AddLiveNode</span><span class="params">(priority_queue&lt;HeapNode&gt; &amp;H,HeapNode E,<span class="keyword">int</span> cn,<span class="keyword">int</span> i,<span class="keyword">bool</span> ch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HeapNode N;<span class="comment">//创建一个新的堆结点</span></span><br><span class="line">    N.x = <span class="keyword">new</span> <span class="keyword">int</span> [n+<span class="number">1</span>];</span><br><span class="line">    N.c = <span class="keyword">new</span> <span class="keyword">int</span> [n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        N.x[j] = E.x[j];</span><br><span class="line">        N.c[j] = E.c[j];</span><br><span class="line">    &#125;</span><br><span class="line">    N.x[i] = ch;</span><br><span class="line">    <span class="keyword">if</span>(ch)</span><br><span class="line">    &#123;</span><br><span class="line">        N.cn = cn + w[i];<span class="comment">//此时i要加入集合U,所以其权重应该加上cn</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i][j])</span><br><span class="line">                N.c[j]++;<span class="comment">//表明此时对于结点j来说,有一节点i属于U与其连接,表明这个点被覆盖了</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        N.cn = cn;</span><br><span class="line">    N.i = i;</span><br><span class="line">    H.<span class="built_in">push</span>(N);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//MinCover完成最小覆盖计算</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MinCover</span><span class="params">(<span class="keyword">int</span> **a,<span class="keyword">int</span> v[],<span class="keyword">int</span> n)</span><span class="comment">//v表示的是结点权重数组</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    VC Y;</span><br><span class="line">    Y.w = <span class="keyword">new</span> <span class="keyword">int</span> [n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)</span><br><span class="line">        Y.w[j] = v[j];</span><br><span class="line">    Y.a = a;</span><br><span class="line">    Y.n = n;</span><br><span class="line">    Y.bestx = v;</span><br><span class="line">    Y.<span class="built_in">BBVC</span>();</span><br><span class="line">    <span class="keyword">return</span> Y.bestn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,e,u,v;<span class="comment">//结点数,边数,u,v为结点编号</span></span><br><span class="line">    cin&gt;&gt;n&gt;&gt;e;</span><br><span class="line">    <span class="keyword">int</span> a[n+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            a[i][j] = <span class="number">0</span>;<span class="comment">//初始化为0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    p = <span class="keyword">new</span> <span class="keyword">int</span> [n+<span class="number">1</span>];<span class="comment">//定义结果向量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= e;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        a[u][v] = <span class="number">1</span>;</span><br><span class="line">        a[v][u] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">MinCover</span>(a,p,n)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        cout&lt;&lt;p[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="期末" scheme="http://xucoud.github.io/categories/%E6%9C%9F%E6%9C%AB/"/>
    
    <category term="算法设计与分析" scheme="http://xucoud.github.io/categories/%E6%9C%9F%E6%9C%AB/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"/>
    
    
    <category term="期末" scheme="http://xucoud.github.io/tags/%E6%9C%9F%E6%9C%AB/"/>
    
  </entry>
  
  <entry>
    <title>数据结构</title>
    <link href="http://xucoud.github.io/2022/01/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://xucoud.github.io/2022/01/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2022-01-26T06:44:09.575Z</published>
    <updated>2022-01-28T15:48:15.983Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>常用的数据结构的介绍以及自己的实现，会慢慢的进行补充······</p><span id="more"></span><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p>线性表是由零个或多个元素组成的有限序列。</p><p>元素之间是由顺序的，而且每一个至多由一个前驱和一个后继。</p><p>第一个元素无前驱，最后一个函数无后继。</p><h3 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h3><p><code>概念</code>：用<code>一组地址连续</code>的存储单元依次存储线性表的数据元素，这种存储结构的线性表称为顺序表。</p><p><code>特点</code>：逻辑上相邻的数据元素，物理次序也是相邻的。</p><p><code>优点</code>：方便查找和修改。知道了起始位置就可以直接找到目标位置，无需遍历数组去查找。</p><p><code>缺点</code>：删除不方便。删除掉一个位置的元素后，需要将这个元素之后的元素都向前补位。</p><p>​        只要确定了顺序表的起止位置，就可以直接对表中任意位置的数据进行随机存取，所以线性表中的顺序表是一种随机存储的存储结构。</p><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3>]]></content>
    
    
    <summary type="html">&lt;p&gt;常用的数据结构的介绍以及自己的实现，会慢慢的进行补充······&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构" scheme="http://xucoud.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="http://xucoud.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>操作系统期末</title>
    <link href="http://xucoud.github.io/2022/01/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB/"/>
    <id>http://xucoud.github.io/2022/01/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB/</id>
    <published>2022-01-26T06:44:09.530Z</published>
    <updated>2022-01-05T16:39:51.604Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><span id="more"></span><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="操作系统的分类"><a href="#操作系统的分类" class="headerlink" title="操作系统的分类"></a>操作系统的分类</h3><ul><li><p>批量操作系统</p></li><li><p>分时操作系统</p></li><li><p>实时操作系统</p></li><li><p>个人计算机操作系统</p></li><li><p>网络操作系统</p></li><li><p>分布式操作系统</p></li></ul><h3 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h3><p>并发共享，虚拟同步</p><h3 id="多道程序设计技术"><a href="#多道程序设计技术" class="headerlink" title="多道程序设计技术"></a>多道程序设计技术</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p><strong>多道程序设计技术</strong>是在计算机内存中同时存放几道相互独立的程序，它们在管理程序的控制下相互穿插地运行。</p><h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><ul><li>多道——计算机主存中存放几道相互独立的程序</li><li>宏观上并行——都处于运行状态，但都未运行完</li><li>微观上串行——各作业交替使用CPU</li></ul><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li><p><strong>资源利用率高</strong>：CPU和内存利用率较高；</p></li><li><p><strong>作业吞吐量大</strong>：单位时间内完成的工作总量大；</p></li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li><strong>用户交互性差</strong>：整个作业完成后或中间出错时，才与用户交互，不利于调试和修改；</li><li><strong>作业平均周转时间长</strong>：短作业的周转时间显著增长；</li></ul><h3 id="分时技术"><a href="#分时技术" class="headerlink" title="分时技术"></a>分时技术</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>​        把处理机的响应时间分成若于个大小相等（或不相等）的时间单位，称为时间片（如100毫秒），每个终端用户获得CPU，就等于获得一个时间片，该用户程序开始运行，当时间片到（用完），用户程序暂停运行，等待下一次运行。</p><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><p>​        它一般采用 <strong>时间片轮转</strong> 的办法，使一台计算机同时为多个终端用户服务，对每个用户都能保证足够快的响应时间，并提供交互会话功能。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li><p>同时性：众多联机用户可以同时使用同一台计算机</p></li><li><p>独占性：各终端用户感觉到自己独占了计算机</p></li><li><p>及时性：用户的要求能够及时得到响应</p></li><li><p>交互性：用户与计算机之间可进行会话</p></li></ul><h3 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h3><h4 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h4><p>​        <strong>实时操作系统</strong>是又一种类型的操作系统，对外部的请求，实时操作系统能够在规定的时间内处理完毕。主要用于过程控制、事务处理等有实时要求的领域，其<strong>主要特征</strong>是<code>实时性</code>和<code>可靠性</code>。</p><p><strong>实时：</strong>指计算机对于用户请求能足够快地进行处理，并做出反映。要求毫秒、微秒级。</p><h4 id="应用领域"><a href="#应用领域" class="headerlink" title="应用领域"></a>应用领域</h4><p><strong>实时控制</strong>：    工业过程控制、防空系统等</p><p><strong>实时信息处理</strong>：情报检索和查询、飞机订票系统、银行信用卡系统。</p><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul><li>系统对外部的信号必须能及时响应，(在规定的时间内（deadlin）)；</li><li>要求高可靠性和安全性，效率则放在第二位；</li><li>系统整体性强；</li><li>不要求很强的“会话”能力。</li></ul><h3 id="分时，批处理系统的异同"><a href="#分时，批处理系统的异同" class="headerlink" title="分时，批处理系统的异同"></a>分时，批处理系统的异同</h3><ol><li><p>用户体验上：<strong>批处理系统</strong>用户交互性差，只有作业完成或出错时才与用户交互，用户也不能控制作业的运行；而<strong>分时系统</strong>可以让用户的要求得到及时的响应</p></li><li><p>侧重层面上：<strong>批处理系统</strong>侧重于多个程序与操作系统的关系；<strong>分时系统</strong>侧重于多个用户与操作系统的关系</p></li><li><p>进程调度方式不同：<strong>批处理系统</strong>属于非抢占式的进程调度，只有一个程序因I/O请求阻塞时，才会执行下一道程序；<strong>分时系统</strong>属于抢占式的进程调度，一个程序只能在分配给他的时间片中才可以执行，时间片用完了，不管是否执行完，都要进行切换。</p></li><li><p>目的不同：<strong>批处理系统</strong>的目的是为了解决人机矛盾及CPU和I/O设备之间速度不匹配矛盾，提高系统有效性（包括资源利用率和吞吐量），并不提供人际交互能力；<strong>分时系统</strong>是实现人机交互的系统</p></li><li><p>相同：都是在微观上串行，宏观上并行</p></li></ol><h2 id="组织结构"><a href="#组织结构" class="headerlink" title="组织结构"></a>组织结构</h2><h3 id="操作系统的接口"><a href="#操作系统的接口" class="headerlink" title="操作系统的接口"></a>操作系统的接口</h3><ol><li>命令接口：（作业一级）提供一组控制命令供用户去组织和控制自己的作业</li><li>系统调用：（程序一级）通过一组广义指令（或称系统调用）供用户程序和其他系统程序调用</li></ol><h3 id="处理机的状态"><a href="#处理机的状态" class="headerlink" title="处理机的状态"></a>处理机的状态</h3><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ol><li>核态：CPU执行操作系统程序时所处的状态。在此状态下允许CPU使用全部资源和全部指令，其中包括一组特权指令（如涉及外设的I/O、改变处理机状态、修改存储保护的指令），实现对系统资源的分配与管理，为用户提供使用外部设备的服务。</li><li>管态：管态比核态的权限低，在此状态下允许使用一些用户态下不能使用的资源，但不能使用修改CPU状态的指令。无核态时，管态执行核态的全部功能。</li><li>用户态：用户程序执行时CPU所处的状态。在此状态下禁止使用特权指令，不能直接使用系统资源与改变CPU状态，并且只能访问用户程序所在的存储空间。</li></ol><h4 id="CPU状态转变"><a href="#CPU状态转变" class="headerlink" title="CPU状态转变"></a>CPU状态转变</h4><ol><li><p>目态–管态  ：其转换的唯一途径是通过中断</p></li><li><p>管态–目态  ：可用设置PSW(修改程序状态字)可实现</p></li></ol><h3 id="特权指令集"><a href="#特权指令集" class="headerlink" title="特权指令集"></a>特权指令集</h3><ol><li>在核态下操作系统可以使用所有指令，包括一组特权指令：<ul><li>允许和禁止中断；</li><li>在进程之间切换处理机；</li><li>存取用于内存保护的寄存器；</li><li>执行输入和输出操作；</li><li>停止一个中央处理机的工作。</li></ul></li><li>在下列情况下，由用户态转向核态：<ul><li>用户程序要求操作系统的服务，系统调用；</li><li>发生一次中断；</li><li>在用户程序中产生了一个错误的状态；</li><li>在用户程序中企图执行一条特权指令；</li></ul></li><li>从核态转回用户态用一条指令实现，这条指令也是特权指令。一般情况下是<strong>中断返回指令</strong>。</li></ol><h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><h4 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h4><ol><li>中断：是指某个事件（例如，电源掉电、浮点运算溢出、外部设备传输完成或出错等）发生时，系统中止现运行程序的执行，引出处理事件程序对相应事件进行处理，处理完毕后返回断点继续执行。</li><li>中断源：引起中断的事件称中断源，如打印完成中断，其中断源是打印机。</li><li>断点：发生中断时正在运行的程序被暂时停止，程序的暂停点称为断点。例如，某程序正在执行0200地址的指令被中断，那么，0200地址就是断点， 在中断返回时就执行0200的下一条指令。</li><li>中断响应：是处理机发现有中断请求时，中止现运行程序的执行并自动引出中断处理程序的过程。</li><li>中断处理程序：对中断事件进行处理的程序叫中断处理程序。如时钟中断处理、打印机完成中断处理、打印机缺纸中断处理等等。它是操作系统中与硬件最接近的一部分，是操作系统与硬件的接口。</li></ol><h4 id="引入中断的目的"><a href="#引入中断的目的" class="headerlink" title="引入中断的目的"></a>引入中断的目的</h4><ol><li>解决主机与外设的并行工作问题</li><li>提高可靠性</li><li>实现多机联系</li><li>实现实时控制</li></ol><h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><ol><li><p>中断随机的</p><ol start="2"><li>中断是可恢复的</li><li>中断是自动处理的</li></ol></li></ol><h4 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h4><ol><li>输入输出中断：它是当外部设备或通道操作正常结束或发生错误时所发生的中断。例如：打印机打印完成、缺纸，读磁盘时相应驱动器中没有磁盘等。</li><li>外中断：对某个中央处理机而言，它的外部非通道式装置所引起的中断称为外部中断。例如，时钟中断、操作员控制台中断，多处理机系统中CPU到CPU之间的通信中断等。</li><li>硬件故障中断：当机器发生故障时的中断叫硬件故障中断。例如，电源故障、内存单元奇偶校验错。</li><li>程序性中断：在程序执行的过程中，发现了程序性质的错误或出现了某些特定状态而产生的中断。如浮点溢出、用户态下使用了特权指令、内存越界、跟踪等。</li><li>访管中断：对操作系统提出某种请（需）求时所发生的中断。例如，创建进程，I/O传输、打开文件、关闭文件、文件的读、写等系统调用。</li></ol><blockquote><p>以上五种中断也归纳成两类<br>其一是来自处理机外部的事件，称为<strong>外部中断</strong>，如I/O中断、外中断。<br>另一类是来自处理机的中断，称为<strong>内部中断</strong>，如硬件故障中断、程序性中断、访管中断。这类中断有时称俘获（也有称陷入、陷阱、自陷、捕俘等，它的英文名称为 trap，来自早期的UNIX系统）。</p></blockquote><h4 id="中断机制"><a href="#中断机制" class="headerlink" title="中断机制"></a>中断机制</h4><ol><li>保护现场</li><li>中断响应</li><li>中断处理</li><li>恢复现场</li></ol><p><strong>现场</strong>：是被中断断点时刻处理机的各种信息，包括：</p><ol><li><p>程序状态字；</p></li><li><p>各寄存器的值；</p></li><li><p>打开文件的状态</p></li></ol><p><strong>保护现场：</strong>在进入中断时将现场信息保存到指定的位置，一般情况是保留到系统栈中。</p><p><strong>恢复现场：</strong>在中断处理完成后，返回断点之前将保留在栈中的断点的现场信息恢复，使被中断的程序能继续正确地执行。</p><h4 id="中断响应"><a href="#中断响应" class="headerlink" title="中断响应"></a>中断响应</h4><p><strong>中断响应：</strong>是处理机发现有中断请求时，中止现运行程序的执行，并自动引出中断处理程序的过程。中断响应的实质是交换指令执行地址和处理机的状态，以达到如下目的：</p><ol><li>保留程序断点及有关信息；</li><li>自动转入相应的中断处理程序执行。</li></ol><p><strong>中断响应过程:</strong></p><ol><li><p>发现中断源(识别中断原因)</p></li><li><p>保存现场,将中断向量推入系统堆栈</p></li><li><p>引出中断处理程序</p></li></ol><p><strong>中断响应具体做法:</strong> </p><ol><li>CPU在执行每条指令后扫描中断寄存器，查看有无中断请求。</li><li>如果没有，则运行下一条指令；</li><li>如果有中断请求，则通过交换中断向量引出（进入）中断处理程序</li></ol><h4 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h4><p>​        中断处理和自陷处理的过程是类似的，当硬件完成了中断进入后，转到中断处理程序，进入软件中断处理过程。这个过程主要有如下三项工作：</p><ol><li><p>保护现场和传递参数；</p></li><li><p>执行相应的中断（或自陷）处理程序；</p></li><li><p>恢复和退出。</p></li></ol><blockquote><p>在中断进入时由硬件保护了被中断程序的PC和PS，在中断处理中由软件保护各寄存器的值和其它状态信息。</p></blockquote><h4 id="分类-2"><a href="#分类-2" class="headerlink" title="分类"></a>分类</h4><ul><li><p><strong>硬件故障中断的处理</strong></p></li><li><p><strong>程序性中断事件的处理</strong></p></li><li><p><strong>外部中断事件的处理</strong></p></li><li><p><strong>外部设备中断的处理</strong></p></li><li><p><strong>自愿访管中断的处理</strong></p></li></ul><h3 id="程序状态字"><a href="#程序状态字" class="headerlink" title="程序状态字"></a>程序状态字</h3><p>在计算机系统中有一个寄存器（有的系统有几个寄存器）用来存放程序状态字，称为PS。</p><p>其中包括：</p><ol><li>指令计数器（PC Program counter,instruction counter)</li><li>程序现应执行哪条指令，当前指令执行的情况</li><li>机器处于何种状态（核态、用户态）</li><li>程序执行时应屏蔽哪些中断（处理机运行级）</li><li>寻址方式、编址、保护键</li><li>响应中断的内容</li></ol><h2 id="用户界面"><a href="#用户界面" class="headerlink" title="用户界面"></a>用户界面</h2><h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3><p><strong>作业：</strong>要求计算机系统按指定的步骤对原始数据进行处理，并得到计算结果的加工工作。</p><blockquote><p>在多道环境下，一个作业是一个单位，是一个用户的计算任务区别于其它用户的计算任务的一个计算单位。</p></blockquote><p><strong>作业步：</strong>对作业的加工工作中的一个步骤称为一个作业步。</p><p>在操作系统中，把编好源程序后上机调试的工作分成四个步骤，称为四个作业步：</p><ol><li>编辑（修改）</li><li>编译</li><li>连接</li><li>运行</li></ol><p><strong>作业步之间的关系：</strong></p><ul><li>每个作业步运行的结果产生下一作业步运行所需要的文件。</li><li>一个作业步能否正确执行，取决于前一作业步是否成功完成。</li></ul><h3 id="作业的状态"><a href="#作业的状态" class="headerlink" title="作业的状态"></a>作业的状态</h3><ol><li>进入状态：作业的信息从输入设备上预输入到输入井，此时称为作业处于进入状态。</li><li>后备状态：当作业的全部信息都已输入，且由操作系统将其存放在输入井中，此时称作业处于后备状态。系统将所有处于后备状态的作业组成后备作业队列，等待作业调度程序的调度。</li><li>运行状态：一个后备作业被作业调度程序选中，分配了必要的资源，调入内存运行，称作业处于运行状态。④</li><li>完成状态：当作业正常运行完毕或因发生错误非正常终止时，作业进入这完成状态。</li></ol><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p><strong>系统调用：</strong>就是用户在程序中调用操作系统所提供的一些子功能。是操作系统和用户的第二个接口。它是管理程序提供的服务界面，或更确切地说是操作系统中支持程序设计语言正常工作的支撑系统所提供的界面。</p><p>这是一种特殊的过程调用，这种调用通常是由特殊的机器指令实现的。除了提供对操作系统子程序的调用外，这个指令还将系统转入特权方式。因此系统调用程序被看成是一个低级的过程，只能由汇编语言直接访问。</p><p>系统调用是操作系统提供给编程人员的唯一接口。编程人员利用系统调用，动态请求和释放系统资源，调用系统中已有的系统功能来完成与计算机硬件部分相关的工作以及控制程序的执行速度等。</p><h4 id="系统调用与一般过程调用的区别"><a href="#系统调用与一般过程调用的区别" class="headerlink" title="系统调用与一般过程调用的区别"></a>系统调用与一般过程调用的区别</h4><ol><li>运行在不同的系统状态： 一般的过程调用，其调用程序和被调用程序都运行在相同的状态：核心态或用户态；而系统调用与一般调用的最大区别就在于：调用程序运行在用户态，而被调用程序则运行在核心态。</li><li>状态的转换：一般的过程调用不涉及系统状态的转换，但系统调用通常都是通过软中断机制先由用户态转换为核心态。</li><li>返回问题：一般的过程调用在被调用过程执行完后，将返回到调用过程继续执行。但系统调用结束后，系统将根据优先级进行调度。</li><li>嵌套调用：像一般过程一样，系统调用也允许嵌套调用，但每个系统对嵌套调用的深度都有一定的限制。</li></ol><h4 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h4><p><strong>系统调用</strong>是通过访管指令实现的。</p><p>​        在程序中，如果希望请求操作系统的服务（例如，打开一个文件，显示某个目录的内容等），就要执行一条访管指令（trap、int），系统处理这个中断，即为用户提供相应的服务（或者称响应用户的请求）。</p><blockquote><p>在汇编程序中是显式地使用访管中断命令，trap、INT。在高级语言中（C语言）是隐式使用访管指令。</p></blockquote><h2 id="并发处理"><a href="#并发处理" class="headerlink" title="并发处理"></a>并发处理</h2><h3 id="顺序执行"><a href="#顺序执行" class="headerlink" title="顺序执行"></a>顺序执行</h3><h4 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h4><p>一个程序由若干个程序段组成，而这些程序段的执行必须是顺序的，这种程序执行的方式就称为程序的顺序执行。</p><ol><li>数据：用来表示人们思维对象的抽象概念的物理表现；</li><li>信息：经过解释和处理以满足人们特定需要的数据；</li><li>操作：数据处理的规则；</li><li>计算：对某一有限数据的集合所施行的、目的在于解决某一问题的一组有限的操作的集合。</li></ol><h4 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h4><ol><li>顺序性：处理机严格按照程序所规定的顺序执行，即每个操作必须在下一个操作开始之前结束；</li><li>封闭性：程序一旦开始执行，其计算结果不受外界的影响，当程序的初始条件给定之后，其后的状态只能由程序本身确定，即只有本程序才能改变它；</li><li>可再现性：程序执行的结果与初始条件有关，而与执行时间无关。即只要程序的初始条件相同，它的执行结果是相同的，不论它在什么时间执行，也不管计算机的运行速度。</li></ol><h3 id="并发执行"><a href="#并发执行" class="headerlink" title="并发执行"></a>并发执行</h3><h4 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a>概念</h4><p>若干个程序段同时在系统中运行，这些程序的执行在时间上是重迭的，一个程序段的执行尚未结束，另一个程序段的执行已经开始，即使这种重迭是很小的，也称这几个程序段是并发执行的。</p><h4 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h4><ul><li>失去了程序的封闭性和结果的可再现性<ul><li>如果程序执行的结果是一个与时间无关的函数，即具有封闭性。</li><li>若一个程序的执行可改变另一个程序的变量，象二个并发程序完成誊抄的例子，程序执行的结果不仅依赖于程序的初始条件，还依赖于程序执行时的相对速度，在这种情况下就失去了程序的封闭性。</li></ul></li><li>程序与计算不再一一对应<ul><li>在程序顺序执行时，一个程序总是对应一个具体的计算，但在程序的并发执行时，可能有多用户共享使用同一个程序，但处理（计算）的对象却是不同的，例如，在多用户环境下，可能同时有多个用户调用C语言的编译程序，每一个调用被称之为一个计算，这就是典型的一个程序对应多个计算的情况。</li></ul></li><li>程序执行的间断性<ul><li>程序在并发执行时，由于它们共享资源或为完成同一项任务而相互合作，致使在并发程序之间形成了相互制约的关系。这种相互制约将导致并发程序具有“执行—暂停执行—执行”这种间断性的活动规律。</li></ul></li><li>资源共享<ul><li>程序的并发执行与资源共享之间互为条件：一方面，资源共享是以程序并发执行为条件的；另一方面，资源共享的有效管理必将影响程序的并发执行程度。</li></ul></li></ul><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><h4 id="概念-6"><a href="#概念-6" class="headerlink" title="概念"></a>概念</h4><p>即是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。</p><h4 id="特征-1"><a href="#特征-1" class="headerlink" title="特征"></a>特征</h4><ul><li>并发性<ul><li>任何进程都可以同其他进程一起向前推进</li></ul></li><li>动态性<ul><li>进程对应程序的执行</li><li>进程是动态产生，动态消亡的</li><li>进程在其生命周期内，在三种基本状态之间转换</li></ul></li><li>独立性<ul><li>进程是CPU调度的一个独立单位</li></ul></li><li>交互性<ul><li>指进程在执行过程中可能与其它进程产生直接或间接的关系</li></ul></li><li>异步<ul><li>每个进程都与其相对独立的不可预知的速度向前推进</li></ul></li><li>结构性<ul><li>进程的组成：程序+数据+PCB</li></ul></li></ul><h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4><p><strong>进程在系统中的活动规律是：</strong><br>      执行——&gt;暂停——&gt;执行</p><p><strong>进程的三种基本状态：</strong></p><ul><li>运行状态<ul><li>当进程由调度/分派程序分派后，得到CPU控制权，它的程序正在运行，该进程所处的状态为运行状态。（在单CPU系统中，总只有一个进程处于此状态）</li></ul></li><li>就绪状态<ul><li>存在于处理机调度队列中的那些进程，它们已经准备就绪，一旦得到CPU，就立即可以运行，这些进程所取的状态为就绪状态。（有多个进程处于此状态）</li></ul></li><li>等待状态（又称阻塞、挂起、睡眠）<ul><li>若一个进程正在等待某个事件的发生（如等待I/O的完成），而暂停执行，这时，即使给它CPU时间，它也无法执行，则称该进程处于等待状态。</li></ul></li></ul><p><strong>其他状态：</strong></p><ol><li>终止状态</li><li>挂起状态<ul><li>引入挂起状态可能是基于下述需要：调节负载，对换，父进程，操作系统，终端用户</li></ul></li><li>创建( 新new)状态<ul><li>OS 已完成为创建一进程所必要的工作<ul><li>已构造了进程标识符</li><li>已创建了管理进程所需的表格</li></ul></li><li>但还没有允许执行该进程 (尚未同意)<ul><li>因为资源有限</li></ul></li></ul></li><li>终止（退出exit)状态<ul><li>中止后进程移入该状态</li><li>它不再有执行资格</li><li>表格和其它信息暂时由辅助程序保留<br>例子: 为处理用户帐单而累计资源使用情况的财务程序</li></ul></li><li>当数据不再需要后，进程(和它的表格)被删除</li></ol><p><strong>状态变迁：</strong></p><p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220104225724.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220104225724.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220104225715424"></p><p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220104225732.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220104225732.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220104225731547"></p><h3 id="进程的三种基本状态"><a href="#进程的三种基本状态" class="headerlink" title="进程的三种基本状态"></a>进程的三种基本状态</h3><p>(1) 就绪(Ready)状态</p><p>(2) 执行(Running)状态</p><p>(3) 阻塞(Block)状态。</p><p>进程的五种基本状态和转换<br><img src="https://img-blog.csdnimg.cn/20210705162019277.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk2OTE0Mg==,size_16,color_FFFFFF,t_70#pic_center" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/20210705162019277.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk2OTE0Mg==,size_16,color_FFFFFF,t_70#pic_center" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述" style="zoom:67%;" /></p><p>具有创建、终止和挂起状态的进程状态图<br><img src="https://img-blog.csdnimg.cn/20210705162032117.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk2OTE0Mg==,size_16,color_FFFFFF,t_70#pic_center" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/20210705162032117.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk2OTE0Mg==,size_16,color_FFFFFF,t_70#pic_center" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="zoom:67%;" /></p><h4 id="进程和程序的区别"><a href="#进程和程序的区别" class="headerlink" title="进程和程序的区别"></a>进程和程序的区别</h4><p><strong>进程实体的组成</strong></p><ol><li><p>程序：表示该进程所要进行的操作；</p></li><li><p>数据集合：程序加工的对象和场所、它包括操作的数据和程序自己的变量单元。</p></li><li><p>进程控制块PCB：用于刻画一个进程在各个不同时期所处的状态的数据块。</p></li></ol><blockquote><p>进程＝程序＋数据＋PCB</p></blockquote><h4 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h4><p><strong>进程控制块</strong> PCB (Process Control Block)</p><ul><li>存放进程的管理和控制信息的数据结构称为进程控制块。它是进程管理和控制的最重要的数据结构，在创建时，建立PCB，并伴随进程运行的全过程，直到进程撤消而撤消。PCB就象我们的户口。</li></ul><p>作用：用以标识一个进程的存在。是标识进程的唯一实体。</p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220104230115.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220104230115.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220104230105691" style="zoom:67%;" /><p><strong>作用：</strong></p><ol><li>PCB是进程组成中最关键部分。</li><li>每个进程有惟一的进程控制块；</li><li>操作系统根据PCB对进程实施管理和控制</li><li>进程的动态、并发等特征是利用PCB表现出来的；</li><li>PCB是进程存在的惟一标志</li></ol><h4 id="原语"><a href="#原语" class="headerlink" title="原语"></a>原语</h4><ol><li>进程创建：fork</li><li>进程撤消：exit</li><li>进程阻塞：sleep</li><li>进程唤醒：wakeup</li></ol><h4 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h4><p>​        在操作系统中，当某一进程正在访问某临界区时，就不允许其它进程进入，否则就会发生无法估计的错误。我们把进程之间的这种相互制约的关系称为<strong>互斥</strong>。    </p><p><strong>引入互斥的目的：</strong>使并发程序正确执行，不发生与时间有关的错误。</p><p><strong>临界资源：</strong>一次仅允许一个进程使用的资源称为临界资源。</p><p><strong>临界区：</strong>每个进程中访问临界资源的那段程序段称为临界区（临界段）。</p><p><strong>公共变量：</strong>允许多个进程访问的变量。</p><p><strong>进入临界区的准则：</strong></p><ol><li>每次至多有一个进程处于临界区；</li><li>当有若干个进程欲进入临界区时，应在有限的时间内使其进入；</li><li>进程在临界区内仅逗留有限的时间。</li></ol><h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><p><strong>同步</strong>就是并发进程在一些关键点上可能需要相互等待与互通消息，这样的相互制约关系称为进程同步。</p><p><strong>同步机制：</strong>实现同步的机制。常用的有信号灯机制和管程机制。</p><p><strong>同步规则：</strong>同步的各进程之间应遵循的规则。</p><ol><li>空闲让进；</li><li>忙则等待；</li><li>有限等待；</li><li>让权等待。</li></ol><p><strong>实现：</strong></p><ol><li><strong>诸进程合作完成某工作的逻辑顺序</strong>。如考证问题；</li><li><strong>对系统资源的共享</strong>。如两个进程共享一个缓冲区完成誊抄问题。</li></ol><h4 id="互斥与同步的区别："><a href="#互斥与同步的区别：" class="headerlink" title="互斥与同步的区别："></a>互斥与同步的区别：</h4><p><strong>互斥：</strong>仅是让两个进程不能同时访问某资源；<br><strong>同步：</strong>互斥且同步执行的各进程前后顺序有限制。</p><h4 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h4><ol><li><p>低级通信：只能传递状态和整数值（控制信息），包括进程互斥和同步所采用的信号量和管程机制。</p><ul><li><p>优点的速度快。</p></li><li><p>缺点是：</p><ul><li><p>传送信息量小：效率低，每次通信传递的信息量固定，若传递较多信息则需要进行多次通信。</p></li><li><p>编程复杂：用户直接实现通信的细节，编程复杂，易出错。</p></li></ul></li></ul></li><li><p>高级通信：能够传送任意数量的数据，包括三类：</p><ul><li>直接通信：消息缓冲机制</li><li>间接通信：采用信箱为中介实现通信</li><li>管道通信</li></ul></li></ol><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h4 id="概念-7"><a href="#概念-7" class="headerlink" title="概念"></a>概念</h4><p>线程是比进程更小的活动单位，它是进程中的一个执行路径。一个进程可以有多个线程。</p><p><strong>线程的描述：</strong></p><ol><li>进程中的一条执行路径；</li><li>它有自己私用的堆栈和处理机执行环境（尤其是处理器寄存器）；</li><li>它与父进程共享分配给父进程的主存；</li><li>它是单个进程所创建的许多个同时存在的线程中的一个。</li></ol><h4 id="分类-3"><a href="#分类-3" class="headerlink" title="分类"></a>分类</h4><ol><li>用户级线程<ul><li>用户级线程仅存在于用户空间中。对于这种线程的创建、 撤消、线程之间的同步与通信等功能，都无须利用系统调用来实现。对于用户级线程的切换，通常是发生在一个应用进程的诸多线程之间，这时，也同样无须内核的支持。由于切换的规则远比进程调度和切换的规则简单，因而使线程的切换速度特别快。可见，这种线程是与内核无关的。</li><li>特点：<ul><li>内核不了解用户线程的存在；</li><li>用户线程切换不需要内核特权；</li><li>调度由应用软件内部进行，通常采用非抢先式和更简单的规则，也无需用户态/核心态切换，所以速度特别快。</li></ul></li></ul></li><li>内核支持线程 <ul><li>这里所谓的内核支持线程，也都同样是在内核的支持下运行的，即无论是用户进程中的线程，还是系统进程中的线程，他们的创建、撤消和切换等，也是依靠内核实现的。此外，在内核空间还为每一个内核支持线程设置了一个线程控制块， 内核是根据该控制块而感知某线程的存在的，并对其加以控制。 </li><li>特点：<ul><li>内核可以将同一进程中的多个线程调度到多个处理器上;</li><li>一个线程发起系统调用而阻塞，不会影响其它线程的运行，内核可以调度同一个进程中的另一个线程。</li></ul></li></ul></li></ol><h2 id="资源分配与调度"><a href="#资源分配与调度" class="headerlink" title="资源分配与调度"></a>资源分配与调度</h2><h3 id="概念-8"><a href="#概念-8" class="headerlink" title="概念"></a>概念</h3><p><strong>资源：</strong>执行一个用户程序所需要的全部硬件设备、软件设施和数据。包括：</p><ul><li><p>硬件资源：CPU、内存、各种I/O设备、存储设备、时钟等；</p></li><li><p>软件资源：系统程序、服务性程序、用户程序、语言处理程序等。</p></li></ul><h3 id="资源分配的方法"><a href="#资源分配的方法" class="headerlink" title="资源分配的方法"></a>资源分配的方法</h3><ol><li>静态分配：在调用某作业时根据用户的需求分配资源，并在作业完毕后回收所有资源的方式；</li><li>动态分配：在某一进程运行过程中根据运行情况动态地分配、使用和释放其所需地资源地方式。</li></ol><h3 id="资源管理的目的"><a href="#资源管理的目的" class="headerlink" title="资源管理的目的"></a>资源管理的目的</h3><ol><li>保证资源的高利用率；</li><li>在“合理”时间内使所有顾客有获得所需资源的机会；</li><li>对不可共享的资源实施互斥使用；</li><li>防止由资源分配不当而引起的死锁。</li></ol><h3 id="资源管理数据结构"><a href="#资源管理数据结构" class="headerlink" title="资源管理数据结构"></a>资源管理数据结构</h3><p>描述资源的管理和控制信息的<strong>数据结构</strong>称为<strong>资源分配的机构</strong> 。包括：资源描述器和 资源信息块</p><h4 id="资源描述器（rd）"><a href="#资源描述器（rd）" class="headerlink" title="资源描述器（rd）"></a><strong>资源描述器（rd）</strong></h4><p>描述各类资源的最小分配单位的数据结构</p><p>资源描述器中存放的信息取决于资源的特性与对该资源的管理方式。最简单的资源描述器可以用一个二进制位来实现，它表示该资源是可用的，还是已分配的。</p><p>对于各类资源来说，若它具有若干个（n个）资源分配单元，则描述该类资源的数据结构就是由n个描述器组织而成。</p><h4 id="资源信息块（rib）"><a href="#资源信息块（rib）" class="headerlink" title="资源信息块（rib）"></a><strong>资源信息块（rib）</strong></h4><p>用来说明资源、请求者以及实施分配所需信息。以实现对资源的有效分配。</p><p>对于每一类资源，存在两个队列：</p><ol><li><p>可利用资源队列</p></li><li><p>该类资源的等待队列</p></li></ol><p>在资源信息块中，分别由两个指针指向这两个队列。</p><p>另外还有一类为该类资源的分配程序入口地址。</p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h4 id="概念-9"><a href="#概念-9" class="headerlink" title="概念"></a>概念</h4><ol><li><p>死锁就是两个或两个以上的进程等候着一个永远不会发生的事件时所处的一种系统状态。</p></li><li><p>两个或两个以上并发进程，如果每个进程持有某种资源，而又等待着别的进程释放它或它们现在保持着的资源，否则就不能向前推进。此时，每个进程都占用了一定的资源，但又都不能向前推进。这种现象称为死锁。</p></li></ol><h4 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h4><ol><li><p>竞争资源</p><ul><li><p>在这两个进程并发执行时，当PA进程占有R1、PB进程占用R2时；</p></li><li><p>PA要求R2，由于PB已占有R2而得不到，PA进程只有等待；</p></li><li><p>PB申请R1，由于PA已占有R1，而得不到，PB进程只有等待；</p></li><li><p>从而出现了死等的情况。</p></li></ul></li><li><p>PV操作不当</p></li><li><p>资源分配不当</p><ul><li>资源总数小于进程所要求的总数。则有可能死锁</li></ul></li></ol><ol start="4"><li>临时性资源分配不当<ul><li>若P1等待P3的信件S3来到后再向进程P2发信件S1；</li><li>若P2等待P1的信件S1来到后再向进程P3发信件S2；</li><li>若P3等待P2的信件S2来到后再向进程P2发信件S3；</li></ul></li></ol><h4 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h4><ol><li>互斥条件</li><li>不可剥夺条件</li><li>部分分配</li><li>环路条件</li></ol><h4 id="破坏死锁的策略"><a href="#破坏死锁的策略" class="headerlink" title="破坏死锁的策略"></a>破坏死锁的策略</h4><ol><li>死锁预防：预先设置一些条件限制去破坏四个必要条件之一 ，从而预防死锁。<ul><li>缺点：系统资源利用率、吞吐率降低。</li></ul></li><li>死锁避免：不预先采取条件限制，只是在 动态分配前提下，防止进入不安全状态，从而避免死锁。<ul><li>适当提高资源利用率，吞吐率。</li></ul></li><li>死锁检测：允许死锁发生，再去检测发生死锁的进程和资源，然后去消除死锁；</li><li>死锁解除：取消或挂起相应发生死锁的进程，回收该进程资源，再分配给阻塞进程。<ul><li>发生死锁进程取消；</li><li>发生死锁进程部分取消；</li><li>重启动。</li></ul></li></ol><h4 id="死锁的预防"><a href="#死锁的预防" class="headerlink" title="死锁的预防"></a>死锁的预防</h4><ol><li><p>预先静态分配法(破坏部分分配条件)</p><ul><li>策略：作业调度时，仅当系统满足作业运行时所需的全部资源时，才把该作业调入内存运行。在作业运行前一次性将其所需的全部资源分配给它，于是在作业运行过程中不再会提出新的资源请求。</li><li>缺点：<ul><li>降低了对资源的利用率，降低进程的并发程度；</li><li>有可能无法预先知道所需资源；</li><li>延长了作业的等待时间    </li></ul></li></ul></li><li><p>有序资源使用法: (破坏循环等待条件)</p><ul><li>策略：把系统中的全部资源分别分给一个特定的序号，并且要求每个进程均应严格地按照序号递增的次序请求资源。       </li><li>优点：基于动态分配方法，资源利用率较前法    </li><li>缺点：                        <ul><li>限制进程对资源的请求；</li><li>资源的排序占用系统开销；         </li><li>资源序号尽可能反映多数作业的实际使用资源的顺序，但总有不合适的作业而造成资源浪费。</li></ul></li></ul></li><li><p>“可剥夺”资源使用法: (破坏“不可剥夺”条件)</p><ul><li>策略：在允许进程动态申请资源前提下规定，一个进程在申请新的资源不能立即得到满足而变为等待状态之前，必须释放已占有的全部资源，若需要再重新申请； </li><li>缺点：                        <ul><li>一个资源在使用一段时间后被释放，可能会造成前阶段工作的失效；</li><li>可能会导致某进程重复多次申请和释放资源，从而延长了进程周转时间,并增加了系统开销,降低了系统吞吐量；</li><li>只适用主存和处理器的分配,而不能对所有资源都适用。</li></ul></li></ul></li><li><p>破坏“互斥”条件:</p><ul><li>就是在系统里取消互斥。若资源不被一个进程独占使用，那么死锁是肯定不会发生的。但一般来说在所列的四个条件中，“互斥”条件是无法破坏的。因此，在死锁预防里主要是破坏其他几个必要条件，而不去涉及破坏“互斥”条件。</li></ul><blockquote><p>注意：互斥条件不能被破坏，否则会造成结果的不可再现性。</p></blockquote></li></ol><h2 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h2><h3 id="两级调度"><a href="#两级调度" class="headerlink" title="两级调度"></a>两级调度</h3><ol><li>宏观上：作业调度—使该作业对应的进程（进入就绪态），具有使用CPU的权利。<ul><li>任务：将外存上的作业有选择地调入内存，建立作业对应的进程，使其投入运行。</li></ul></li><li>微观上：进程调度—从各就绪进程中选中一个，使其占有CPU开始执行。<ul><li>任务：在进入内存的所有进程中，确定哪个进程何时占有CPU ，使用多长时间。</li></ul></li></ol><h3 id="三级调度"><a href="#三级调度" class="headerlink" title="三级调度"></a>三级调度</h3><p>在某些多道程序系统中，处理机的调度分为三级：</p><ol><li>高级调度（作业调度、宏观调度）<ol><li>按一定原则对外存输入井上的作业进行调度，并建立进程PCB。它决定允许哪些作业竞争系统资源。由于这种调度决定哪些作业可以进入系统，所以也称收容调度。作业一旦被系统收容，就便成进程或进程组。 </li></ol></li><li>中级调度（交换调度）<ol><li>它决定允许哪些进程竞争处理机。中级调度通过使进程临时挂起和激活的方法对系统负载波动作出反映，以便获得平稳的系统操作和实现较好的系统综合性能目标，中级调度的作用使作为作业进入系统和将中央处理机分配给这些作业二者之间的一个缓冲。</li></ol></li><li>低级调度（进程调度）<ol><li>它决定了存在就绪进程时，哪一个就绪进程将分配到中央处理机，并且把中央处理机实际分配给这个进程（即低级调度是将处理机分配给进程）。低级调度是由每秒可操作许多次的处理机调度程序执行，处理机调度程序应常驻内存。</li></ol></li></ol><h3 id="JCB"><a href="#JCB" class="headerlink" title="JCB"></a>JCB</h3><p>为了管理和调度作业，系统为每个作业设置了一个**作业控制块(JCB)**，它记录该作业的有关信息</p><p>JCB是作业在系统中存在的标志。</p><p>当作业进入系统时，为该作业建立一个JCB；当作业运行结束退出系统时，则它的JCB也一起被撤消。</p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220104235510.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220104235510.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220104235459845" style="zoom:67%;" /><h3 id="作业调度"><a href="#作业调度" class="headerlink" title="作业调度"></a>作业调度</h3><p><strong>作业调度的主要任务:</strong> 完成作业从后备状态到执行状态和从执行状态到完成状态的转变。</p><h4 id="作业调度功能："><a href="#作业调度功能：" class="headerlink" title="作业调度功能："></a><strong>作业调度功能：</strong></h4><ol><li>确定数据结构（建立JCB，Job Control Block）；</li><li>确定调度算法，按该算法，从后备作业中选择一个或几个作业进入系统内存；</li><li>为被选中的作业创建进程，并且为其申请系统资源；</li><li>作业结束后作善后处理工作。</li></ol><h4 id="作业调度目标："><a href="#作业调度目标：" class="headerlink" title="作业调度目标："></a><strong>作业调度目标：</strong></h4><ol><li>对所有作业应该是公平合理</li><li>应使设备有高的利用率</li><li>每天执行尽可能多的作业</li><li>有快的响应时间</li></ol><h4 id="调度性能的衡量："><a href="#调度性能的衡量：" class="headerlink" title="调度性能的衡量："></a><strong>调度性能的衡量：</strong></h4><ul><li>通常采用平均周转时间和带权平均周转时间</li><li>作业的周转时间：<ul><li>ti = tci-tsi</li><li>ti:作业周转时间</li><li>tci：作业完成时间</li><li>tsi:  作业提交时间</li></ul></li></ul><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220104235655.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220104235655.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220104235647813" style="zoom: 50%;" /><h4 id="作业调度算法"><a href="#作业调度算法" class="headerlink" title="作业调度算法"></a><strong>作业调度算法</strong></h4><ol><li>先来先服务调度算法（FCFS）<ul><li>先来先服务算法是按作业来到的先后次序进行调度的，换句话说，调度程序每次选择的作业是等待时间最久的，而不管作业的运行时间的长短。</li><li>优点: 实现简单;     缺点:效率较低</li><li>在一些实际的系统和一般应用程序中采用这种算法的较多。</li></ul></li><li>短作业优先调度算法（SJF）<ul><li>短作业优先调度算法考虑作业的运行时间，每次总是选择一个运行时间最小的作业调入内存（系统）。</li><li>优点:易实现,效率较高；</li><li>缺点:只照顾短作业,而未考虑长作业。</li><li><strong>该调度算法有最短的作业平均周转时间。</strong></li></ul></li><li>响应比高者优先调度算法（HRRN）<ul><li>这样算法从理论上讲是比较完备的，既照顾了短作业，又兼顾到了长作业；</li><li>但作业调度程序要统计作业的等待时间，使用用户的估计的运行时间，并要作浮点运算（这是系统程序最忌讳的）浪费大量的计算时间，这是系统程序所不允许的。</li></ul></li><li>优先数调度算法<ul><li>优先数调度算法是终合考虑各方面的因素（作业等待时间、运行时间、缓急程度，系统资源使用等），给每个作业设置一个优先数，调度程序总是选择一个优先数最大（或者最小）的作业调入（系统）内存。这种算法实现的困难在于如何终合考虑，这些因素之间的关系怎样处理。</li><li>确定优先数的考虑因素：<br>1、作业要求运行的急切程度；<br>2、作业运行时间的长短；<br>3、对资源要求的多寡。</li></ul></li><li>均衡调度算法<ul><li>按作业本身的特性分类，作业调度程序轮流从这些不同类的作业中挑选作业运行。</li><li>作业的分类方法之一：<br>（1）“短”作业：其特点是计算时间小于一定值，且无特殊的外设要求；<br>（2）“要用到磁带的作业”：要使用“一条或几条私用磁带<br>（3）“长”作业：作业所需的计算时间很长。</li><li>一般，系统总是从每一类中挑选一个作业出来，使其投入运行，以保持机器中的各部件均处于忙碌状态</li><li>分类方法之二：（按其输入输出的繁忙程度）<br>1）A类：输入输出繁忙的作业：<br>2）B类：输入输出与CPU均衡的作业；<br>3）C类：CPU繁忙的作业：</li><li>处理方法：系统总是力图保持运行作业中的A类与C类作业的数目相当，以使系统资源得到较均衡的使用。</li><li>均衡调度算法的缺陷<ul><li>均衡调度算法就是一种更为理想化的调度算法，如何实现就更困难，并且算法本身的开销有时会远选大于先来先服务和小作业优先调度算法的不足，这也是这种算法很难被采用的最根本的原因。</li></ul></li></ul></li></ol><h4 id="进程调度准则"><a href="#进程调度准则" class="headerlink" title="进程调度准则"></a>进程调度准则</h4><ol><li>CPU使用率——需要使CPU尽可能忙。其负荷应达到40%~90%；</li><li>吞吐量——使其单位时间内完成的进程数量尽可能多</li><li>周转时间——尽可能短（用于批处理系统）；</li><li>响应时间——尽可能短（用于交互式系统）；</li><li>等待时间——尽可能短（用于交互式系统）；</li></ol><h4 id="调度方式"><a href="#调度方式" class="headerlink" title="调度方式"></a>调度方式</h4><p><strong>调度方式：</strong>当一个进程正在处理机上执行时，若有某个更为“重要而紧迫”的进程需要进行处理时，亦即，若有优先级更高的进程进入就绪队列中时，如何分配处理机。</p><p><strong>进程调度方式的分类：</strong><br> 1、非剥夺方式</p><ul><li>分派程序一旦把处理机分配给某进程后便让它一直运行下去，直到进程完成或发生某事件而阻塞时，才把处理机分配给另一个进程。</li><li>优点：简单，系统开销小；</li><li>缺点：可能会使得紧急任务不能立即投入运行，以致延误时机。</li></ul><p> 2、剥夺方式</p><ul><li>当一个进程正在运行时，系统可以基于某种原则，剥夺已分配给它的处理机，将之分配给其它进程。</li><li>剥夺原则有：<ul><li>优先权原则：优先权较高的进程可剥夺优先权低的进程而运行；</li><li>短进程优先原则：短进程到达后可以剥夺长进程的运行；</li><li>时间片原则：一个时间片用完后重新调度。</li></ul></li><li>除了以上两种调度方式外，Shaw还提出一个选择可抢占策略，该策略是两种极端的抢占和不可抢占策略之间的折衷方案，该方案下，每个进程不仅被指派一个优先数，而且还有一对标志（ U、V ）<ul><li>U=1表示该进程可以抢占另一进程；</li><li>U=0表示该进程不可抢占另一进程；</li><li>V=1表示该进程可以被另一进程抢占；</li><li>V=0表示该进程不可被另一进程抢占。</li></ul></li></ul><h4 id="分配方式"><a href="#分配方式" class="headerlink" title="分配方式"></a>分配方式</h4><ol><li><p>静态优先数法：在进程创建时指定优先数，在进程运行时优先数不变</p><ul><li>确定进程优先数：<ul><li>系统确定：（运行时间、使用资源，进程的类型）</li><li>用户确定：（紧迫程度，计费与进程优先数有关）</li><li>系统与用户结合（用户可以为本用户的进程设置优先数，但不是作调度用，系统还要根据系统情况把用户设置的进程优先数作为确定进程优先数的一个参数）</li></ul></li></ul></li><li><p>动态进程优先数</p><ul><li>系统在运行的过程中，根据系统的设计目标，不断地调整进程的优先数，这种方法的优点是能比较客观地反映进程的实际情况和保证达到系统设计目标。如：<ul><li>在就绪队列中，等待时间延长则优先级提高，从而使优先级较低的进程在等待足够的时间后，其优先级提高到可被调度执行；</li><li>进程每执行一个时间片，就降低其优先级，从而一个进程持续执行时，其优先级降低到出让CPU。</li></ul></li></ul></li></ol><h2 id="主存管理"><a href="#主存管理" class="headerlink" title="主存管理"></a>主存管理</h2><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ol><li>映射逻辑地址到物理主存地址：将程序地址空间中使用的逻辑地址变换成主存中的地址。</li><li>在多用户之间分配物理主存：按照一定的算法把某一空闲的主存区分配给作业或进程。</li><li>对操作系统以及各用户的信息提供保护措施：保证用户程序(或进程映象)在各自的存储区域内操作，互不干扰。</li><li>扩充逻辑主存区：提供虚拟存储技术，使用户程序的大小和结构不受主存容量和结构的限制，即使在用户程序比实际主存容量还要大的情况下，程序也能正确运行。</li></ol><h3 id="虚存条件"><a href="#虚存条件" class="headerlink" title="虚存条件"></a>虚存条件</h3><ol><li>需要有相当容量的辅存；</li><li>要有一定容量的主存；</li><li>地址变换机构。引进虚存后必须在地址变换上花费开销，所以，在设计虚拟存储器时，应力求地址变换能快速进行。</li></ol><h3 id="动态地址映射"><a href="#动态地址映射" class="headerlink" title="动态地址映射"></a>动态地址映射</h3><p>动态运行时的装入程序，在把装入模块装入内存时，并不立即把装入模块中的相对地址转换为绝对地址，而是把这种地址转换，推迟到程序真正要执行时才进行。因此， 装入内存后的所有地址都仍是相对地址。 </p><p>系统中设置了重定位寄存器。</p><p><strong>动态地址映射技术能满足以下目标：</strong></p><ol><li>具有给一个用户程序任意分配内存区的能力；</li><li>可实现虚拟存储；</li><li>具有重新分配的能力；</li><li>对于一个用户程序，可以分配到多个不同的存储区。</li></ol><p><strong>优点：</strong></p><ol><li><p>OS可以将一个程序分散存放于不连续的内存空间，装入后程序可以移动；</p></li><li><p>较容易实现几个进程对同一程序副本的共享使用</p></li><li><p>能够支持程序执行中产生的地址引用，如指针变量（而不仅是生成可执行文件时的地址引用）；</p></li><li><p>能提供虚存功能</p></li></ol><p><strong>缺点：</strong>需要硬件支持（通常是CPU），OS实现较复杂。它是虚拟存储的基础。</p><h3 id="碎片"><a href="#碎片" class="headerlink" title="碎片"></a>碎片</h3><p><strong>碎片：</strong>在已分配区之间存在着的一些没有被充分利用的空闲区。</p><p><strong>碎片的危害：</strong>在按区分配方法中，根据申请按区分配主存，会把主存越分越零碎。在整个系统运行一段时间后，甚至会出现这样的局面：分布在主存各处的破碎空闲区占据了相当数量的空间，当一个作业申请一定数量的主存时，虽然此时空闲区的总和大于新作业所要的主存容量，但却没有单个的空闲区大到足够装下这个作业。</p><p><strong>紧凑（拼接技术）：</strong>移动存储器中某些已分配区中的信息，使本来分散的空闲区连成一个大的空闲区。</p><p><strong>拼接时机的选择：</strong></p><ol><li>某个分区回收时立即进行；<ul><li>缺点：拼接频率过高，系统开销加大。</li></ul></li><li>当找不到足够大的空白区，而空白区的存储容量总和却可以满足作业需要时进行。<ul><li>优点：拼接频率较小，系统开销较小；</li><li>缺点：空白区管理较复杂。</li></ul></li></ol><p><strong>拼接技术的缺点：</strong></p><ol><li>消耗系统资源；</li><li>拼接时必须停止所有其他的工作；</li><li>拼接需要重新定义已存入主存的作业。</li></ol><h3 id="基本的放置策略"><a href="#基本的放置策略" class="headerlink" title="基本的放置策略"></a>基本的放置策略</h3><h4 id="空闲区表的组织方法"><a href="#空闲区表的组织方法" class="headerlink" title="空闲区表的组织方法"></a>空闲区表的组织方法</h4><ol><li><p>按空闲区大小的升序（降序）组织；</p></li><li><p>按空闲区首址升序（降序）组织。</p></li></ol><h4 id="放置策略"><a href="#放置策略" class="headerlink" title="放置策略"></a>放置策略</h4><ol><li>最佳适应算法<ul><li>最佳适应算法是将申请者放入与其大小最接近的空闲区中。切割后的空闲区最小，若系统中有与申请区大小相等的空闲区，这种算法肯定能将这种空闲区分配给申请者。</li><li>最佳适应算法的空闲区表按空闲区大小升序方法组织。分配时，按申请的大小逐个与空闲区大小进行比较，找到一个满足要求的空闲区，就说明它是最适合的（即最佳的）。</li><li>优点：<br>（1）如果存储空间中具有正好是所要求大小的空白区，则它必然被选中；<br>（2）如果不存在这样的空白区，也只是对比要求稍大的空白区进行划分，而绝不会去划分更大的空白区。从而，在遇到有大的存储要求时，就比较容易得到满足。</li><li>缺点：<br>（1）产生的空白区太小，不能使用；<br>（2）回收分区时，将其插入到空白链中合适位置较费时。</li></ul></li><li>首次适应算法<ul><li>首次适应算法的表是按空闲区首址升序的（即空闲区表是按空闲区首址从小到大）方法组织的。     </li><li>分配时从表首开始，以请求内存区的大小逐个与空闲区进行比较，找到第一个满足要求的空闲后，若空闲区大小与请求区的大小相等，则将该空闲区分配给请求者，并撤消该空闲区所在表目；若大于请求区，就将该空闲区的一部分分配给请求者，然后，修改空闲区的大小和首址。</li><li><strong>首次适应算法的实质</strong>是尽可能地利用低地址部分的空闲区，而尽量地保证高地址部分的大空闲区，使其不被切削成小的区，其目的是保证在有大的作业的到来有足够大的空闲区来满足请求者。</li><li>回收时，首先考察释放区是否与系统中的某个空闲区相邻，若相邻则合并成一个空闲区，否则，将释放区作为一个空闲区按首址升序的规则插入到空闲区表适当的位置。</li><li>优点：<br>① 算法简单，查找速度快；<br>② 高址部分空白区被划分的机会少，故大作业较易得到满足。</li><li>缺点：<br>① 易造成很多“内存碎片”；<br>② 查找较大的空白区通常在链的尾端才能发现，故查找速度降低。</li></ul></li><li>最坏适应算法<ul><li>为了克服最佳适应算法把空闲区切割得大小的缺点，人们提出了一种最坏适应算法，即每次分配时，总是将最大的空闲区切去一部分分配给请求者，其依据是当一个很大的空闲区被切割了一部分后可能仍是一个较大的空闲区。避免了空闲区越分越小的问题。</li><li>最坏适应算法的空闲区表是按空闲区大小降序的方法组织的（从大到小的顺序）。分配时总是取表中的第一个表目，若不能满足申请者的要求，则表示系统中无满足要求的空闲区，分配失败；否则，将从该空闲区中分配给申请者，然后修改空闲区的大小，并将它插入到空闲区表的适当位置。</li><li>优点：<ul><li>使剩下的空闲区不至于太小，有可能仍能分配，对中小作业有利；</li></ul></li><li>缺点：<ul><li>会导致大作业的请求往往不能得到满足</li></ul></li></ul></li></ol><h3 id="请调策略"><a href="#请调策略" class="headerlink" title="请调策略"></a>请调策略</h3><ul><li>预调<ul><li>系统根据作业（进程）运行的情况，预测哪些页将要运行，在其运行之前先行调入内存，这样在程序运行的过程中就不会出现缺页中断。这样方法从表面上看起来很好，但系统无法预计系统中作业的运行情况，难以实现。</li></ul></li><li>请调<ul><li>进程在执行的过程中，发现要执行的程序或处理的数据不在内存，向系统提出调入相应程序的请求，系统响应用户的请求。</li></ul></li></ul><h3 id="置换策略"><a href="#置换策略" class="headerlink" title="置换策略"></a>置换策略</h3><h4 id="OPT（最佳算法）"><a href="#OPT（最佳算法）" class="headerlink" title="OPT（最佳算法）"></a>OPT（最佳算法）</h4><ul><li>缺页中断率f’ = f/a， 则最佳算法是f’最小的调度算法</li><li>当要调入一新页而必须淘汰一旧页时，所淘汰的页是以后不再使用的，或者是以后相当长的时间内不会使用的。这种算法是不可能的。</li><li>存在问题：由于无法预知哪个页面是未来最长时间内不被访问的，所以该算法只是一种理论上的算法.</li></ul><h4 id="FIFO（先进先出算法）"><a href="#FIFO（先进先出算法）" class="headerlink" title="FIFO（先进先出算法）"></a>FIFO（先进先出算法）</h4><ul><li>先进入内存的页，先退出内存。</li><li>实质上是淘汰在内存驻留时间最长的页。</li><li>其理由是：最早调入内存的页，不再被使用的可能性比近期调入内存的大。</li><li>这种算法简单，实现容易。</li></ul><h4 id="LRU（最久未使用淘汰算法）"><a href="#LRU（最久未使用淘汰算法）" class="headerlink" title="LRU（最久未使用淘汰算法）"></a>LRU（最久未使用淘汰算法）</h4><ul><li>这种算法的实质：当需要淘汰一页时，选择最长时间未使用的页。</li><li>依据的理论是如果某页被访问，它可能马上还要被访问；相反，如果某页长时间未被访问，它可能最近也不可能被访问。</li><li>缺点：<ul><li>在每次访问页面时都要修改有关信息，且需做连续修改，此工作由软件完成，代价太高；由硬件完成，大大增加成本。</li><li>故此,真正的LRU算法用得最少，得到推广的仅是一种LRU近似算法（也被称为Clock置换算法，后续会讲到）。</li></ul></li></ul><h4 id="LFU（最不经常使用淘汰算法）"><a href="#LFU（最不经常使用淘汰算法）" class="headerlink" title="LFU（最不经常使用淘汰算法）"></a>LFU（最不经常使用淘汰算法）</h4><ul><li>实质：把最近应用次数最少的页淘汰掉；</li><li>实现：为每一页设置一个计数器，初值为0。对每一页访问一次后，就将它相应计数器加1。过一定时间t后，将所有计数器一律清除。发生缺页中断时，选择计数器值最小的一页淘汰，同时将所有计数器清0。</li><li>优点：容易实现</li><li>缺点：代价较高</li></ul><h4 id="简单的Clock置换算法"><a href="#简单的Clock置换算法" class="headerlink" title="简单的Clock置换算法"></a>简单的Clock置换算法</h4><ul><li>这种算法，只要在存储分块表（或页表）中设一个“引用位”，当存储分块表中的某一页被访问时，该位由硬件自动置1，并由页面管理软件周期性把所有引用位置0。这样，在一个时间周期T内，某些被访问过的页面其引用位为1，而未被访问过的页面其引用位为0。</li><li>根据引用位的状态来判别各页面最近的使用情况。当需要置换一页面时，选择其引用位为0的页，如下图所示的算法。</li><li>缺点：<ul><li>使所有块的引用位重置0的周期T大小难以确定。若太大：可能使所有块的引用位均为1，不知谁是最近以来没访问过的。若太小：可能引用位为0的块相当多，也不利于选择。</li><li>若缺页刚好发生在系统对所有引用位重置0之后，则几乎所有块的引用位为0，同样不利于选择。</li></ul></li></ul><h3 id="分页，分段的区别"><a href="#分页，分段的区别" class="headerlink" title="分页，分段的区别"></a>分页，分段的区别</h3><ol><li>页是信息的物理单位，段是信息的逻辑单位；</li><li>页的大小是由系统固定的，段的长度因段而异，由用户决定；</li><li>分页的作业地址空间是一维的，分段的作业地址空间是二维的。</li></ol><h4 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h4><p>页表是页式存储管理的数据结构，它包括用户程序空间的页面与内存块的对应关系、页面的存储保护和存取控制方面的信息。</p><blockquote><p>页号    内存块号     存取控制    状态   其它<br>在实际的系统中，为了节省存储空间，在页表中可以省去页号这个表目。</p></blockquote><ul><li><p>页表的构成：</p><ul><li>由高速缓存组成：地址转换速度快，但成本高；</li><li>在主存固定区域开辟一些单元来存放。</li></ul></li><li><p>页表的使用：</p><ul><li>在主存分配时，建立页表；</li><li>在用户程序执行时，访问页表。</li></ul></li><li><p>页面尺寸的选择：</p><ul><li>若页面尺寸选得过大，以致和一般作业大小不相上下，则实际上就蜕化为按区分配法；</li><li>若页面尺寸太小，页表本身较大，浪费资源太多。</li></ul></li><li><p>虚地址以十进制数给出</p><ul><li>页号＝虚地址/页大小</li><li>位移量＝虚地址 mod 页大小</li><li>根据题意产生页表；</li><li>以页号查页表，得到对应页装入内存的块号</li><li>内存地址＝块号×页大小＋位移量</li></ul></li></ul><h2 id="输入-输出管理"><a href="#输入-输出管理" class="headerlink" title="输入/输出管理"></a>输入/输出管理</h2><h3 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h3><ul><li>状态跟踪<ul><li>设备控制块是存放设备管理和控制信息的数据结构。</li><li>系统要掌握设备的状态。</li></ul></li><li>设备存取<ul><li>实现对设备的存取操作。</li></ul></li><li>设备分配<ul><li>在多用户的环境下，负责设备的分配和回收。</li></ul></li><li>设备控制<ul><li>设备控制包括设备的驱动、完成和故障中断处理。</li></ul></li></ul><h3 id="分类-4"><a href="#分类-4" class="headerlink" title="分类"></a>分类</h3><ul><li>按传输速率分     <ul><li>低速设备：几～几十字节/秒          键盘</li><li>中速设备：几百～几千字节/秒      行式/激光打印机</li><li>高速设备：上万～上百万字节/秒   磁盘驱动器</li></ul></li><li>信息组织和处理方式<ul><li>块设备：信息按字符块组织和处理（面向块的设备：存储设备）</li><li>字符设备：信息按字符组织和处理（面向字符的设备：I/O设备）</li></ul></li><li>按从属关系分类<ul><li>系统设备：OS生成时已配置的各种标准设备</li><li>用户设备：用户自己提供，由系统管理，非标准</li></ul></li><li>按交互对象分类<ul><li>人机交互设备：视频显示器、键盘、鼠标、打印机</li><li>与计算机或其他电子设备交互的设备：磁盘、磁带、传感器、控制器</li><li>计算机间的通信设备：网卡、调制解调器</li></ul></li><li>按资源分配方式<ul><li>独占设备：在一段时间内只能有一个进程使用的设备，一般为低速I/O设备。（如打印机，磁带等）</li><li>共享设备：在一段时间内可有多个进程共同使用的设备，多个进程以交叉的方式来使用设备，其资源利用率高。（如硬盘）</li><li>虚拟设备：用软件技术把慢速独占设备变成共享设备。一般是通过借用大容量共享设备的一部分空间来充当缓冲而实现的。把这部分空间称为“虚拟设备”。 （Spooling 技术）</li></ul></li></ul><h3 id="设备独立性"><a href="#设备独立性" class="headerlink" title="设备独立性"></a>设备独立性</h3><h4 id="概念-10"><a href="#概念-10" class="headerlink" title="概念"></a>概念</h4><ul><li>设备独立性是指用户在编程序时所使用的设备与实际设备无关。</li><li>两类设备独立性：<ul><li>一个程序应独立于分配给它的某类设备的具体设备。即在用户程序中只指明I/O使用的设备类型即可。如在系统中配备了两台打印机，用户要打印时只要告诉系统要将信息送到打印机即可。</li><li>程序要尽可能地与它使用的设备类型无关。即在用户程序中只要指出要输入或输出信息，至于信息I/O使用的设备不需用户指明。</li></ul></li></ul><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><ul><li>逻辑设备和实际设备的联系通常是由操作系统命令语言（作业控制语言、键盘命令或用户程序中的语言级）中提供的信息实现的。</li><li>采用高级语言级则通过软通道实现。</li><li>计算机系统中配置有各种不同类型的独占设备，每一类独占设备又可以有好多台。为了对这些设备进行管理，计算机系统对每一台设备都要进行登记，且为每一台设备确定一个编号，以便区分和识别．这个确定的编号称为设备的绝对号。</li><li>在多道程序设计系统中，因为用户无法知道哪台设备正在被其他用户占用，哪台设备当前是空闲的，所以用户中请分配设备时不能使用设备的绝对号。</li><li>当用户要使用独占设备时，只需向系统说明所要使用的设备类型，至于实际应该使用哪一台，由系统根据该类设备的分配情况来决定。有时用户可能要求同时使用几台同类型设备，为了避免使用时的混乱，用户可以把自己要求使用的若干台同类设备给出编号。由用户对自己需要使用的若干台同类设备给出的编号称为设备的相对号。</li><li>用户总是用“设备类相对号”来提出使用设备的要求。系统在为用户分配具体设备时就建立“绝对号”与“设备类相对号”的对应关系。根据这个对应关系，系统就能知道对用户要求使用的设备实际上应启动哪台设备。 </li></ul><h3 id="缓冲技术"><a href="#缓冲技术" class="headerlink" title="缓冲技术"></a>缓冲技术</h3><h4 id="概念-11"><a href="#概念-11" class="headerlink" title="概念"></a>概念</h4><p>是用来在两种不同速度的设备之间传输信息时平滑传输过程的常用手段。</p><p>引入缓冲的原因：</p><ul><li>CPU与各种外部设备的速度上的差异很大，设备与设备之间的速度的差异也很大。</li><li>系统有时会产生大量的数据需要I/O，有时又会很长时间没有I/O。造成I/O负荷的不均匀。</li></ul><h4 id="目的-1"><a href="#目的-1" class="headerlink" title="目的"></a>目的</h4><ul><li>缓和CPU与I/O设备间速度不匹配的矛盾</li><li>提高它们之间的并行性</li><li>减少对CPU的中断次数，放宽CPU对中 断响应时间的要求</li></ul><h4 id="分类-5"><a href="#分类-5" class="headerlink" title="分类"></a>分类</h4><ul><li><p>缓冲区设置</p><ul><li><p>硬缓冲：在设备中设置缓冲区，由硬件实现；</p></li><li><p>软缓冲：在内存中开辟一个空间，用作缓冲区。</p></li></ul></li><li><p>缓冲区管理</p><ul><li>单缓冲</li><li>双缓冲</li><li>环形缓冲</li><li>缓冲池：多个缓冲区连接起来统一管理，常采用多缓冲管理</li></ul></li></ul><h4 id="静态分配和动态分配"><a href="#静态分配和动态分配" class="headerlink" title="静态分配和动态分配"></a><strong>静态分配和动态分配</strong></h4><p>静态分配<br>当一个作业（或进程）运行时，根据作业要求的设备，系统如果能满足，则将其要求的设备全部分配给它，然后开始运行，运行完成释放其占用的所有设备。<br>这种分配方式的优点是系统绝不会出现死锁，缺点是设备利用率太低。</p><p>动态分配<br>这种分配方法是在作业（或进程）运行的过程中，需要使用设备时，就向系统申请，系统根据某种分配原则进行分配。<br>这种方法的优点是设备的利用率高，缺点是系统有出现死锁的可能。</p><h3 id="Spooling"><a href="#Spooling" class="headerlink" title="Spooling"></a>Spooling</h3><h4 id="概念-12"><a href="#概念-12" class="headerlink" title="概念"></a>概念</h4><ul><li>利用CPU与通道可以并行工作的特点，原来在脱机系统中的预输入和缓输出工作全部由主机系统承担。</li><li>在操作系统设计了两个程序来代替两台卫星机的工作，这两个程序分别为“预输入程序”和“缓输出程序”在系统运行时形成进程工作。</li><li>同时在共享设备（磁盘）上开辟出两个称为“井”的特殊的区域来存放输入的信息和执行结果。</li></ul><h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><ol><li>硬件部分<ul><li>这部分包含了在磁盘或磁鼓上设立的两区域：输入井和输出井，以及在主存中开辟出的两个缓冲区：输入缓冲区和输出缓冲区。 </li><li>输入井：用来存放来自于输入设备的信息。</li><li>输出井：用来保存即将送到输出设备上的结果。</li><li>输入缓冲区：暂时保存外设准备送入输入井的信息。</li><li>输出缓冲区：暂时保存从输出井送出的结果。</li></ul></li><li>软件部分<ul><li>在这部分中，包含了预输入进程，缓输出进程，输入井管理进程，输出井管理进程。</li><li>预输入进程：将用户要求的输入数据输入到输入设备上，再经通道和输入缓冲区送入输入井。</li><li>缓输出进程：将用户的输出结果在设备空闲时从输出井中，经输出缓冲区送至输入设备。</li><li>输入井管理进程：将输入井中的数据读入内存。</li><li>输出井管理进程：将内存中的结果送至输出井中。</li></ul></li></ol><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220105152017.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220105152017.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220105151931423" style="zoom: 50%;" /><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><p>可使一个作业的I/O与其它作业的计算重叠起来进行</p><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul><li> 占用大量的内存空间</li><li>占用大量磁盘空间作为输入井和输出井</li><li>增加了系统的复杂性</li></ul><h3 id="CPU和外设数据的交换方式"><a href="#CPU和外设数据的交换方式" class="headerlink" title="CPU和外设数据的交换方式"></a>CPU和外设数据的交换方式</h3><h4 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h4><ol><li>在计算机中，端口又被称为接口。其主要功能是：<ul><li>按照计算机主机与设备的约定格式和过程接收或发送数据和信号。</li></ul></li><li>分类：<ul><li>从数据传输方式分类：并行接口/串行接口</li><li>从传送的同步方式来看：有异步和同步之分。</li></ul></li></ol><h4 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h4><ol><li>如果一个或多个设备使用一组共同的线，这张连接称为总线（bus）。</li><li>总线是一组线和一组严格定义的可以描述在线上传输信息的协议。在总线上可以连接多个设备，它们通过总线交换数据。</li><li>根据其传递信息类型分类：<ul><li>地址总线</li><li>数据总线</li><li>控制总线</li></ul></li></ol><h4 id="设备控制器"><a href="#设备控制器" class="headerlink" title="设备控制器"></a>设备控制器</h4><ol><li><p>设备控制器的主要功能是：控制一个或多个I/O设备，以实现I/O设备和计算机之间的数据交换。</p></li><li><p>它是CPU和I/O设备之间的接口，它接收从CPU发出的命令，并控制I/O设备工作。</p></li><li><p>它是一个可编址的设备，当它只控制一个设备时，它有唯一的一个设备地址；若它连接多个设备时，则应含有多个设备地址，使每一个设备地址对应一个设备。</p></li><li><p>设备控制器可分为两类：</p><ul><li>一类是控制字符设备的控制器</li><li>另一类是用于控制块设备的控制器。</li></ul></li><li><p>设备控制器的基本功能：</p><ul><li>接收和识别命令：接收从CPU发来的命令，并识别这些命令。 </li><li>数据交换：实现CPU与设备控制器之间、设备控制器与设备之间的数据交换。 </li><li>标识和报告设备的状态：控制器应记录下设备的状态供CPU了解。此状态值从设备对应的状态寄存器中读取。</li><li>地址识别：识别其所控制的每个设备的地址。 </li><li>数据缓冲：在控制器中设置缓冲以缓和I/O设备和CPU、内存之间的速度矛盾。 </li><li>差错控制：设备控制器还兼管对由I/O设备传来的数据进行差错检测。 </li></ul></li></ol><h3 id="I-O通道"><a href="#I-O通道" class="headerlink" title="I/O通道"></a>I/O通道</h3><h4 id="分类-6"><a href="#分类-6" class="headerlink" title="分类"></a>分类</h4><ol><li><p>字节多路通道</p><ul><li>字节多路通道以字节为单位传输信息，它可以分时地执行多个通道程序。当一个通道程序控制某台设备传送一个字节后，通道硬件就控制转去执行另一个通道程序，控制另一台设备传送信息</li><li>主要连接以字节为单位的低速I/O设备。如打印机，终端。   以字节为单位交叉传输，当一台传送一个字节后，立即转去为另一台传送字节</li></ul></li><li><p>选择通道</p><ul><li>选择通道是以成组方式工作的，即每次传送一批数据，故传送速度很高。选择通道在一段时间内只能执行一个通道程序，只允许一台设备进行数据传输</li><li>当这台设备数据传输完成后，再选择与通道连接的另一台设备，执行它的相应的通道程序</li><li>主要连接磁盘，磁带等高速I/O设备</li></ul></li><li><p>成组多路通道</p><ul><li>它结合了选择通道传送速度高和字节多路通道能进行分时并行操作的优点。它先为一台设备执行一条通道指令，然后自动转接，为另一台设备执行一条通道指令</li><li>主要连接高速设备</li></ul></li></ol><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>为了使CPU从I/O事务中解脱出来，同时为了提高CPU与设备，设备与设备之间的并行工作能力</p><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h3 id="概念-13"><a href="#概念-13" class="headerlink" title="概念"></a>概念</h3><ol><li>文件系统是操作系统中负责管理和存取文件信息的软件机构，它是由管理文件所需的数据结构和相应的管理软件以及访问文件的一组操作组成。</li><li>从系统的角度看：文件系统是一个负责文件存储空间管理的机构。</li><li>从用户的角度看：文件系统是用户在计算机上存储信息、和使用信息的接口。</li></ol><h3 id="功能-2"><a href="#功能-2" class="headerlink" title="功能"></a>功能</h3><ol><li>提供用户对文件操作的命令；</li><li>提供用户共享文件的机制；</li><li>管理文件的存储介质；</li><li>提供文件的存取控制的机制，保障文件及文件系统的安全性；</li><li>提供文件及文件系统的备份和恢复功能；</li><li>提供对文件的加密和解密功能。</li></ol><h3 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h3><h4 id="概念-14"><a href="#概念-14" class="headerlink" title="概念"></a>概念</h4><ol><li>文件目录也被称为文件说明或文件控制块（File Control Block，FCB）即文件名址录。它是一张记录所有文件名及其存放地址、文件的说明和控制信息的表格。</li><li>一般情况下，每个文件占用一个表目，即每个文件有一个文件的目录项。</li></ol><h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><ol><li>文件名</li><li>文件的大小，单位：字节</li><li>文件在物理存储介质中的位置。<ul><li>取决于文件的物理结构 。对于连续文件：文件起始块号（即文件的第一个物理块块号）；对于串联文件：指向第一个物理块的指针；对于索引文件：索引表。</li></ul></li><li>存取控制信息<ul><li>文件主和其它用户对该文件的访问权限。</li></ul></li><li>管理信息<ul><li>包含文件创建的日期和时间，最近修改该文件的日期和时间等。</li></ul></li><li>文件的类型</li></ol><h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><ul><li>实现“按名存取”。 </li><li>提高对目录的检索速度。 </li><li>文件共享。 </li><li>允许文件重名。 </li></ul><h3 id="文件逻辑结构"><a href="#文件逻辑结构" class="headerlink" title="文件逻辑结构"></a>文件逻辑结构</h3><ol><li>无结构文件－－流式文件<ul><li>无结构的流式文件是相关的有序字符的集合。文件的长度为所含字符数。</li><li>UNIX、DOS、WINDOWS系统中的普通文件都是流式文件。</li></ul></li><li>结构文件－－记录式文件<ul><li>结构文件是记录的集合。 每个记录由彼此相关的域构成。记录可按顺序编号。</li><li>如果文件中所有记录的长度都相同，则这种文件为定长记录文件。</li><li>定长记录文件的长度 = 记录个数x记录长度。</li><li>变长记录文件的长度为各记录长度之和。</li></ul></li></ol><h3 id="文件物理结构"><a href="#文件物理结构" class="headerlink" title="文件物理结构"></a>文件物理结构</h3><h4 id="连续文件"><a href="#连续文件" class="headerlink" title="连续文件"></a>连续文件</h4><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220105154033.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220105154033.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220105154028523" style="zoom:50%;" /><h4 id="串联文件"><a href="#串联文件" class="headerlink" title="串联文件"></a>串联文件</h4><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220105154107.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220105154107.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220105154103983" style="zoom:50%;" /><ol><li><p>一个串联文件结构是按顺序由串联的块组成的，即文件的信息按存储介质的物理特性存于若干块中。每个物理块的最末一个字(或第一个字)作为链接字，它指出后继块的物理地址。链首指针存放在该文件目录中。文件的结尾块的指针为“∧”。</p></li><li><p>这种文件结构不要求连续存放。</p></li><li><p>对于记录式文件一块中可包含一个逻辑记录或多个逻辑记录，也可以若干物理块包含一个逻辑记录。</p></li><li><p>优点：</p><ol><li>存储空间利用率高；</li><li>文件创建时用户不必指出文件的大小；</li><li>文件动态扩充和修改容易。</li><li>顺序存取效率高。</li></ol></li><li><p>缺点：<br>1.随机存取效率太低，如果访问文件的最后内容，实际上是要访问整个文件。<br>2.指针域需额外占用空间；<br>3.指针与数据同时存放，破坏了物理块的完整性。</p></li></ol><h4 id="随机文件"><a href="#随机文件" class="headerlink" title="随机文件"></a>随机文件</h4><h5 id="直接地址结构"><a href="#直接地址结构" class="headerlink" title="直接地址结构"></a>直接地址结构</h5><ol><li>定义：<pre><code> 直接通过某一给定的记录地址，直接对记录存取。</code></pre></li><li>优点：<pre><code> 存储效率高，不需要进行任何查找；</code></pre></li><li>缺点：<pre><code> 知道记录所在地址较困难。</code></pre></li></ol><h5 id="索引文件结构"><a href="#索引文件结构" class="headerlink" title="索引文件结构"></a>索引文件结构</h5><ol><li>这种文件结构的数据结构是文件的索引表，每个文件有一个索引表，表中每个表目包括：逻辑块号，物理块号。</li><li>索引表位置：文件目录中，文件的开头等。</li><li>索引表大小:固定大小，非固定大小。</li><li>索引文件占两个区：<ul><li>索引区：存放索引表；</li><li>数据区：用于存放数据文件本身。</li></ul></li><li>访问索引文件<ul><li>查文件索引，由逻辑块号查得物理块号；</li><li>访问该物理块获得所需信息。</li></ul></li><li>优点：<ul><li>可直接读写记录；</li><li>便于文件的增删。</li></ul></li><li>缺点：<ul><li>增加了索引表的空间开销及查找时间。</li></ul></li></ol><h5 id="计算寻址结构"><a href="#计算寻址结构" class="headerlink" title="计算寻址结构"></a>计算寻址结构</h5><ol><li>直接地址</li><li>一次间接地址</li><li>多次间接地址</li></ol><h4 id="散列文件文件（HASH文件）"><a href="#散列文件文件（HASH文件）" class="headerlink" title="散列文件文件（HASH文件）"></a>散列文件文件（HASH文件）</h4><ol><li><p>HASH法是一种杂凑法，亦称散列法。</p></li><li><p>它是一种构造和查找符号表的常用技术，其基本思想是利用一个简单宜于实现的变换函数（HASH函数），把每个符号名唯一的变换成表中的表目位置.即：a=H(k)</p></li><li><p>其中，H为HASH函数，k为关键字（符号名），a为k在符号表中相应的表目位置，a又称HASH值，对于任一符号名，通过HASH变换直接得到a,比线性查找法大大加快了平均检索速度.</p></li><li><p>散列算法的基本思想：关键字   计算   记录地址；</p></li><li><p>需解决的问题：</p><ul><li>寻一HASH函数实现转换；</li><li>确定解决冲突的方法。</li></ul></li><li><p>常用的散列算法有：</p><ul><li>截段法：截取关键字的一部分作为地址；</li><li>特征性抽取法：抽取关键码字段的某些位并联结起来作为地址；</li><li>除余法：把关键字除以某一数而取其余数作为地址；</li><li>折叠法：把关键字数码串分段，然后叠加起来作为地址；</li><li>平方取中法：把关键字平方后取其结果的中间部分作为地址。</li></ul></li></ol><h4 id="文件物理结构的比较"><a href="#文件物理结构的比较" class="headerlink" title="文件物理结构的比较"></a>文件物理结构的比较</h4><ol><li><p>连续文件的优点是不需要额外的空间开销，只要在文件目录中指出文件的大小和首块的块号即可，对顺序的访问效率很高。适应于顺序存取。缺点是动态地增长和缩小系统开销很大；文件创建时要求用户提供文件的大小；存储空间浪费较大。</p></li><li><p>串联文件克服了连续文件的不足之处，但文件的随机访问系统开销较大。适应于顺序访问的文件。DOS系统中改造了串联文件的结构，使其克服了串联文件的不足，但增加了系统的危险性。</p></li><li><p>索引文件既适应于顺序存访问，也适应于随机访问，是一种比较 好的文件物理结构，但要有用于索引表的空间开销和文件索引的时间开销。UNIX系统是使用索引结构成功的例子。</p></li></ol><h3 id="文件存储空间的管理"><a href="#文件存储空间的管理" class="headerlink" title="文件存储空间的管理"></a>文件存储空间的管理</h3><p>策略：</p><ul><li>空闲文件项</li><li>空闲文件目录，</li><li>空闲块链，</li><li>位示图</li></ul><h3 id="文件共享与文件保护"><a href="#文件共享与文件保护" class="headerlink" title="文件共享与文件保护"></a>文件共享与文件保护</h3><ol><li>文件共享：是指某一个或某一部分文件可以让事先规定的某些用户共同使用。</li><li>为了实现文件共享，系统还必须提供文件保护的能力，即提供保证文件安全性的措施。</li><li>为了保证文件的安全性，一个文件保护系统应具有四个方面的内容：<ul><li>被保护的目标；</li><li>被允许的文件存取类型；</li><li>标识能独立地存取某一文件的用户；</li><li>实现文件保护的过程，即存取权限的验证。</li></ul></li></ol><h4 id="文件共享的五种方式"><a href="#文件共享的五种方式" class="headerlink" title="文件共享的五种方式"></a>文件共享的五种方式</h4><ol><li>绕道法</li><li>采用“链接技术”实现文件共享</li><li>基本文件目录</li><li>利用符号链实现文件共享 </li><li>基于索引节点的共享方式 </li></ol><h4 id="文件保护的六种方式"><a href="#文件保护的六种方式" class="headerlink" title="文件保护的六种方式"></a>文件保护的六种方式</h4><ol><li>访问控制矩阵</li><li>存取控制表</li><li>用户权限表</li><li>隐藏文件目录</li><li>口令</li><li>密码</li></ol><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p>为方便用户使用文件，文件系统提供对文件的各种操作，形式分别为：</p><ol><li><p>系统调用或命令</p></li><li><p>提供设置和修改用户文件的存取权限的服务</p></li><li><p>提供建立、修改、改变、删除目录的服务</p></li><li><p>提供文件共享，设置访问路径的服务</p></li><li><p>提供创建、打开、读、写、关闭、撤消文件等服务</p></li><li><p>文件系统维护</p></li><li><p>文件系统的转储和恢复</p></li></ol><blockquote><p>最基本的操作是：打开、关闭、读、写文件等</p></blockquote><h4 id="建立文件"><a href="#建立文件" class="headerlink" title="建立文件"></a>建立文件</h4><ol><li><p>实质：</p><ul><li>建立文件的FCB，并建立必要的存储空间，分配空FCB，根据提供的参数及需要填写有关内容，返回一个文件描述</li></ul></li><li><p>目的：建立系统与文件的联系</p></li><li><p>过程:</p><ul><li>检查参数合法性</li><li>检查同一目录下有无重名文件</li><li>在文件目录结构中的适当位置建立一个文件控制块FCB。</li><li>将参数填入FCB。</li><li>分配文件所存放的外存空间（也可lazy分配即在写数据时分配），建立索引表，填入FCB中。 </li></ul></li></ol><h4 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h4><ol><li>任何一个文件使用前都要先打开，即把FCB送到内存，以建立用户和文件的联系，使今后频繁的查目录操作在内存中完成。如fd=open(文件路径名, 打开方式)</li><li>打开文件操作的主要执行步骤如下：<ul><li>根据文件路径名查目录，找到FCB主部；</li><li>根据打开方式、共享说明和用户身份检查访问合法性；</li><li>根据文件号查系统打开文件表，看文件是否已被打开；若是→共享计数加1,  否则→将外存中的FCB主部等信息填入系统打开文件表空表项，共享计数置为1；</li><li>在用户打开文件表中取一空表项，填写打开方式等，并指向系统打开文件表对应表项</li><li>返回信息：fd：文件描述符，是一个非负整数，用于以后读写文件</li></ul></li></ol><h4 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h4><ol><li>用户要求读文件信息时就调用本操作，系统允许用户对已经调用过“打开”操作的文件进行渎。</li><li>调用“读”操作时，用户应提供如下参数：用户名、文件名、主存地址、存取方式、记录号或记录键、长度。</li><li>文件系统完成“读”操作的主要工作是：<ul><li>核对该用户是否已“打开”指定的文件，</li><li>核对存取方式是否合理；</li><li>若采用的是顺序存取方式，则从当前位置读一块或几块信息到指定的主存地址中，且把后继信息存放位置作为新的当前位置i</li><li>若采用的是随机存取方式，则按给定的记录号或记录控查索引表，得到记录存放地址后读出该记录。</li></ul></li></ol><h4 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h4><ol><li>用户要求保存文件信息时就调用本操作，系统允许用户对已经调用过“建立”操作的文件执行写。</li><li>调用“写”操作时用户提供的参数与“读”操作的参数相同。</li><li>文件系统完成“写”操作的主要工作是：<ul><li>核对用户文件是否已“建立”，若否，则请用户先调用“建立”操作；</li><li>寻找空闲的存储空间，按已确定的存储结构把主存中的文件信息写到所找出的存储块中；</li><li>对采用索引结构的文件须登记索引项。</li></ul></li></ol><h4 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h4><ol><li>经过“打开”或“建立”的文件，用户在读写完毕后，需要调用“关闭”操作归还文件的使用权。</li><li>用户只能关闭自己打开或建立的文件。</li><li>调用“关闭”操作时应给出参数：用户名、文件名。</li><li>文件系统执行“关闭”操作的主要工作如下：<ul><li>检查是否是文件打开者或建立者请求关闭。若否，则拒绝关闭。</li><li>谈到主存储器中的文件目录或索引表是否被修改过，若是，则把它们重新保存到存储介质上。</li><li>清除文件已“打开”。</li></ul></li></ol><h4 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h4><ol><li>用户调用“删除”操作可请求文件系统删除一个保存在磁盘或磁带上的文件。</li><li>调用该操作时提供的参数为：用户名、文件名、存储设备类型。</li><li>文件系统执行“删除”操作的主要工作是：<ul><li>在指定的设备上让用户装上含有该文件的存储介质；</li><li>检查文件是否已关闭，若否，则请先调用“关闭”操作；</li><li>在文件目录中删除该文件的目录项；</li><li>收回该文件占用的存储空间。</li></ul></li></ol><h4 id="文件的使用"><a href="#文件的使用" class="headerlink" title="文件的使用"></a>文件的使用</h4><ol><li>为了保证文件系统对文件的正确管理，用户使用文件时应遵循一定的步骤。为避免一个共享文件(多个用户都可使用的文件)被几个用户同时使用而造成的混乱，规定使用文件前先调用“打开”。一个文件打开后，在它被关闭之前不允许非打开者使用。</li><li>一个文件被“打开”或“建立”后，允许打开者或建立者多次调用“读”操作或“写”操作来使用该文件。文件使用结束后必须调用“关闭”操作来归还文件的使用权。一个被关闭后的文件不能再使用。若要再使用，则必须再次调用“打开”操作。</li><li>用户的文件交系统管理后，为保证文件的安全可靠，用户使用文件的操作步骤应遵循如下步骤：<br>（一）读文件：“打开”文件；“读”文件(可多次调用)；“关闭”文件<br>（二）写文件：“建立”文件；“写”文件(可多次调用)；“关闭”文件<br>（三）删除文件：关闭文件；删除文件</li><li>有的系统为了方便用户，还提供了一种隐式使用文件的方法，用户可以不必调用“打开”、“建立”和“关闭”文件的操作，而是直接调用“读”文件或“写”文件的操作。但是对文件系统来说，要先检查用户请求读或写的文件是否已经打开或建立，若否，则文件系统仍需先做好“打开”或“建立”的工作。如果用户使用了一个A文件后又要使用B文件，则文件系统先关闭A文件，再打开或建立B文件，然后对B文件执行读或写操作。 </li></ol><h3 id="文件转存备份方式"><a href="#文件转存备份方式" class="headerlink" title="文件转存备份方式"></a>文件转存备份方式</h3><ol><li>全量转储：把文件存储器中的所有文件定期复制到磁带上</li><li>增量转储：定期把所有修改过的文件和新文件转储到磁带上</li></ol><h3 id="位示图"><a href="#位示图" class="headerlink" title="位示图"></a>位示图</h3><ol><li>位示图是外存空间的存储映射图。</li><li>位示图是系统在内存中划分出的若干字节的集合，用来指示磁盘存储情况。位示图中的每一位（bit）对应外存空间的一个物理块。<ul><li>若该位为“1”，表示对应块被占用；</li><li>若该位为“0”，表示对应物理块空闲。</li></ul></li><li>位示图的大小由其对应的文件存储设备的容量决定，当一个盘组的分块确定后，根据划分的总块数决定位示图由多少字节组成。</li></ol><p>在实际应用时，应根据磁盘的结构确定位示图的构造，以及每个柱面上的块数和每个磁道上的扇区数，列出相应的换算公式。确定空闲块地址的通用公式为：</p><ul><li><p>块号 = 字号x字长 ＋ 位号</p></li><li><p>柱面号 = [块号/柱面上的块数]</p></li><li><p>磁头号 = [(块号mod柱面上的块数)／磁道上的扇区数]</p></li><li><p>扇区号＝(块号mod柱面上的块数) mod磁道上的扇区数</p></li></ul><p>归还一块时，寻找位示图中位置的通用公式为：</p><ul><li>块号＝柱面号×柱面上块数＋磁头号×磁道上扇区数＋扇区号</li><li>字号＝[块号/字长]</li><li>位号＝块号mod字长</li></ul><h2 id="计算题"><a href="#计算题" class="headerlink" title="计算题"></a>计算题</h2><h3 id="位示图-1"><a href="#位示图-1" class="headerlink" title="位示图"></a>位示图</h3><p>例4：磁盘有80个柱面，20个磁道/柱面，6块/磁道，1KB/块。位示图共有20张，60字/张。给出申请或归还公式。<br>假设：<br>       磁盘                    位示图：<br>  柱面号i：(0～79)          张x： （0～20）<br>  磁头号j：(0～19)          字y： （0～59）<br>  块号k： (0～5)            位z： （0～15）<br>申请一块：已知x，y，z，转换为i，j，k<br>归还一块：已知i，j，k ，转换为x，y，z</p><p>解：60字/张，16位/字⇒60×16＝960位/字<br>20个磁道，6块/磁道，故20×6＝120块/柱面<br>分配：一张位示图 960/120＝8个柱面<br>设w为某一张位示图的第w位。则w＝16×y＋z<br>则柱面号：i＝8×x＋w/120=(960×x＋16×y＋z）/120<br>磁头号：j＝（w％120）/6<br>块号：k＝（ w％120）％6<br>归还：已知i，j，k；求x，y，z<br>x ＝ i/8<br>y = ( i%8<em>120+6</em>j+k ) / 16<br>z = ( i%8<em>120+6</em>j+k ) % 16</p><h3 id="页式地址变换"><a href="#页式地址变换" class="headerlink" title="页式地址变换"></a>页式地址变换</h3><p>在请求分页系统中，某用户的编程空间为16个页面，每页1K，分配的内存空间为8K。假定某时刻该用户的页表如下图所示，试问：</p><img src="https://img-blog.csdnimg.cn/20191219155804660.png" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/20191219155804660.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述" style="zoom: 80%;" /><p>（1）逻辑地址084B（H）对应的物理地址是多少？（用十六进制表示）<br>（2）逻辑地址5000（十进制）对应的物理地址是多少？（用十进制表示）<br>（3）当该用户进程欲访问24A0H单元时，会出现什么现象？</p><p>084BH = 0000 1000 0100 1011<br>0000 10 00 0100 1011<br>0001 00 00 0100 1011 0x104B</p><p>5000 = 0001 0011 1000 1000<br>0001 00 11 1000 1000<br>0011 00 11 1000 1000 13192</p><p>24A0 = 0010 0100 1010 0000<br>0010 01 00 1010 0000<br>页号为9，页表中不存在，发生缺页中断</p><p><img src="https://img-blog.csdnimg.cn/20191219155831316.png" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/20191219155831316.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述"></p><p>(3)答： 24A0（H）的页号为9，而其页面当前不在内存，所以会发一个缺页中断，请求系统调页。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="期末" scheme="http://xucoud.github.io/categories/%E6%9C%9F%E6%9C%AB/"/>
    
    <category term="操作系统" scheme="http://xucoud.github.io/categories/%E6%9C%9F%E6%9C%AB/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="期末" scheme="http://xucoud.github.io/tags/%E6%9C%9F%E6%9C%AB/"/>
    
  </entry>
  
  <entry>
    <title>java期末</title>
    <link href="http://xucoud.github.io/2022/01/26/Java%E6%9C%9F%E6%9C%AB/"/>
    <id>http://xucoud.github.io/2022/01/26/Java%E6%9C%9F%E6%9C%AB/</id>
    <published>2022-01-26T06:44:09.115Z</published>
    <updated>2022-01-04T11:46:41.966Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><span id="more"></span><h2 id="Java的特性"><a href="#Java的特性" class="headerlink" title="Java的特性"></a>Java的特性</h2><h3 id="简单性"><a href="#简单性" class="headerlink" title="简单性"></a>简单性</h3><p>Java看起来设计得很像<a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/C++">C++</a>，但是为了使语言小和容易熟悉，设计者们把C++语言中许多可用的特征去掉了，这些特征是一般程序员很少使用的。例如，Java不支持go to语句，代之以提供<a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/break/405784">break</a>和<a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/continue/3009735">continue</a>语句以及异常处理。Java还剔除了C++的操作符过载（<a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/overload">overload</a>）和多继承特征，并且不使用主文件，免去了预处理程序。因为Java没有结构，数组和串都是对象，所以不需要指针。Java能够自动处理对象的引用和间接引用，实现自动的无用单元收集，使用户不必为存储管理问题烦恼，能更多的时间和精力花在研发上。</p><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>Java是一个面向对象的语言。对程序员来说，这意味着要注意应中的数据和操纵数据的方法（method），而不是严格地用过程来思考。在一个面向对象的系统中，类（<a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/class/12502737">class</a>）是数据和操作数据的方法的集合。数据和方法一起描述对象（object）的状态和行为。每一对象是其状态和行为的封装。类是按一定体系和层次安排的，使得子类可以从超类继承行为。在这个类层次体系中有一个根类，它是具有一般行为的类。Java程序是用类来组织的。</p><p>Java还包括一个类的扩展集合，分别组成各种程序包（<a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/Package">Package</a>），用户可以在自己的程序中使用。例如，Java提供产生图形用户接口部件的类（<a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/java.awt">java.awt</a>包），这里awt是抽象窗口工具集（abstract windowing toolkit）的缩写，处理输入输出的类（<a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/java.io">java.io</a>包）和支持网络功能的类（<a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/java.net">java.net</a>包）。</p><h3 id="分布性"><a href="#分布性" class="headerlink" title="分布性"></a>分布性</h3><p>Java设计成支持在网络上应用，它是分布式语言。Java既支持各种层次的网络连接，又以Socket类支持可靠的流（<a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/stream">stream</a>）网络连接，所以用户可以产生分布式的客户机和服务器。</p><p>网络变成软件应用的分布运载工具。Java程序只要编写一次，就可到处运行。</p><h3 id="编译和解释性"><a href="#编译和解释性" class="headerlink" title="编译和解释性"></a>编译和解释性</h3><p>Java编译程序生成字节码（byte-code），而不是通常的机器码。Java字节码提供对体系结构中性的目标文件格式，代码设计成可有效地传送程序到多个平台。Java程序可以在任何实现了Java解释程序和运行系统（run-time system）的系统上运行。</p><p>在一个解释性的环境中，程序开发的标准“链接”阶段大大消失了。如果说Java还有一个链接阶段，它只是把新类装进环境的过程，它是增量式的、<a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/%E8%BD%BB%E9%87%8F%E7%BA%A7/10002835">轻量级</a>的过程。因此，Java支持快速原型和容易试验，它将导致快速程序开发。这是一个与传统的、耗时的“编译、链接和测试”形成鲜明对比的精巧的开发过程。</p><h3 id="稳健性"><a href="#稳健性" class="headerlink" title="稳健性"></a>稳健性</h3><p>Java原来是用作编写消费类家用电子产品软件的语言，所以它是被设计成写高可靠和稳健软件的。Java消除了某些编程错误，使得用它写可靠软件相当容易。</p><p>Java是一个强类型语言，它允许扩展编译时检查潜在类型不匹配问题的功能。Java要求显式的方法声明，它不支持C风格的<a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/%E9%9A%90%E5%BC%8F%E5%A3%B0%E6%98%8E">隐式声明</a>。这些严格的要求保证编译程序能捕捉调用错误，这就导致更可靠的程序。</p><p>可靠性方面最重要的增强之一是Java的存储模型。Java不支持指针，它消除重写存储和<a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/%E8%AE%B9%E8%AF%AF">讹误</a>数据的可能性。类似地，Java自动的“无用单元收集”预防存储漏泄和其它有关动态存储分配和解除分配的有害错误。Java解释程序也执行许多运行时的检查，诸如验证所有数组和串访问是否在界限之内。</p><p>异常处理是Java中使得程序更稳健的另一个特征。异常是某种类似于错误的异常条件出现的信号。使用try/catch/finally语句，程序员可以找到出错的处理代码，这就简化了出错处理和恢复的任务。</p><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>Java的存储分配模型是它防御<a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81">恶意代码</a>的主要方法之一。Java没有指针，所以程序员不能得到隐蔽起来的内幕和伪造指针去指向<a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E5%99%A8">存储器</a>。更重要的是，Java编译程序不处理存储安排决策，所以程序员不能通过查看<a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/%E5%A3%B0%E6%98%8E/13130358">声明</a>去猜测类的实际存储安排。编译的Java代码中的存储引用在运行时由Java解释程序决定实际存储地址。</p><p>Java运行系统使用字节码验证过程来保证装载到网络上的代码不违背任何Java语言限制。这个安全机制部分包括类如何从网上装载。例如，装载的类是放在分开的名字空间而不是局部类，预防恶意的小应用程序用它自己的版本来代替标准Java类。</p><h3 id="可移植性"><a href="#可移植性" class="headerlink" title="可移植性"></a>可移植性</h3><p>Java使得语言声明不依赖于实现的方面。例如，Java显式说明每个基本数据类型的大小和它的运算行为（这些数据类型由Java语法描述）。</p><p>Java环境本身对新的硬件平台和操作系统是可移植的。Java编译程序也用Java编写，而Java运行系统用ANSIC语言编写。</p><h3 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h3><p>Java是一种先编译后解释的语言，所以它不如全编译性语言快。但是有些情况下性能是很要紧的，为了支持这些情况，Java设计者制作了“及时”编译程序，它能在运行时把Java字节码翻译成特定<a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/CPU">CPU</a>（中央处理器）的机器代码，也就是实现全编译了。</p><p>Java字节码格式设计时考虑到这些“及时”编译程序的需要，所以生成机器代码的过程相当简单，它能产生相当好的代码。</p><h3 id="多线索性"><a href="#多线索性" class="headerlink" title="多线索性"></a>多线索性</h3><p>Java是多线索语言，它提供支持多线索的执行（也称为轻便过程），能处理不同任务，使具有线索的程序设计很容易。Java的lang包提供一个<a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/Thread/5156974">Thread</a>类，它支持开始线索、运行线索、停止线索和检查线索状态的方法。</p><p>Java的线索支持也包括一组同步原语。这些原语是基于监督程序和条件变量风范，由C.A.R.Haore开发的广泛使用的同步化方案。用关键词<a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/synchronized">synchronized</a>，程序员可以说明某些方法在一个类中不能并发地运行。这些方法在监督程序控制之下，确保变量维持在一个一致的状态。</p><h3 id="动态性"><a href="#动态性" class="headerlink" title="动态性"></a>动态性</h3><p>Java语言设计成适应于变化的环境，它是一个动态的语言。例如，Java中的类是根据需要载入的，甚至有些是通过网络获取的。</p><h2 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h2><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><p>JVM(Java Virtual Machine)是Java虚拟机，JVM负责解释执行字节码文件。使用Java编译器编译生成的与平台无关的字节码文件，这些字节码文件不面向任何具体的平台，只面向JVM。不同平台上的JVM都是不同的，但它们都提供了相同的接口，只要为不同平台实现了相应的虚拟机，编译后的Java字节码就可以在该平台上运行。JVM像是一个中间转换器，将生成的字节码文件在虚拟机中运行，而虚拟机则在不同平台上运行，从而实现Java程序的跨平台。</p><h3 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h3><p>每个程序员都遇到过内存溢出的情况，程序运行时，内存空间是有限的，那么如何及时的把不再使用的对象清除将内存释放出来，这就是GC要做的事。</p><h4 id="需要GC的内存区域"><a href="#需要GC的内存区域" class="headerlink" title="需要GC的内存区域"></a>需要GC的内存区域</h4><p>jvm 中，程序计数器、虚拟机栈、本地方法栈都是随线程而生随线程而灭，栈帧随着方法的进入和退出做入栈和出栈操作，实现了自动的内存清理，因此，我们的内存垃圾回收主要集中于 java 堆和方法区中，在程序运行期间，这部分内存的分配和使用都是动态的。</p><h4 id="GC的对象"><a href="#GC的对象" class="headerlink" title="GC的对象"></a>GC的对象</h4><p>需要进行回收的对象就是已经没有存活的对象，判断一个对象是否存活常用的有两种办法：引用计数和可达分析。</p><p>（1）引用计数：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。</p><p>（2）可达性分析（Reachability Analysis）：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。不可达对象。</p><h4 id="什么时候触发GC"><a href="#什么时候触发GC" class="headerlink" title="什么时候触发GC"></a>什么时候触发GC</h4><p>(1)程序调用System.gc时可以触发</p><p>(2)系统自身来决定GC触发的时机（根据Eden区和From Space区的内存大小来决定。当内存大小不足时，则会启动GC线程并停止应用线程）</p><h4 id="GC做了什么事"><a href="#GC做了什么事" class="headerlink" title="GC做了什么事"></a>GC做了什么事</h4><p> 主要做了清理对象，整理内存的工作。Java堆分为新生代和老年代，采用了不同的回收方式。</p><h4 id="GC常用算法"><a href="#GC常用算法" class="headerlink" title="GC常用算法"></a>GC常用算法</h4><p>GC常用算法有：<strong>标记-清除算法</strong>，<strong>标记-压缩算法</strong>，<strong>复制算法</strong>，<strong>分代收集算法。</strong></p><p>目前主流的JVM（HotSpot）采用的是分代收集算法。</p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20211229214157.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20211229214157.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20211229214148420"></p><h3 id="标识符、关键字的概念及区别"><a href="#标识符、关键字的概念及区别" class="headerlink" title="标识符、关键字的概念及区别"></a>标识符、关键字的概念及区别</h3><ul><li><p>字母、下划线、$开头的字母、下划线、$、数字的组合</p></li><li><p>区分大小写</p></li><li><p>标识符需避免与关键字冲突</p></li></ul><h3 id="常量的概念及分类"><a href="#常量的概念及分类" class="headerlink" title="常量的概念及分类"></a>常量的概念及分类</h3><p> <img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20211229221244.jpg" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20211229221244.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><h3 id="变量的概念及分类"><a href="#变量的概念及分类" class="headerlink" title="变量的概念及分类"></a>变量的概念及分类</h3><p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20211229221254.jpg" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20211229221254.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20211229221256.jpg" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20211229221256.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><ul><li>基本数据类型（掌握分类、理解类型转换）</li></ul><p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20211229221306.jpg" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20211229221306.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><ul><li><p>引用数据类型（理解内存，结合第 3 章）</p></li><li><p>运算符、表达式、语句、方法、程序结构（同 C 语言，略）</p></li></ul><h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><h3 id="面向对象的设计思想"><a href="#面向对象的设计思想" class="headerlink" title="面向对象的设计思想"></a>面向对象的设计思想</h3><ul><li>封装</li><li>多态</li></ul><h3 id="类与类之间的关系"><a href="#类与类之间的关系" class="headerlink" title="类与类之间的关系"></a>类与类之间的关系</h3><ul><li>继承</li><li>聚集</li><li>实现</li></ul><h3 id="了解命名规则"><a href="#了解命名规则" class="headerlink" title="了解命名规则"></a>了解命名规则</h3><p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20211229221311.jpg" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20211229221311.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><h3 id="理解关键字-this-和-super-的用法"><a href="#理解关键字-this-和-super-的用法" class="headerlink" title="理解关键字 this 和 super 的用法"></a>理解关键字 this 和 super 的用法</h3><ul><li></li></ul><p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20211229220118.jpg" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20211229220118.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><ul><li>使用 super 访问基类成员</li></ul><h3 id="理解关键字-static-的用法"><a href="#理解关键字-static-的用法" class="headerlink" title="理解关键字 static 的用法"></a>理解关键字 static 的用法</h3><p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20211229220158.jpg" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20211229220158.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><h3 id="掌握方法重写的语法规则"><a href="#掌握方法重写的语法规则" class="headerlink" title="掌握方法重写的语法规则"></a>掌握方法重写的语法规则</h3><p> <img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20211229220229.jpg" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20211229220229.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><h3 id="权限控制和类的继承"><a href="#权限控制和类的继承" class="headerlink" title="权限控制和类的继承"></a>权限控制和类的继承</h3><ul><li>掌握类的成员的访问权限</li></ul><p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20211229220251.jpg" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20211229220251.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><ul><li><p>派生类的声明</p></li><li><p>派生类的构造方法</p></li></ul><p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20211229220304.jpg" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20211229220304.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><h3 id="理解-Object-类"><a href="#理解-Object-类" class="headerlink" title="理解 Object 类"></a>理解 Object 类</h3><p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20211229220321.jpg" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20211229220321.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><h3 id="理解对象转型"><a href="#理解对象转型" class="headerlink" title="理解对象转型"></a>理解对象转型</h3><p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20211229220336.jpg" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20211229220336.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><h3 id="理解并掌握动态绑定和多态"><a href="#理解并掌握动态绑定和多态" class="headerlink" title="理解并掌握动态绑定和多态"></a>理解并掌握动态绑定和多态</h3><ul><li><p>要有继承</p></li><li><p>要有重写</p></li><li><p>基类引用指向派生类对象</p></li></ul><h3 id="理解-final-关键字"><a href="#理解-final-关键字" class="headerlink" title="理解 final 关键字"></a>理解 final 关键字</h3><p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20211229220404.gif" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20211229220404.gif" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><p> <img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20211229220410.jpg" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20211229220410.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="掌握异常的概念及分类"><a href="#掌握异常的概念及分类" class="headerlink" title="掌握异常的概念及分类"></a>掌握异常的概念及分类</h3><p> <img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20211229220442.gif" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20211229220442.gif" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20211229220456.jpg" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20211229220456.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><h3 id="掌握异常处理中的常用关键字及其含义"><a href="#掌握异常处理中的常用关键字及其含义" class="headerlink" title="掌握异常处理中的常用关键字及其含义"></a>掌握异常处理中的常用关键字及其含义</h3><ul><li><p>try：里面是可能出现异常的语句或者代码块。后面可以跟一个或多个 catch 代码段。出现异常，终止 try 代码段的执行，根据错误的类型找到对应的 catch 执行；</p></li><li><p>catch：捕获异常，进行相应处理；</p></li><li><p>finally：无论是否产生异常都会执行。一般用于资源的清除工作，比如 io 流的关闭，jdbc 的驱动关闭。</p></li><li><p>throws：用于方法声明时抛出异常；</p></li><li><p>throw：用于实际手动抛出异常。</p></li></ul><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h3><ul><li><p>声明</p></li><li><p>初始化（默认值）</p></li></ul><p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20211229220530.jpg" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20211229220530.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><ul><li><p>对象创建</p></li><li><p>数组元素的引用（数组属性 length）</p></li></ul><h3 id="二维数组（掌握）"><a href="#二维数组（掌握）" class="headerlink" title="二维数组（掌握）"></a>二维数组（掌握）</h3><ul><li>声明和初始化</li></ul><p> <img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20211229220553.jpg" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20211229220553.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20211229220602.jpg" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20211229220602.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><ul><li><p>对象创建</p></li><li><p>数组元素的引用（数组属性 length）</p></li></ul><h3 id="数组的拷贝（了解）"><a href="#数组的拷贝（了解）" class="headerlink" title="数组的拷贝（了解）"></a>数组的拷贝（了解）</h3><p> <img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20211229220617.jpg" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20211229220617.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><ul><li>String 是不可变的，而 StringBuffer 和 StringBuilder 是可变类。</li><li>StringBuffer 是线程安全和同步的，而 StringBuilder 不是。这就是 StringBuilder 比 StringBuffer 快的原因。</li><li>字符串连接运算符 (+) 在内部使用 StringBuilder 类。</li><li>对于非多线程环境中的字符串操作，我们应该使用 StringBuilder 否则使用 StringBuffer 类。</li></ul><h2 id="容器类"><a href="#容器类" class="headerlink" title="容器类"></a>容器类</h2><h3 id="理解容器类的派生体系"><a href="#理解容器类的派生体系" class="headerlink" title="理解容器类的派生体系"></a>理解容器类的派生体系</h3><p> <img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20211229220746.jpg" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20211229220746.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><h3 id="Collection-接口"><a href="#Collection-接口" class="headerlink" title="Collection 接口"></a>Collection 接口</h3><ul><li><p>理解 iterator、equals、hashCode 方法</p></li><li><p>理解并掌握 iterator 方法和 Iterator 接口的用法</p></li></ul><h3 id="for-foreach"><a href="#for-foreach" class="headerlink" title="for, foreach"></a>for, foreach</h3><ul><li><p>在循环操作ArrayList的时候，使用for和foreach速度差不多，for稍微快一点。实际<strong>操作ArrayList使用过程中建议使用for循环</strong>，因为for循环采用下标访问，对于数组结构的数据来说，采用下标访问比较好。</p></li><li><p>在循环操作LinkedList的时候，使用for和foreach速度差非常多。所以<strong>在操作LinkedList的时候，一定要使用foreach循环</strong>。如果使用for循环，数据量大的时候有可能会导致系统崩溃。</p></li><li><p>foreach适用于只是进行集合或数组遍历，for则在较复杂的循环中效率更高。</p></li><li><p>foreach不能对数组或集合进行修改（添加删除操作），如果想要修改就要用for循环。</p></li></ul><h3 id="List、Set、Map"><a href="#List、Set、Map" class="headerlink" title="List、Set、Map"></a>List、Set、Map</h3><ul><li>list 和set 有共同的父类 它们的用法也是一样的 唯一的不太就是set中不能有相同的元素 list中可以</li><li>list和set的用途非常广泛 list可以完全代替数组来使用</li><li>map 是独立的合集 它使用键值对的方式来储存数据 键不能有重复的 值可以用</li><li>map不像上边两种集合那个用的广泛 不过在servlet 和jsp中 map可是绝对的重中之重 页面之间传值全靠map</li></ul><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><ol><li><p>可以允许重复的对象。</p></li><li><p>可以插入多个null元素。</p></li><li><p>是一个有序容器，保持了每个元素的插入顺序，输出的顺序就是插入的顺序。</p></li><li><p>常用的实现类有 ArrayList、LinkedList 和 Vector。ArrayList 最为流行，它提供了使用索引的随意访问，而 LinkedList 则对于经常需要从 List 中添加或删除元素的场合更为合适。</p></li></ol><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><ol><li><p>不允许重复对象</p><p>　　   2. 无序容器，你无法保证每个元素的存储顺序，TreeSet通过 Comparator  或者 Comparable 维护了一个排序顺序。</p><pre><code>       　　   3. 只允许一个 null 元素                 　　   4. Set 接口最流行的几个实现类是 HashSet、LinkedHashSet 以及 TreeSet。最流行的是基于 HashMap 实现的 HashSet；TreeSet 还实现了 SortedSet 接口，因此 TreeSet 是一个根据其 compare() 和 compareTo() 的定义进行排序的有序容器。</code></pre></li></ol><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><ol><li><p>Map不是collection的子接口或者实现类。Map是一个接口。</p></li><li><p>Map 的 每个 Entry 都持有两个对象，也就是一个键一个值，Map 可能会持有相同的值对象但键对象必须是唯一的。</p></li><li><p>TreeMap 也通过 Comparator  或者 Comparable 维护了一个排序顺序。</p></li><li><p>Map 里你可以拥有随意个 null 值但最多只能有一个 null 键。</p></li><li><p>Map 接口最流行的几个实现类是 HashMap、LinkedHashMap、Hashtable 和 TreeMap。（HashMap、TreeMap最常用）</p></li></ol><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><ul><li><p>理解并掌握泛型的概念及用法</p></li><li><p>能配合迭代器、增强 for 循环遍历 List、Set、Map</p></li></ul><h2 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h2><ul><li>作用：监听某个事件的发生，状态的改变</li><li>内部机制：接口回调</li><li>容器产生的事件分类如下：<br>生命周期相关的事件。 – 如 对象的创建或者销毁等<br>属性状态相关的事件。 – attribute属性的增删改<br>存值状态相关的事件。 – 如 对象和session的绑定和解绑</li></ul><p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20211229221119.gif" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20211229221119.gif" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><h2 id="servlet"><a href="#servlet" class="headerlink" title="servlet"></a>servlet</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>Java Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。</p><p>使用 Servlet，您可以收集来自网页表单的用户输入，呈现来自数据库或者其他源的记录，还可以动态创建网页。</p><p>Java Servlet 通常情况下与使用 CGI（Common Gateway Interface，公共网关接口）实现的程序可以达到异曲同工的效果。但是相比于 CGI，Servlet 有以下几点优势：</p><ul><li>性能明显更好。</li><li>Servlet 在 Web 服务器的地址空间内执行。这样它就没有必要再创建一个单独的进程来处理每个客户端请求。</li><li>Servlet 是独立于平台的，因为它们是用 Java 编写的。</li><li>服务器上的 Java 安全管理器执行了一系列限制，以保护服务器计算机上的资源。因此，Servlet 是可信的。</li><li>Java 类库的全部功能对 Servlet 来说都是可用的。它可以通过 sockets 和 RMI 机制与 applets、数据库或其他软件进行交互.</li></ul><h3 id="web-xml配置"><a href="#web-xml配置" class="headerlink" title="web.xml配置"></a>web.xml配置</h3><ul><li><web-app></li><li><p><display-name> : 标注了该web项目的名字</p></li><li><p><welcome-list-file> : 定义了首页文件，也就是用户直接输入域名时跳转的页面</p></li><li><p><servlet> : 用来声明一个servlet的数据，主要有以下子元素：</p><ul><li><p><strong><servlet-name></strong><br>指定servlet的名称</p></li><li><p><strong><servlet-class></strong><br>指定servlet的类名称</p></li><li><p><strong><jsp-file></strong><br>指定web站台中的某个JSP网页的完整路径</p></li><li><p><strong><init-param></strong><br>用来定义初始化参数，可有多个<code>init-param</code>。在servlet类中通过<code>ServletConfig</code>对象传入init函数，通过- getInitParamenter(String name)方法访问初始化参数。例如使用<init-param>来初始化数据库连接参数。</p></li><li><load-on-startup>指定当Web应用启动时，装载Servlet的次序。当值为正数或零时：Servlet容器先加载数值小的servlet，再依次加载其他数值大的servlet。当值为负或未定义：Servlet容器将在Web客户首次访问这个servlet时加载它。</li><li><servlet-mapping>用来定义servlet所对应的URL，包含两个子元素。需要特别注意的是</servlet-mapping>元素，这个元素规定了一个servlet-name和url-pattern，如果请求的url能够匹配该url-pattern，则使用servlet-name指定的servlet处理该请求。</li><li><servlet-name>指定servlet的名称</li><li><url-pattern>指定servlet所对应的URL</li></ul></li><li><filter>过滤器元素将一个名字与一个实现javax.servlet.Filter接口的类相关联。</li><li><listener>Listener元素指出事件监听程序类</li><li><session-config>配置会话超时，单位是分钟</li><li><error-page><p>在返回特定HTTP状态代码时，或者特定类型的异常被抛出时，能够制定将要显示的页面。</p></li></ul><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>Servlet 生命周期可被定义为从创建直到毁灭的整个过程。以下是 Servlet 遵循的过程：</p><ul><li>Servlet 初始化后调用 <strong>init ()</strong> 方法。</li><li>Servlet 调用 <strong>service()</strong> 方法来处理客户端的请求。</li><li>Servlet 销毁前调用 <strong>destroy()</strong> 方法。</li><li>最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。</li></ul><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>MVC 模式表示模型 - 视图 - 控制器模式。</p><p>从名称我们可以看到，MVC模式涉及三个部分:</p><ul><li><p><strong>Model（模型）</strong>- 模型表示携带数据的对象。它也可以具有逻辑来更新控制器，如果其数据改变。</p></li><li><p><strong>View（视图）</strong>- 视图表示模型包含的数据的可视化。通常它有UI逻辑。</p></li><li><p><strong>Controller（控制器）</strong> - 控制器引用模型和视图。它控制数据流进入模型对象，并在数据更改时更新视图。它保持视图和模型分开。</p><p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20211229225232.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20211229225232.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20211229225231208"></p></li></ul><p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20211229225827.jpg" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20211229225827.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Inkedimage-20211229225542323"></p><h2 id="http-协议"><a href="#http-协议" class="headerlink" title="http 协议"></a>http 协议</h2><h3 id="http-请求响应机制"><a href="#http-请求响应机制" class="headerlink" title="http 请求响应机制"></a>http 请求响应机制</h3><ol><li>建立连接：客户端与服务器建立TCP连接 </li><li>发送请求：打开一个连接后，客户端把请求信息发送到服务器的相应端口上，完成请求动作提交。 </li><li>发送响应：服务器在处理完客户端请求之后，要向客户端发送响应消息。 </li><li>关闭连接：客户端和服务器端都可以关闭套接字来结束TCP/IP对话。 </li></ol><h3 id="HTTP-无状态性"><a href="#HTTP-无状态性" class="headerlink" title="HTTP 无状态性"></a>HTTP 无状态性</h3><p>​        HTTP 协议是无状态的(stateless)。也就是说，同一个客户端第二次访问同一个服务器上的页面时，服务器无法知道这个客户端曾经访问过，服务器也无法分辨不同的客户端。HTTP 的无状态特性简化了服务器的设计，使服务器更容易支持大量并发的HTTP 请求。</p><h3 id="掌握常用的-http-请求头和-http-响应头"><a href="#掌握常用的-http-请求头和-http-响应头" class="headerlink" title="掌握常用的 http 请求头和 http 响应头"></a>掌握常用的 http 请求头和 http 响应头</h3><h4 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a><strong>请求头</strong></h4><p>当你使用http(https)协议请求一个网站的时候，你的浏览器会向对方的服务器发送一个http请求，这个请求同样包含三个部分</p><ul><li><p>请求方法 请求路径（URL） 请求协议版本</p></li><li><ul><li>例：GET <a href="https://link.zhihu.com/?target=https://www.google.com.hk/">https://www.google.com.hk/</a> HTTP/1.1</li></ul></li><li><p>报文主体</p></li><li><p>（POST/GET）参数</p></li></ul><p><strong>响应头</strong></p><p>当你向对方发送请求后，对方会回应你浏览器的请求，返回两个部分：响应头，Body</p><blockquote><p> 注：Body就是返回给你的主体，比如说请求网站返回的html</p></blockquote><p>响应头讯息里包含了服务器的响应讯息，如http版本，压缩方式，响应文件类型，文件编码等</p><h3 id="常见的响应码（状态码）"><a href="#常见的响应码（状态码）" class="headerlink" title="常见的响应码（状态码）"></a>常见的响应码（状态码）</h3><p>200 - 服务器成功返回网页</p><p>302  （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</p><p>304  （未修改）自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。</p><p>307  （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</p><p>404 - 请求的网页不存在</p><p>500  （服务器内部错误） 服务器遇到错误，无法完成请求。</p><p>503 - 服务不可用</p><h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><h3 id="JDBC-的开发步骤"><a href="#JDBC-的开发步骤" class="headerlink" title="JDBC 的开发步骤"></a>JDBC 的开发步骤</h3><ol><li>注册驱动程序</li><li>建立连接</li><li>建立Statement</li><li>执行查询</li><li>关闭连接</li></ol><h3 id="Statement-与-PreparedStatement-的区别"><a href="#Statement-与-PreparedStatement-的区别" class="headerlink" title="Statement 与 PreparedStatement 的区别"></a>Statement 与 PreparedStatement 的区别</h3><p>关系：PreparedStatement继承自Statement,都是接口<br>区别：PreparedStatement可以使用<a href="https://so.csdn.net/so/search?q=%E5%8D%A0%E4%BD%8D%E7%AC%A6">占位符</a>，是预编译的，批处理比Statement效率高  </p><h3 id="掌握防止-SQL-注入漏洞的常用方法"><a href="#掌握防止-SQL-注入漏洞的常用方法" class="headerlink" title="掌握防止 SQL 注入漏洞的常用方法"></a>掌握防止 SQL 注入漏洞的常用方法</h3><ul><li><p>PreparedStatement 代替 Statement</p></li><li><p>密码加密</p></li></ul><h2 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h2><p>JSP全称Java Server Pages，是一种动态网页开发技术。它使用JSP标签在HTML网页中插入Java代码。标签通常以&lt;%开头以%&gt;结束。</p><p>JSP是一种Java servlet，主要用于实现Java web应用程序的用户界面部分。网页开发者们通过结合HTML代码、XHTML代码、XML元素以及嵌入JSP操作和命令来编写JSP。</p><p>JSP通过网页表单获取用户输入数据、访问数据库及其他数据源，然后动态地创建网页。</p><p>JSP标签有多种功能，比如访问数据库、记录用户选择信息、访问JavaBeans组件等，还可以在不同的网页中传递控制信息和共享信息。</p><h3 id="标签元素"><a href="#标签元素" class="headerlink" title="标签元素"></a>标签元素</h3><table><thead><tr><th align="left">语法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">jsp:include</td><td align="left">在页面被请求的时候引入一个文件。</td></tr><tr><td align="left">jsp:useBean</td><td align="left">寻找或者实例化一个JavaBean。</td></tr><tr><td align="left">jsp:setProperty</td><td align="left">设置JavaBean的属性。</td></tr><tr><td align="left">jsp:getProperty</td><td align="left">输出某个JavaBean的属性。</td></tr><tr><td align="left">jsp:forward</td><td align="left">把请求转到一个新的页面。</td></tr><tr><td align="left">jsp:plugin</td><td align="left">根据浏览器类型为Java插件生成OBJECT或EMBED标记。</td></tr><tr><td align="left">jsp:element</td><td align="left">定义动态XML元素</td></tr><tr><td align="left">jsp:attribute</td><td align="left">设置动态定义的XML元素属性。</td></tr><tr><td align="left">jsp:body</td><td align="left">设置动态定义的XML元素内容。</td></tr><tr><td align="left">jsp:text</td><td align="left">在JSP页面和文档中使用写入文本的模板</td></tr></tbody></table><h3 id="常见的属性"><a href="#常见的属性" class="headerlink" title="常见的属性"></a>常见的属性</h3><p>所有的动作要素都有两个属性：id属性和scope属性。</p><ul><li><p>id属性：</p><p>id属性是动作元素的唯一标识，可以在JSP页面中引用。动作元素创建的id值可以通过PageContext来调用。</p></li><li><p>scope属性：</p><p>该属性用于识别动作元素的生命周期。 id属性和scope属性有直接关系，scope属性定义了相关联id对象的寿命。 scope属性有四个可能的值： (a) page, (b)request, (c)session, 和 (d) application。</p></li></ul><h2 id="Servlet实例"><a href="#Servlet实例" class="headerlink" title="Servlet实例"></a>Servlet实例</h2><p>web.xml:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">xmlns</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee </span></span></span><br><span class="line"><span class="string"><span class="tag">                         http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">id</span>=<span class="string">&quot;WebApp_ID&quot;</span> <span class="attr">version</span>=<span class="string">&quot;3.0&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Demos<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">description</span>&gt;</span>This is the description of my J2EE component<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>This is the display name of my J2EE component<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>FirstServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.demos.servlet.FirstServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>FirstServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/servlet/FirstServlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>IndexServlet.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demos.servlet;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">304496806747823900L</span>;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">              <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">          response.setContentType(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">          PrintWriter out = response.getWriter();</span><br><span class="line">          out.println(<span class="string">&quot;&lt;!DOCTYPE HTML PUBLIC \&quot;-//W3C//DTD HTML 4.01 Transitional//EN\&quot;&gt;&quot;</span>);</span><br><span class="line">          out.println(<span class="string">&quot;&lt;HTML&gt;&quot;</span>);</span><br><span class="line">          out.println(<span class="string">&quot;  &lt;HEAD&gt;&lt;TITLE&gt;A Servlet&lt;/TITLE&gt;&lt;/HEAD&gt;&quot;</span>);</span><br><span class="line">          out.println(<span class="string">&quot;  &lt;BODY&gt;&quot;</span>);</span><br><span class="line">          out.print(<span class="string">&quot;    This is &quot;</span>);</span><br><span class="line">          out.print(<span class="keyword">this</span>.getClass());</span><br><span class="line">          out.println(<span class="string">&quot;, using the GET method&quot;</span>);</span><br><span class="line">          out.println(<span class="string">&quot;  &lt;/BODY&gt;&quot;</span>);</span><br><span class="line">          out.println(<span class="string">&quot;&lt;/HTML&gt;&quot;</span>);</span><br><span class="line">          out.flush();</span><br><span class="line">          out.close();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">              <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">          response.setContentType(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">          PrintWriter out = response.getWriter();</span><br><span class="line">          out.println(<span class="string">&quot;&lt;!DOCTYPE HTML PUBLIC \&quot;-//W3C//DTD HTML 4.01 Transitional//EN\&quot;&gt;&quot;</span>);</span><br><span class="line">          out.println(<span class="string">&quot;&lt;HTML&gt;&quot;</span>);</span><br><span class="line">          out.println(<span class="string">&quot;  &lt;HEAD&gt;&lt;TITLE&gt;A Servlet&lt;/TITLE&gt;&lt;/HEAD&gt;&quot;</span>);</span><br><span class="line">          out.println(<span class="string">&quot;  &lt;BODY&gt;&quot;</span>);</span><br><span class="line">          out.print(<span class="string">&quot;    This is &quot;</span>);</span><br><span class="line">          out.print(<span class="keyword">this</span>.getClass());</span><br><span class="line">          out.println(<span class="string">&quot;, using the POST method&quot;</span>);</span><br><span class="line">          out.println(<span class="string">&quot;  &lt;/BODY&gt;&quot;</span>);</span><br><span class="line">          out.println(<span class="string">&quot;&lt;/HTML&gt;&quot;</span>);</span><br><span class="line">          out.flush();</span><br><span class="line">          out.close();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">          <span class="comment">// Put your code here</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>index.jsp</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span>%&gt;</span><br><span class="line">&lt;title&gt;QIMITY&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form action=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/login&quot;</span>&gt;</span><br><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;user&quot;</span>/&gt;</span><br><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;password&quot;</span>/&gt;</span><br><span class="line">&lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;登录&quot;</span>/&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="期末" scheme="http://xucoud.github.io/categories/%E6%9C%9F%E6%9C%AB/"/>
    
    <category term="JAVA" scheme="http://xucoud.github.io/categories/%E6%9C%9F%E6%9C%AB/JAVA/"/>
    
    
    <category term="期末" scheme="http://xucoud.github.io/tags/%E6%9C%9F%E6%9C%AB/"/>
    
  </entry>
  
  <entry>
    <title>GORM</title>
    <link href="http://xucoud.github.io/2021/10/26/GORM/"/>
    <id>http://xucoud.github.io/2021/10/26/GORM/</id>
    <published>2021-10-26T15:03:14.000Z</published>
    <updated>2022-01-04T11:46:11.193Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>GORM框架在Go中的简单运用</p><span id="more"></span><p>​        在实际的开发过程中，经常会需要对数据库进行操作。在Go语言中，它自带了一个<code>database/sql</code>的标准库，结合数据库的驱动包，我们就可以对数据库进行操作了。不过，他们都属相对偏底层的软件包，需要自己手动写<code>sql</code>语句。在实际的开发过程中，我们通常会使用一些在此基础上封装好的<code>ORM</code>库，在这里我们会简单介绍一下<code>GORM</code>在Go程序中的使用方法。</p><h2 id="安装GORM包"><a href="#安装GORM包" class="headerlink" title="安装GORM包"></a>安装GORM包</h2><p><code>gorm</code> 是一个出色的，对开发人员友好的 <code>Golang ORM</code> 库，其支持的特性包括：</p><ul><li><p>全特性 ORM (几乎包含所有特性)</p></li><li><p>模型关联 (一对一， 一对多，一对多（反向）， 多对多， 多态关联)</p></li><li><p>钩子 (Before/After Create/Save/Update/Delete/Find)</p></li><li><p>预加载</p></li><li><p>事务</p></li><li><p>复合主键</p></li><li><p>SQL 构造器</p></li><li><p>自动迁移</p></li><li><p>日志</p></li></ul><p>使用如下命令进行安装：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> get -u github.com/jinzhu/gorm</span><br></pre></td></tr></table></figure><h2 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h2><p>连接不同的数据库都需要导入对应数据的驱动程序，<code>GORM</code>已经贴心的为我们包装了一些驱动程序，只需要导入需要的数据库驱动即可。</p><h3 id="连接MySQL"><a href="#连接MySQL" class="headerlink" title="连接MySQL"></a>连接MySQL</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;github.com/jinzhu/gorm&quot;</span></span><br><span class="line">  _ <span class="string">&quot;github.com/jinzhu/gorm/dialects/mysql&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  db, err := gorm.Open(<span class="string">&quot;mysql&quot;</span>, <span class="string">&quot;user:password@(localhost)/dbname?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span>)</span><br><span class="line">  <span class="keyword">defer</span> db.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="连接PostgreSQL"><a href="#连接PostgreSQL" class="headerlink" title="连接PostgreSQL"></a>连接PostgreSQL</h3><p>基本代码同上，注意引入对应<code>postgres</code>驱动并正确指定<code>gorm.Open()</code>参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;github.com/jinzhu/gorm&quot;</span></span><br><span class="line">  _ <span class="string">&quot;github.com/jinzhu/gorm/dialects/postgres&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  db, err := gorm.Open(<span class="string">&quot;postgres&quot;</span>, <span class="string">&quot;host=myhost port=myport user=gorm dbname=gorm password=mypassword&quot;</span>)</span><br><span class="line">  <span class="keyword">defer</span> db.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="连接Sqlite3"><a href="#连接Sqlite3" class="headerlink" title="连接Sqlite3"></a>连接Sqlite3</h3><p>基本代码同上，注意引入对应<code>sqlite</code>驱动并正确指定<code>gorm.Open()</code>参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;github.com/jinzhu/gorm&quot;</span></span><br><span class="line">  _ <span class="string">&quot;github.com/jinzhu/gorm/dialects/sqlite&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  db, err := gorm.Open(<span class="string">&quot;sqlite3&quot;</span>, <span class="string">&quot;/tmp/gorm.db&quot;</span>)</span><br><span class="line">  <span class="keyword">defer</span> db.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="连接SQL-Server"><a href="#连接SQL-Server" class="headerlink" title="连接SQL Server"></a>连接SQL Server</h3><p>基本代码同上，注意引入对应<code>mssql</code>驱动并正确指定<code>gorm.Open()</code>参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;github.com/jinzhu/gorm&quot;</span></span><br><span class="line">  _ <span class="string">&quot;github.com/jinzhu/gorm/dialects/mssql&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  db, err := gorm.Open(<span class="string">&quot;mssql&quot;</span>, <span class="string">&quot;sqlserver://username:password@localhost:1433?database=dbname&quot;</span>)</span><br><span class="line">  <span class="keyword">defer</span> db.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="GORM-Model"><a href="#GORM-Model" class="headerlink" title="GORM Model"></a>GORM Model</h2><p>​        在使用ORM工具时，通常我们需要在代码中定义模型（Models）与数据库中的数据表进行映射，在GORM中模型（Models）通常是正常定义的结构体、基本的go类型或它们的指针。 同时也支持<code>sql.Scanner</code>及<code>driver.Valuer</code>接口（interfaces）。</p><h3 id="模型定义"><a href="#模型定义" class="headerlink" title="模型定义"></a>模型定义</h3><p>​        模型是标准的 <code>struct</code>，由 <code>Go</code> 的基本数据类型、实现了<code>Scanner</code>和 <code>Valuer</code>接口的自定义类型及其指针或别名组成。</p><p>​        为了方便模型定义，<code>GORM</code>内置了一个<code>gorm.Model</code>结构体。<code>gorm.Model</code>是一个包含了<code>ID</code>, <code>CreatedAt</code>, <code>UpdatedAt</code>, <code>DeletedAt</code>四个字段的<code>Golang</code>结构体。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gorm.Model 定义</span></span><br><span class="line"><span class="keyword">type</span> Model <span class="keyword">struct</span> &#123;</span><br><span class="line">ID        <span class="keyword">uint</span> <span class="string">`gorm:&quot;primary_key&quot;`</span></span><br><span class="line">CreatedAt time.Time</span><br><span class="line">UpdatedAt time.Time</span><br><span class="line">DeletedAt *time.Time <span class="string">`sql:&quot;index&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以将它嵌入到你自己的模型中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 `ID`, `CreatedAt`, `UpdatedAt`, `DeletedAt`字段注入到`User`模型中</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相当于：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID        <span class="keyword">uint</span> <span class="string">`gorm:&quot;primary_key&quot;`</span></span><br><span class="line">  CreatedAt time.Time</span><br><span class="line">  UpdatedAt time.Time</span><br><span class="line">  DeletedAt *time.Time <span class="string">`sql:&quot;index&quot;`</span></span><br><span class="line">  Name      <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然你也可以完全自己定义模型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不使用gorm.Model，自行定义模型</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID   <span class="keyword">int</span></span><br><span class="line">  Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  Name         <span class="keyword">string</span></span><br><span class="line">  Age          sql.NullInt64</span><br><span class="line">  Birthday     *time.Time</span><br><span class="line">  Email        <span class="keyword">string</span>  <span class="string">`gorm:&quot;type:varchar(100);unique_index&quot;`</span></span><br><span class="line">  Role         <span class="keyword">string</span>  <span class="string">`gorm:&quot;size:255&quot;`</span> <span class="comment">// 设置字段大小为255</span></span><br><span class="line">  MemberNumber *<span class="keyword">string</span> <span class="string">`gorm:&quot;unique;not null&quot;`</span> <span class="comment">// 设置会员号（member number）唯一并且不为空</span></span><br><span class="line">  Num          <span class="keyword">int</span>     <span class="string">`gorm:&quot;AUTO_INCREMENT&quot;`</span> <span class="comment">// 设置 num 为自增类型</span></span><br><span class="line">  Address      <span class="keyword">string</span>  <span class="string">`gorm:&quot;index:addr&quot;`</span> <span class="comment">// 给address字段创建名为addr的索引</span></span><br><span class="line">  IgnoreMe     <span class="keyword">int</span>     <span class="string">`gorm:&quot;-&quot;`</span> <span class="comment">// 忽略本字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结构体标记（tags）"><a href="#结构体标记（tags）" class="headerlink" title="结构体标记（tags）"></a>结构体标记（tags）</h3><p>使用结构体声明模型时，标记（tags）是可选项。<code>gorm</code>支持以下标记:</p><h4 id="支持的结构体标记（Struct-tags）"><a href="#支持的结构体标记（Struct-tags）" class="headerlink" title="支持的结构体标记（Struct tags）"></a>支持的结构体标记（Struct tags）</h4><table><thead><tr><th align="center">结构体标记（Tag）</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">Column</td><td align="center">指定列名</td></tr><tr><td align="center">Type</td><td align="center">指定列数据类型</td></tr><tr><td align="center">Size</td><td align="center">指定列大小, 默认值255</td></tr><tr><td align="center">PRIMARY_KEY</td><td align="center">将列指定为主键</td></tr><tr><td align="center">UNIQUE</td><td align="center">将列指定为唯一</td></tr><tr><td align="center">DEFAULT</td><td align="center">指定列默认值</td></tr><tr><td align="center">PRECISION</td><td align="center">指定列精度</td></tr><tr><td align="center">NOT NULL</td><td align="center">将列指定为非 NULL</td></tr><tr><td align="center">AUTO_INCREMENT</td><td align="center">指定列是否为自增类型</td></tr><tr><td align="center">INDEX</td><td align="center">创建具有或不带名称的索引, 如果多个索引同名则创建复合索引</td></tr><tr><td align="center">UNIQUE_INDEX</td><td align="center">和 <code>INDEX</code> 类似，只不过创建的是唯一索引</td></tr><tr><td align="center">EMBEDDED</td><td align="center">将结构设置为嵌入</td></tr><tr><td align="center">EMBEDDED_PREFIX</td><td align="center">设置嵌入结构的前缀</td></tr><tr><td align="center">-</td><td align="center">忽略此字段</td></tr></tbody></table><h4 id="关联相关标记（tags）"><a href="#关联相关标记（tags）" class="headerlink" title="关联相关标记（tags）"></a>关联相关标记（tags）</h4><table><thead><tr><th align="center">结构体标记（Tag）</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">MANY2MANY</td><td align="center">指定连接表</td></tr><tr><td align="center">FOREIGNKEY</td><td align="center">设置外键</td></tr><tr><td align="center">ASSOCIATION_FOREIGNKEY</td><td align="center">设置关联外键</td></tr><tr><td align="center">POLYMORPHIC</td><td align="center">指定多态类型</td></tr><tr><td align="center">POLYMORPHIC_VALUE</td><td align="center">指定多态值</td></tr><tr><td align="center">JOINTABLE_FOREIGNKEY</td><td align="center">指定连接表的外键</td></tr><tr><td align="center">ASSOCIATION_JOINTABLE_FOREIGNKEY</td><td align="center">指定连接表的关联外键</td></tr><tr><td align="center">SAVE_ASSOCIATIONS</td><td align="center">是否自动完成 save 的相关操作</td></tr><tr><td align="center">ASSOCIATION_AUTOUPDATE</td><td align="center">是否自动完成 update 的相关操作</td></tr><tr><td align="center">ASSOCIATION_AUTOCREATE</td><td align="center">是否自动完成 create 的相关操作</td></tr><tr><td align="center">ASSOCIATION_SAVE_REFERENCE</td><td align="center">是否自动完成引用的 save 的相关操作</td></tr><tr><td align="center">PRELOAD</td><td align="center">是否自动完成预加载的相关操作</td></tr></tbody></table><h3 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h3><p>​        可导出的字段在使用 <code>GORM</code> 进行 <code>CRUD</code> 时拥有全部的权限，此外，<code>GORM</code> 允许您用标签控制字段级别的权限。这样您就可以让一个字段的权限是只读、只写、只创建、只更新或者被忽略。</p><blockquote><p><strong>注意：</strong> 使用 GORM Migrator 创建表时，不会创建被忽略的字段</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name <span class="keyword">string</span> <span class="string">`gorm:&quot;&lt;-:create&quot;`</span> <span class="comment">// 允许读和创建</span></span><br><span class="line">  Name <span class="keyword">string</span> <span class="string">`gorm:&quot;&lt;-:update&quot;`</span> <span class="comment">// 允许读和更新</span></span><br><span class="line">  Name <span class="keyword">string</span> <span class="string">`gorm:&quot;&lt;-&quot;`</span>        <span class="comment">// 允许读和写（创建和更新）</span></span><br><span class="line">  Name <span class="keyword">string</span> <span class="string">`gorm:&quot;&lt;-:false&quot;`</span>  <span class="comment">// 允许读，禁止写</span></span><br><span class="line">  Name <span class="keyword">string</span> <span class="string">`gorm:&quot;-&gt;&quot;`</span>        <span class="comment">// 只读（除非有自定义配置，否则禁止写）</span></span><br><span class="line">  Name <span class="keyword">string</span> <span class="string">`gorm:&quot;-&gt;;&lt;-:create&quot;`</span> <span class="comment">// 允许读和写</span></span><br><span class="line">  Name <span class="keyword">string</span> <span class="string">`gorm:&quot;-&gt;:false;&lt;-:create&quot;`</span> <span class="comment">// 仅创建（禁止从 db 读）</span></span><br><span class="line">  Name <span class="keyword">string</span> <span class="string">`gorm:&quot;-&quot;`</span>         <span class="comment">// 通过 struct 读写会忽略该字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建-更新时间追踪（纳秒、毫秒、秒、Time）"><a href="#创建-更新时间追踪（纳秒、毫秒、秒、Time）" class="headerlink" title="创建/更新时间追踪（纳秒、毫秒、秒、Time）"></a>创建/更新时间追踪（纳秒、毫秒、秒、Time）</h3><p>​        <code>GORM</code> 约定使用 <code>CreatedAt</code>、<code>UpdatedAt</code> 追踪创建/更新时间。如果您定义了这种字段，<code>GORM</code> 在创建、更新时会自动填充当前时间。</p><p>​        要使用不同名称的字段，您可以配置 <code>autoCreateTime</code>、<code>autoUpdateTime</code> 标签。</p><p>​        如果您想要保存 UNIX（毫/纳）秒时间戳，而不是 time，您只需简单地将 <code>time.Time</code> 修改为 <code>int</code> 即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  CreatedAt time.Time <span class="comment">// 在创建时，如果该字段值为零值，则使用当前时间填充</span></span><br><span class="line">  UpdatedAt <span class="keyword">int</span>       <span class="comment">// 在创建时该字段值为零值或者在更新时，使用当前时间戳秒数填充</span></span><br><span class="line">  Updated   <span class="keyword">int64</span> <span class="string">`gorm:&quot;autoUpdateTime:nano&quot;`</span> <span class="comment">// 使用时间戳填纳秒数充更新时间</span></span><br><span class="line">  Updated   <span class="keyword">int64</span> <span class="string">`gorm:&quot;autoUpdateTime:milli&quot;`</span> <span class="comment">// 使用时间戳毫秒数填充更新时间</span></span><br><span class="line">  Created   <span class="keyword">int64</span> <span class="string">`gorm:&quot;autoCreateTime&quot;`</span>      <span class="comment">// 使用时间戳秒数填充创建时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="嵌入结构体"><a href="#嵌入结构体" class="headerlink" title="嵌入结构体"></a>嵌入结构体</h3><p>对于匿名字段，GORM 会将其字段包含在父结构体中，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等效于</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID        <span class="keyword">uint</span>           <span class="string">`gorm:&quot;primaryKey&quot;`</span></span><br><span class="line">  CreatedAt time.Time</span><br><span class="line">  UpdatedAt time.Time</span><br><span class="line">  DeletedAt gorm.DeletedAt <span class="string">`gorm:&quot;index&quot;`</span></span><br><span class="line">  Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于正常的结构体字段，你也可以通过标签 <code>embedded</code> 将其嵌入，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Author <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name  <span class="keyword">string</span></span><br><span class="line">    Email <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Blog <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID      <span class="keyword">int</span></span><br><span class="line">  Author  Author <span class="string">`gorm:&quot;embedded&quot;`</span></span><br><span class="line">  Upvotes <span class="keyword">int32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等效于</span></span><br><span class="line"><span class="keyword">type</span> Blog <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID    <span class="keyword">int64</span></span><br><span class="line">  Name  <span class="keyword">string</span></span><br><span class="line">  Email <span class="keyword">string</span></span><br><span class="line">  Upvotes  <span class="keyword">int32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且，您可以使用标签 <code>embeddedPrefix</code> 来为 <code>db</code> 中的字段名添加前缀，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Blog <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID      <span class="keyword">int</span></span><br><span class="line">  Author  Author <span class="string">`gorm:&quot;embedded;embeddedPrefix:author_&quot;`</span></span><br><span class="line">  Upvotes <span class="keyword">int32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等效于</span></span><br><span class="line"><span class="keyword">type</span> Blog <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID          <span class="keyword">int64</span></span><br><span class="line">    AuthorName  <span class="keyword">string</span></span><br><span class="line">    AuthorEmail <span class="keyword">string</span></span><br><span class="line">  Upvotes     <span class="keyword">int32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h2><p>​        我们可以自己手动添加数据库表，也可以使用<code>GORM</code>来自动生成数据库表。我们可以事先定义好要生成数据库表的结构体，可以使用tag对字段进行一些属性的设置，参照上面的结构体相关标记。</p><p>生成数据库有两种方式：</p><ul><li><code>AutoMigrate()</code>：自动迁移数据库表。它可以根据结构体的字段自动生成数据库表，默认表名为结构体的复数，这个可以通过<code>db.SingularTable(true)</code>来禁用复数表名。默认字段名会将结构体中属性的大写改为小写，两个单词之间通过<code>_</code>来连接，这个可以通过<code>tag</code>来为字段设置名称。</li><li><code>db.Table(&quot;user&quot;).CreateTable(&amp;User&#123;&#125;)</code>：创建数据库表。通过<code>Table</code>来设置表名，<code>CreateTable</code>来指定要生成数据库表的结构体。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义模型</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">gorm.Model   <span class="comment">//内嵌gorm.Model</span></span><br><span class="line">Username     <span class="keyword">string</span></span><br><span class="line">Age          sql.NullInt64</span><br><span class="line">Birthday     *time.Time</span><br><span class="line">Email        <span class="keyword">string</span>  <span class="string">`gorm:&quot;type:varchar(255);unique_index&quot;`</span></span><br><span class="line">Role         <span class="keyword">string</span>  <span class="string">`gorm:&quot;size:255&quot;`</span>        <span class="comment">//设置字段大小为255</span></span><br><span class="line">MemberNumber *<span class="keyword">string</span> <span class="string">`gorm:&quot;unique;not null&quot;`</span> <span class="comment">//会员号唯一且不为空</span></span><br><span class="line">Num          <span class="keyword">int</span>     <span class="string">`gorm:&quot;AUTO_INCREMENT&quot;`</span>  <span class="comment">//自增</span></span><br><span class="line">Address      <span class="keyword">string</span>  <span class="string">`gorm:&quot;index:addr&quot;`</span>      <span class="comment">//给Address字段创建名为addr的索引</span></span><br><span class="line">IgnoreMe     <span class="keyword">int</span>     <span class="string">`gorm:&quot;-&quot;`</span>               <span class="comment">//忽略此字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">db, err := gorm.Open(<span class="string">&quot;mysql&quot;</span>, <span class="string">&quot;root:123456@tcp(1.15.5.24:3306)/gorm?loc=Local&amp;parseTime=true&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;connect mysql fail err =&quot;</span>, err.Error())</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> db.Close()</span><br><span class="line"><span class="comment">//db.SingularTable(true) //禁用复数表名</span></span><br><span class="line"></span><br><span class="line">db.AutoMigrate(&amp;User&#123;&#125;) <span class="comment">//自动迁移数据表,创建表，标名为结构体的复数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//db.Table(&quot;user&quot;).CreateTable(&amp;User&#123;&#125;) //创建一个名为user的表</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="添加记录"><a href="#添加记录" class="headerlink" title="添加记录"></a>添加记录</h2><h3 id="创建记录"><a href="#创建记录" class="headerlink" title="创建记录"></a>创建记录</h3><p>首先定义模型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">ID           <span class="keyword">int64</span></span><br><span class="line">Name         <span class="keyword">string</span></span><br><span class="line">Age          <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用使用<code>NewRecord()</code>查询主键是否存在，主键为空使用<code>Create()</code>创建记录：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">user := User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>, Age: <span class="number">18</span>&#125;</span><br><span class="line"></span><br><span class="line">db.NewRecord(user) <span class="comment">// 主键为空返回`true`</span></span><br><span class="line">db.Create(&amp;user)   <span class="comment">// 创建user</span></span><br><span class="line">db.NewRecord(user) <span class="comment">// 创建`user`后返回`false`</span></span><br></pre></td></tr></table></figure><h3 id="指定插入的字段"><a href="#指定插入的字段" class="headerlink" title="指定插入的字段"></a>指定插入的字段</h3><p>创建记录并更新给出的字段。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.Select(<span class="string">&quot;Name&quot;</span>).Create(&amp;user)</span><br><span class="line"><span class="comment">// INSERT INTO `users` (`name`) VALUES (&quot;jinzhu&quot;)</span></span><br></pre></td></tr></table></figure><p>创建一个记录且一同忽略传递给略去的字段值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.Omit(<span class="string">&quot;Age&quot;</span>, <span class="string">&quot;CreatedAt&quot;</span>).Create(&amp;user)</span><br><span class="line"><span class="comment">// INSERT INTO `users` (`name`) VALUES (&quot;jinzhu&quot;)</span></span><br></pre></td></tr></table></figure><h3 id="批量插入"><a href="#批量插入" class="headerlink" title="批量插入"></a>批量插入</h3><p>​        要有效地插入大量记录，请将一个 <code>slice</code> 传递给 <code>Create</code> 方法。 GORM 将生成单独一条SQL语句来插入所有数据，并回填主键的值，钩子方法也会被调用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> users = []User&#123;&#123;Name: <span class="string">&quot;jinzhu1&quot;</span>&#125;, &#123;Name: <span class="string">&quot;jinzhu2&quot;</span>&#125;, &#123;Name: <span class="string">&quot;jinzhu3&quot;</span>&#125;&#125;</span><br><span class="line">db.Create(&amp;users)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, user := <span class="keyword">range</span> users &#123;</span><br><span class="line">  user.ID <span class="comment">// 1,2,3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>CreateInBatches</code> 分批创建时，你可以指定每批的数量，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> users = []User&#123;&#123;name: <span class="string">&quot;jinzhu_1&quot;</span>&#125;, ...., &#123;Name: <span class="string">&quot;jinzhu_10000&quot;</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数量为 100</span></span><br><span class="line">db.CreateInBatches(users, <span class="number">100</span>)</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong> 使用<code>CreateBatchSize</code> 选项初始化 <code>GORM</code> 时，所有的创建&amp;关联 <code>INSERT</code> 都将遵循该选项</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db := db.Session(&amp;gorm.Session&#123;CreateBatchSize: <span class="number">1000</span>&#125;)</span><br><span class="line"></span><br><span class="line">users = [<span class="number">5000</span>]User&#123;&#123;Name: <span class="string">&quot;jinzhu&quot;</span>, Pets: []Pet&#123;pet1, pet2, pet3&#125;&#125;...&#125;</span><br><span class="line"></span><br><span class="line">db.Create(&amp;users)</span><br><span class="line"><span class="comment">// INSERT INTO users xxx (5 batches)</span></span><br><span class="line"><span class="comment">// INSERT INTO pets xxx (15 batches)</span></span><br></pre></td></tr></table></figure><h3 id="根据-Map-创建"><a href="#根据-Map-创建" class="headerlink" title="根据 Map 创建"></a>根据 Map 创建</h3><p><code>GORM</code> 支持根据 <code>map[string]interface&#123;&#125;</code> 和 <code>[]map[string]interface&#123;&#125;&#123;&#125;</code> 创建记录，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">db.Model(&amp;User&#123;&#125;).Create(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">  <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;jinzhu&quot;</span>, <span class="string">&quot;Age&quot;</span>: <span class="number">18</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// batch insert from `[]map[string]interface&#123;&#125;&#123;&#125;`</span></span><br><span class="line">db.Model(&amp;User&#123;&#125;).Create([]<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">  &#123;<span class="string">&quot;Name&quot;</span>: <span class="string">&quot;jinzhu_1&quot;</span>, <span class="string">&quot;Age&quot;</span>: <span class="number">18</span>&#125;,</span><br><span class="line">  &#123;<span class="string">&quot;Name&quot;</span>: <span class="string">&quot;jinzhu_2&quot;</span>, <span class="string">&quot;Age&quot;</span>: <span class="number">20</span>&#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong> 根据 <code>map</code> 创建记录时，<code>association</code> 不会被调用，且主键也不会自动填充</p></blockquote><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p>可以通过 tag 定义字段的默认值，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID   <span class="keyword">int64</span></span><br><span class="line">  Name <span class="keyword">string</span> <span class="string">`gorm:&quot;default:&#x27;小王子&#x27;&quot;`</span></span><br><span class="line">  Age  <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong>通过<code>tag</code>定义字段的默认值，在创建记录时候生成的 <code>SQL</code> 语句会排除没有值或值为 零值 的字段。 在将记录插入到数据库后，<code>Gorm</code>会从数据库加载那些字段的默认值。</p></blockquote><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user = User&#123;Name: <span class="string">&quot;&quot;</span>, Age: <span class="number">99</span>&#125;</span><br><span class="line">db.Create(&amp;user)</span><br></pre></td></tr></table></figure><p>上面代码实际执行的SQL语句是<code>INSERT INTO users(&quot;age&quot;) values(&#39;99&#39;);</code>，排除了零值字段<code>Name</code>，而在数据库中这一条数据会使用设置的默认值<code>小王子</code>作为Name字段的值。</p><blockquote><p><strong>注意：</strong>所有字段的零值, 比如<code>0</code>, <code>&quot;&quot;</code>,<code>false</code>或者其它<code>零值</code>，都不会保存到数据库内，但会使用他们的默认值。 如果你想避免这种情况，可以考虑使用指针或实现 <code>Scanner/Valuer</code>接口，比如：</p></blockquote><h4 id="使用指针方式实现零值存入数据库"><a href="#使用指针方式实现零值存入数据库" class="headerlink" title="使用指针方式实现零值存入数据库"></a>使用指针方式实现零值存入数据库</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用指针</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID   <span class="keyword">int64</span></span><br><span class="line">  Name *<span class="keyword">string</span> <span class="string">`gorm:&quot;default:&#x27;小王子&#x27;&quot;`</span></span><br><span class="line">  Age  <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line">user := User&#123;Name: <span class="built_in">new</span>(<span class="keyword">string</span>), Age: <span class="number">18</span>))&#125;</span><br><span class="line">db.Create(&amp;user)  <span class="comment">// 此时数据库中该条记录name字段的值就是&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="使用Scanner-Valuer接口方式实现零值存入数据库"><a href="#使用Scanner-Valuer接口方式实现零值存入数据库" class="headerlink" title="使用Scanner/Valuer接口方式实现零值存入数据库"></a>使用Scanner/Valuer接口方式实现零值存入数据库</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 Scanner/Valuer</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">ID <span class="keyword">int64</span></span><br><span class="line">Name sql.NullString <span class="string">`gorm:&quot;default:&#x27;小王子&#x27;&quot;`</span> <span class="comment">// sql.NullString 实现了Scanner/Valuer接口</span></span><br><span class="line">Age  <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line">user := User&#123;Name: sql.NullString&#123;<span class="string">&quot;&quot;</span>, <span class="literal">true</span>&#125;, Age:<span class="number">18</span>&#125;</span><br><span class="line">db.Create(&amp;user)  <span class="comment">// 此时数据库中该条记录name字段的值就是&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="扩展创建选项"><a href="#扩展创建选项" class="headerlink" title="扩展创建选项"></a>扩展创建选项</h3><p>例如<code>PostgreSQL</code>数据库中可以使用下面的方式实现合并插入, 有则更新, 无则插入。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为Instert语句添加扩展SQL选项</span></span><br><span class="line">db.Set(<span class="string">&quot;gorm:insert_option&quot;</span>, <span class="string">&quot;ON CONFLICT&quot;</span>).Create(&amp;product)</span><br><span class="line"><span class="comment">// INSERT INTO products (name, code) VALUES (&quot;name&quot;, &quot;code&quot;) ON CONFLICT;</span></span><br></pre></td></tr></table></figure><h2 id="查询记录"><a href="#查询记录" class="headerlink" title="查询记录"></a>查询记录</h2><h3 id="一般查询"><a href="#一般查询" class="headerlink" title="一般查询"></a>一般查询</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据主键查询第一条记录</span></span><br><span class="line">db.First(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM users ORDER BY id LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机获取一条记录</span></span><br><span class="line">db.Take(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM users LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据主键查询最后一条记录</span></span><br><span class="line">db.Last(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM users ORDER BY id DESC LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询所有的记录</span></span><br><span class="line">db.Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询指定的某条记录(仅当主键为整型时可用)</span></span><br><span class="line">db.First(&amp;user, <span class="number">10</span>)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE id = 10;</span></span><br></pre></td></tr></table></figure><h3 id="Where-条件"><a href="#Where-条件" class="headerlink" title="Where 条件"></a>Where 条件</h3><h4 id="普通SQL查询"><a href="#普通SQL查询" class="headerlink" title="普通SQL查询"></a>普通SQL查询</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get first matched record</span></span><br><span class="line">db.Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).First(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name = &#x27;jinzhu&#x27; limit 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Get all matched records</span></span><br><span class="line">db.Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name = &#x27;jinzhu&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt;&gt;</span></span><br><span class="line">db.Where(<span class="string">&quot;name &lt;&gt; ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name &lt;&gt; &#x27;jinzhu&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IN</span></span><br><span class="line">db.Where(<span class="string">&quot;name IN (?)&quot;</span>, []<span class="keyword">string</span>&#123;<span class="string">&quot;jinzhu&quot;</span>, <span class="string">&quot;jinzhu 2&quot;</span>&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name in (&#x27;jinzhu&#x27;,&#x27;jinzhu 2&#x27;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LIKE</span></span><br><span class="line">db.Where(<span class="string">&quot;name LIKE ?&quot;</span>, <span class="string">&quot;%jin%&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name LIKE &#x27;%jin%&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// AND</span></span><br><span class="line">db.Where(<span class="string">&quot;name = ? AND age &gt;= ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>, <span class="string">&quot;22&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name = &#x27;jinzhu&#x27; AND age &gt;= 22;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Time</span></span><br><span class="line">db.Where(<span class="string">&quot;updated_at &gt; ?&quot;</span>, lastWeek).Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE updated_at &gt; &#x27;2000-01-01 00:00:00&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// BETWEEN</span></span><br><span class="line">db.Where(<span class="string">&quot;created_at BETWEEN ? AND ?&quot;</span>, lastWeek, today).Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE created_at BETWEEN &#x27;2000-01-01 00:00:00&#x27; AND &#x27;2000-01-08 00:00:00&#x27;;</span></span><br></pre></td></tr></table></figure><h4 id="Struct-amp-Map查询"><a href="#Struct-amp-Map查询" class="headerlink" title="Struct &amp; Map查询"></a>Struct &amp; Map查询</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Struct</span></span><br><span class="line">db.Where(&amp;User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>, Age: <span class="number">20</span>&#125;).First(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name = &quot;jinzhu&quot; AND age = 20 LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Map</span></span><br><span class="line"><span class="comment">// 可以进行零值字段查询</span></span><br><span class="line">db.Where(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;jinzhu&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">20</span>&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name = &quot;jinzhu&quot; AND age = 20;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 主键的切片</span></span><br><span class="line">db.Where([]<span class="keyword">int64</span>&#123;<span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE id IN (20, 21, 22);</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>提示：</strong>当通过结构体进行查询时，<code>GORM</code>将会只通过非零值字段查询，这意味着如果你的字段值为<code>0</code>，<code>&#39;&#39;</code>，<code>false</code>或者其他<code>零值</code>时，将不会被用于构建查询条件，例如：</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.Where(&amp;User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>, Age: <span class="number">0</span>&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name = &quot;jinzhu&quot;;</span></span><br></pre></td></tr></table></figure><p>你可以使用指针或实现 <code>Scanner/Valuer</code> 接口来避免这个问题.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用指针</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  Name <span class="keyword">string</span></span><br><span class="line">  Age  *<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Scanner/Valuer</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  Name <span class="keyword">string</span></span><br><span class="line">  Age  sql.NullInt64  <span class="comment">// sql.NullInt64 实现了 Scanner/Valuer 接口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Not-条件"><a href="#Not-条件" class="headerlink" title="Not 条件"></a>Not 条件</h4><p>作用与 <code>Where</code> 类似的情形如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">db.Not(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).First(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name &lt;&gt; &quot;jinzhu&quot; LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Not In</span></span><br><span class="line">db.Not(<span class="string">&quot;name&quot;</span>, []<span class="keyword">string</span>&#123;<span class="string">&quot;jinzhu&quot;</span>, <span class="string">&quot;jinzhu 2&quot;</span>&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name NOT IN (&quot;jinzhu&quot;, &quot;jinzhu 2&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Not In slice of primary keys</span></span><br><span class="line">db.Not([]<span class="keyword">int64</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;).First(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE id NOT IN (1,2,3);</span></span><br><span class="line"></span><br><span class="line">db.Not([]<span class="keyword">int64</span>&#123;&#125;).First(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM users;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Plain SQL</span></span><br><span class="line">db.Not(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).First(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE NOT(name = &quot;jinzhu&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Struct</span></span><br><span class="line">db.Not(User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>&#125;).First(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name &lt;&gt; &quot;jinzhu&quot;;</span></span><br></pre></td></tr></table></figure><h4 id="Or条件"><a href="#Or条件" class="headerlink" title="Or条件"></a>Or条件</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">db.Where(<span class="string">&quot;role = ?&quot;</span>, <span class="string">&quot;admin&quot;</span>).Or(<span class="string">&quot;role = ?&quot;</span>, <span class="string">&quot;super_admin&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE role = &#x27;admin&#x27; OR role = &#x27;super_admin&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Struct</span></span><br><span class="line">db.Where(<span class="string">&quot;name = &#x27;jinzhu&#x27;&quot;</span>).Or(User&#123;Name: <span class="string">&quot;jinzhu 2&quot;</span>&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name = &#x27;jinzhu&#x27; OR name = &#x27;jinzhu 2&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Map</span></span><br><span class="line">db.Where(<span class="string">&quot;name = &#x27;jinzhu&#x27;&quot;</span>).Or(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;jinzhu 2&quot;</span>&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name = &#x27;jinzhu&#x27; OR name = &#x27;jinzhu 2&#x27;;</span></span><br></pre></td></tr></table></figure><h4 id="内联条件"><a href="#内联条件" class="headerlink" title="内联条件"></a>内联条件</h4><p>作用与<code>Where</code>查询类似，当内联条件与多个立即执行方法一起使用时, 内联条件不会传递给后面的立即执行方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据主键获取记录 (只适用于整形主键)</span></span><br><span class="line">db.First(&amp;user, <span class="number">23</span>)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE id = 23 LIMIT 1;</span></span><br><span class="line"><span class="comment">// 根据主键获取记录, 如果它是一个非整形主键</span></span><br><span class="line">db.First(&amp;user, <span class="string">&quot;id = ?&quot;</span>, <span class="string">&quot;string_primary_key&quot;</span>)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE id = &#x27;string_primary_key&#x27; LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Plain SQL</span></span><br><span class="line">db.Find(&amp;user, <span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name = &quot;jinzhu&quot;;</span></span><br><span class="line"></span><br><span class="line">db.Find(&amp;users, <span class="string">&quot;name &lt;&gt; ? AND age &gt; ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>, <span class="number">20</span>)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name &lt;&gt; &quot;jinzhu&quot; AND age &gt; 20;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Struct</span></span><br><span class="line">db.Find(&amp;users, User&#123;Age: <span class="number">20</span>&#125;)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE age = 20;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Map</span></span><br><span class="line">db.Find(&amp;users, <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;age&quot;</span>: <span class="number">20</span>&#125;)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE age = 20;</span></span><br></pre></td></tr></table></figure><h3 id="额外查询选项"><a href="#额外查询选项" class="headerlink" title="额外查询选项"></a>额外查询选项</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为查询 SQL 添加额外的 SQL 操作</span></span><br><span class="line">db.Set(<span class="string">&quot;gorm:query_option&quot;</span>, <span class="string">&quot;FOR UPDATE&quot;</span>).First(&amp;user, <span class="number">10</span>)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE id = 10 FOR UPDATE;</span></span><br></pre></td></tr></table></figure><h3 id="FirstOrInit"><a href="#FirstOrInit" class="headerlink" title="FirstOrInit"></a>FirstOrInit</h3><p>获取匹配的第一条记录，否则根据给定的条件初始化一个新的对象 (仅支持 struct 和 map 条件)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 未找到</span></span><br><span class="line">db.FirstOrInit(&amp;user, User&#123;Name: <span class="string">&quot;non_existing&quot;</span>&#125;)</span><br><span class="line"><span class="comment">//// user -&gt; User&#123;Name: &quot;non_existing&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到</span></span><br><span class="line">db.Where(User&#123;Name: <span class="string">&quot;Jinzhu&quot;</span>&#125;).FirstOrInit(&amp;user)</span><br><span class="line"><span class="comment">//// user -&gt; User&#123;Id: 111, Name: &quot;Jinzhu&quot;, Age: 20&#125;</span></span><br><span class="line">db.FirstOrInit(&amp;user, <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;jinzhu&quot;</span>&#125;)</span><br><span class="line"><span class="comment">//// user -&gt; User&#123;Id: 111, Name: &quot;Jinzhu&quot;, Age: 20&#125;</span></span><br></pre></td></tr></table></figure><h4 id="Attrs"><a href="#Attrs" class="headerlink" title="Attrs"></a>Attrs</h4><p>如果记录未找到，将使用参数初始化 struct.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 未找到</span></span><br><span class="line">db.Where(User&#123;Name: <span class="string">&quot;non_existing&quot;</span>&#125;).Attrs(User&#123;Age: <span class="number">20</span>&#125;).FirstOrInit(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM USERS WHERE name = &#x27;non_existing&#x27;;</span></span><br><span class="line"><span class="comment">//// user -&gt; User&#123;Name: &quot;non_existing&quot;, Age: 20&#125;</span></span><br><span class="line"></span><br><span class="line">db.Where(User&#123;Name: <span class="string">&quot;non_existing&quot;</span>&#125;).Attrs(<span class="string">&quot;age&quot;</span>, <span class="number">20</span>).FirstOrInit(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM USERS WHERE name = &#x27;non_existing&#x27;;</span></span><br><span class="line"><span class="comment">//// user -&gt; User&#123;Name: &quot;non_existing&quot;, Age: 20&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到</span></span><br><span class="line">db.Where(User&#123;Name: <span class="string">&quot;Jinzhu&quot;</span>&#125;).Attrs(User&#123;Age: <span class="number">30</span>&#125;).FirstOrInit(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM USERS WHERE name = jinzhu&#x27;;</span></span><br><span class="line"><span class="comment">//// user -&gt; User&#123;Id: 111, Name: &quot;Jinzhu&quot;, Age: 20&#125;</span></span><br></pre></td></tr></table></figure><h4 id="Assign"><a href="#Assign" class="headerlink" title="Assign"></a>Assign</h4><p>不管记录是否找到，都将参数赋值给 struct.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 未找到</span></span><br><span class="line">db.Where(User&#123;Name: <span class="string">&quot;non_existing&quot;</span>&#125;).Assign(User&#123;Age: <span class="number">20</span>&#125;).FirstOrInit(&amp;user)</span><br><span class="line"><span class="comment">//// user -&gt; User&#123;Name: &quot;non_existing&quot;, Age: 20&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到</span></span><br><span class="line">db.Where(User&#123;Name: <span class="string">&quot;Jinzhu&quot;</span>&#125;).Assign(User&#123;Age: <span class="number">30</span>&#125;).FirstOrInit(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM USERS WHERE name = jinzhu&#x27;;</span></span><br><span class="line"><span class="comment">//// user -&gt; User&#123;Id: 111, Name: &quot;Jinzhu&quot;, Age: 30&#125;</span></span><br></pre></td></tr></table></figure><h3 id="FirstOrCreate"><a href="#FirstOrCreate" class="headerlink" title="FirstOrCreate"></a>FirstOrCreate</h3><p>获取匹配的第一条记录, 否则根据给定的条件创建一个新的记录 (仅支持 struct 和 map 条件)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 未找到</span></span><br><span class="line">db.FirstOrCreate(&amp;user, User&#123;Name: <span class="string">&quot;non_existing&quot;</span>&#125;)</span><br><span class="line"><span class="comment">//// INSERT INTO &quot;users&quot; (name) VALUES (&quot;non_existing&quot;);</span></span><br><span class="line"><span class="comment">//// user -&gt; User&#123;Id: 112, Name: &quot;non_existing&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到</span></span><br><span class="line">db.Where(User&#123;Name: <span class="string">&quot;Jinzhu&quot;</span>&#125;).FirstOrCreate(&amp;user)</span><br><span class="line"><span class="comment">//// user -&gt; User&#123;Id: 111, Name: &quot;Jinzhu&quot;&#125;</span></span><br></pre></td></tr></table></figure><h4 id="Attrs-1"><a href="#Attrs-1" class="headerlink" title="Attrs"></a>Attrs</h4><p>如果记录未找到，将使用参数创建 struct 和记录.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 未找到</span></span><br><span class="line">db.Where(User&#123;Name: <span class="string">&quot;non_existing&quot;</span>&#125;).Attrs(User&#123;Age: <span class="number">20</span>&#125;).FirstOrCreate(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name = &#x27;non_existing&#x27;;</span></span><br><span class="line"><span class="comment">//// INSERT INTO &quot;users&quot; (name, age) VALUES (&quot;non_existing&quot;, 20);</span></span><br><span class="line"><span class="comment">//// user -&gt; User&#123;Id: 112, Name: &quot;non_existing&quot;, Age: 20&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到</span></span><br><span class="line">db.Where(User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>&#125;).Attrs(User&#123;Age: <span class="number">30</span>&#125;).FirstOrCreate(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name = &#x27;jinzhu&#x27;;</span></span><br><span class="line"><span class="comment">//// user -&gt; User&#123;Id: 111, Name: &quot;jinzhu&quot;, Age: 20&#125;</span></span><br></pre></td></tr></table></figure><h4 id="Assign-1"><a href="#Assign-1" class="headerlink" title="Assign"></a>Assign</h4><p>不管记录是否找到，都将参数赋值给 struct 并保存至数据库.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 未找到</span></span><br><span class="line">db.Where(User&#123;Name: <span class="string">&quot;non_existing&quot;</span>&#125;).Assign(User&#123;Age: <span class="number">20</span>&#125;).FirstOrCreate(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name = &#x27;non_existing&#x27;;</span></span><br><span class="line"><span class="comment">//// INSERT INTO &quot;users&quot; (name, age) VALUES (&quot;non_existing&quot;, 20);</span></span><br><span class="line"><span class="comment">//// user -&gt; User&#123;Id: 112, Name: &quot;non_existing&quot;, Age: 20&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到</span></span><br><span class="line">db.Where(User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>&#125;).Assign(User&#123;Age: <span class="number">30</span>&#125;).FirstOrCreate(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name = &#x27;jinzhu&#x27;;</span></span><br><span class="line"><span class="comment">//// UPDATE users SET age=30 WHERE id = 111;</span></span><br><span class="line"><span class="comment">//// user -&gt; User&#123;Id: 111, Name: &quot;jinzhu&quot;, Age: 30&#125;</span></span><br></pre></td></tr></table></figure><h3 id="高级查询"><a href="#高级查询" class="headerlink" title="高级查询"></a>高级查询</h3><h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><p>基于 <code>*gorm.expr</code> 的子查询</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.Where(<span class="string">&quot;amount &gt; ?&quot;</span>, db.Table(<span class="string">&quot;orders&quot;</span>).Select(<span class="string">&quot;AVG(amount)&quot;</span>).Where(<span class="string">&quot;state = ?&quot;</span>, <span class="string">&quot;paid&quot;</span>).SubQuery()).Find(&amp;orders)</span><br><span class="line"><span class="comment">// SELECT * FROM &quot;orders&quot;  WHERE &quot;orders&quot;.&quot;deleted_at&quot; IS NULL AND (amount &gt; (SELECT AVG(amount) FROM &quot;orders&quot;  WHERE (state = &#x27;paid&#x27;)));</span></span><br></pre></td></tr></table></figure><h4 id="选择字段"><a href="#选择字段" class="headerlink" title="选择字段"></a>选择字段</h4><p>Select，指定你想从数据库中检索出的字段，默认会选择全部字段。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">db.Select(<span class="string">&quot;name, age&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT name, age FROM users;</span></span><br><span class="line"></span><br><span class="line">db.Select([]<span class="keyword">string</span>&#123;<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT name, age FROM users;</span></span><br><span class="line"></span><br><span class="line">db.Table(<span class="string">&quot;users&quot;</span>).Select(<span class="string">&quot;COALESCE(age,?)&quot;</span>, <span class="number">42</span>).Rows()</span><br><span class="line"><span class="comment">//// SELECT COALESCE(age,&#x27;42&#x27;) FROM users;</span></span><br></pre></td></tr></table></figure><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>Order，指定从数据库中检索出记录的顺序。设置第二个参数 reorder 为 <code>true</code> ，可以覆盖前面定义的排序条件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">db.Order(<span class="string">&quot;age desc, name&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users ORDER BY age desc, name;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多字段排序</span></span><br><span class="line">db.Order(<span class="string">&quot;age desc&quot;</span>).Order(<span class="string">&quot;name&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users ORDER BY age desc, name;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 覆盖排序</span></span><br><span class="line">db.Order(<span class="string">&quot;age desc&quot;</span>).Find(&amp;users1).Order(<span class="string">&quot;age&quot;</span>, <span class="literal">true</span>).Find(&amp;users2)</span><br><span class="line"><span class="comment">//// SELECT * FROM users ORDER BY age desc; (users1)</span></span><br><span class="line"><span class="comment">//// SELECT * FROM users ORDER BY age; (users2)</span></span><br></pre></td></tr></table></figure><h4 id="数量"><a href="#数量" class="headerlink" title="数量"></a>数量</h4><p>Limit，指定从数据库检索出的最大记录数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.Limit(<span class="number">3</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users LIMIT 3;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -1 取消 Limit 条件</span></span><br><span class="line">db.Limit(<span class="number">10</span>).Find(&amp;users1).Limit(<span class="number">-1</span>).Find(&amp;users2)</span><br><span class="line"><span class="comment">//// SELECT * FROM users LIMIT 10; (users1)</span></span><br><span class="line"><span class="comment">//// SELECT * FROM users; (users2)</span></span><br></pre></td></tr></table></figure><h4 id="偏移"><a href="#偏移" class="headerlink" title="偏移"></a>偏移</h4><p>Offset，指定开始返回记录前要跳过的记录数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.Offset(<span class="number">3</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users OFFSET 3;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -1 取消 Offset 条件</span></span><br><span class="line">db.Offset(<span class="number">10</span>).Find(&amp;users1).Offset(<span class="number">-1</span>).Find(&amp;users2)</span><br><span class="line"><span class="comment">//// SELECT * FROM users OFFSET 10; (users1)</span></span><br><span class="line"><span class="comment">//// SELECT * FROM users; (users2)</span></span><br></pre></td></tr></table></figure><h4 id="总数"><a href="#总数" class="headerlink" title="总数"></a>总数</h4><p>Count，该 model 能获取的记录总数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">db.Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).Or(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu 2&quot;</span>).Find(&amp;users).Count(&amp;count)</span><br><span class="line"><span class="comment">//// SELECT * from USERS WHERE name = &#x27;jinzhu&#x27; OR name = &#x27;jinzhu 2&#x27;; (users)</span></span><br><span class="line"><span class="comment">//// SELECT count(*) FROM users WHERE name = &#x27;jinzhu&#x27; OR name = &#x27;jinzhu 2&#x27;; (count)</span></span><br><span class="line"></span><br><span class="line">db.Model(&amp;User&#123;&#125;).Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).Count(&amp;count)</span><br><span class="line"><span class="comment">//// SELECT count(*) FROM users WHERE name = &#x27;jinzhu&#x27;; (count)</span></span><br><span class="line"></span><br><span class="line">db.Table(<span class="string">&quot;deleted_users&quot;</span>).Count(&amp;count)</span><br><span class="line"><span class="comment">//// SELECT count(*) FROM deleted_users;</span></span><br><span class="line"></span><br><span class="line">db.Table(<span class="string">&quot;deleted_users&quot;</span>).Select(<span class="string">&quot;count(distinct(name))&quot;</span>).Count(&amp;count)</span><br><span class="line"><span class="comment">//// SELECT count( distinct(name) ) FROM deleted_users; (count)</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong> <code>Count</code> 必须是链式查询的最后一个操作 ，因为它会覆盖前面的 <code>SELECT</code>，但如果里面使用了 <code>count</code> 时不会覆盖</p><h4 id="Group-amp-Having"><a href="#Group-amp-Having" class="headerlink" title="Group &amp; Having"></a>Group &amp; Having</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">rows, err := db.Table(<span class="string">&quot;orders&quot;</span>).Select(<span class="string">&quot;date(created_at) as date, sum(amount) as total&quot;</span>).Group(<span class="string">&quot;date(created_at)&quot;</span>).Rows()</span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Scan将多条结果扫描进事先准备好的结构体切片中</span></span><br><span class="line"><span class="keyword">type</span> Result <span class="keyword">struct</span> &#123;</span><br><span class="line">Date time.Time</span><br><span class="line">Total <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> rets []Result</span><br><span class="line">db.Table(<span class="string">&quot;users&quot;</span>).Select(<span class="string">&quot;date(created_at) as date, sum(age) as total&quot;</span>).Group(<span class="string">&quot;date(created_at)&quot;</span>).Scan(&amp;rets)</span><br><span class="line"></span><br><span class="line">rows, err := db.Table(<span class="string">&quot;orders&quot;</span>).Select(<span class="string">&quot;date(created_at) as date, sum(amount) as total&quot;</span>).Group(<span class="string">&quot;date(created_at)&quot;</span>).Having(<span class="string">&quot;sum(amount) &gt; ?&quot;</span>, <span class="number">100</span>).Rows()</span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Result <span class="keyword">struct</span> &#123;</span><br><span class="line">  Date  time.Time</span><br><span class="line">  Total <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line">db.Table(<span class="string">&quot;orders&quot;</span>).Select(<span class="string">&quot;date(created_at) as date, sum(amount) as total&quot;</span>).Group(<span class="string">&quot;date(created_at)&quot;</span>).Having(<span class="string">&quot;sum(amount) &gt; ?&quot;</span>, <span class="number">100</span>).Scan(&amp;results)</span><br></pre></td></tr></table></figure><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><p>Joins，指定连接条件</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rows, err := db.Table(<span class="string">&quot;users&quot;</span>).Select(<span class="string">&quot;users.name, emails.email&quot;</span>).Joins(<span class="string">&quot;left join emails on emails.user_id = users.id&quot;</span>).Rows()</span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">db.Table(<span class="string">&quot;users&quot;</span>).Select(<span class="string">&quot;users.name, emails.email&quot;</span>).Joins(<span class="string">&quot;left join emails on emails.user_id = users.id&quot;</span>).Scan(&amp;results)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多连接及参数</span></span><br><span class="line">db.Joins(<span class="string">&quot;JOIN emails ON emails.user_id = users.id AND emails.email = ?&quot;</span>, <span class="string">&quot;jinzhu@example.org&quot;</span>).Joins(<span class="string">&quot;JOIN credit_cards ON credit_cards.user_id = users.id&quot;</span>).Where(<span class="string">&quot;credit_cards.number = ?&quot;</span>, <span class="string">&quot;411111111111&quot;</span>).Find(&amp;user)</span><br></pre></td></tr></table></figure><h3 id="Pluck"><a href="#Pluck" class="headerlink" title="Pluck"></a>Pluck</h3><p>Pluck，查询 model 中的一个列作为切片，如果您想要查询多个列，您应该使用 <a href="https://www.liwenzhou.com/posts/Go/gorm_crud/#Scan"><code>Scan</code></a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ages []<span class="keyword">int64</span></span><br><span class="line">db.Find(&amp;users).Pluck(<span class="string">&quot;age&quot;</span>, &amp;ages)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> names []<span class="keyword">string</span></span><br><span class="line">db.Model(&amp;User&#123;&#125;).Pluck(<span class="string">&quot;name&quot;</span>, &amp;names)</span><br><span class="line"></span><br><span class="line">db.Table(<span class="string">&quot;deleted_users&quot;</span>).Pluck(<span class="string">&quot;name&quot;</span>, &amp;names)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 想查询多个字段？ 这样做：</span></span><br><span class="line">db.Select(<span class="string">&quot;name, age&quot;</span>).Find(&amp;users)</span><br></pre></td></tr></table></figure><h3 id="扫描"><a href="#扫描" class="headerlink" title="扫描"></a>扫描</h3><p>Scan，扫描结果至一个 struct.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Result <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name <span class="keyword">string</span></span><br><span class="line">  Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result Result</span><br><span class="line">db.Table(<span class="string">&quot;users&quot;</span>).Select(<span class="string">&quot;name, age&quot;</span>).Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;Antonio&quot;</span>).Scan(&amp;result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> results []Result</span><br><span class="line">db.Table(<span class="string">&quot;users&quot;</span>).Select(<span class="string">&quot;name, age&quot;</span>).Where(<span class="string">&quot;id &gt; ?&quot;</span>, <span class="number">0</span>).Scan(&amp;results)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原生 SQL</span></span><br><span class="line">db.Raw(<span class="string">&quot;SELECT name, age FROM users WHERE name = ?&quot;</span>, <span class="string">&quot;Antonio&quot;</span>).Scan(&amp;result)</span><br></pre></td></tr></table></figure><h2 id="链式操作相关"><a href="#链式操作相关" class="headerlink" title="链式操作相关"></a>链式操作相关</h2><h3 id="链式操作"><a href="#链式操作" class="headerlink" title="链式操作"></a>链式操作</h3><p><code>Method Chaining</code>，<code>Gorm</code> 实现了链式操作接口，所以你可以把代码写成这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个查询</span></span><br><span class="line">tx := db.Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加更多条件</span></span><br><span class="line"><span class="keyword">if</span> someCondition &#123;</span><br><span class="line">  tx = tx.Where(<span class="string">&quot;age = ?&quot;</span>, <span class="number">20</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  tx = tx.Where(<span class="string">&quot;age = ?&quot;</span>, <span class="number">30</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> yetAnotherCondition &#123;</span><br><span class="line">  tx = tx.Where(<span class="string">&quot;active = ?&quot;</span>, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用立即执行方法前不会生成<code>Query</code>语句，借助这个特性你可以创建一个函数来处理一些通用逻辑。</p><h3 id="立即执行方法"><a href="#立即执行方法" class="headerlink" title="立即执行方法"></a>立即执行方法</h3><p><code>Immediate methods</code> ，立即执行方法是指那些会立即生成<code>SQL</code>语句并发送到数据库的方法, 他们一般是<code>CRUD</code>方法，比如：</p><p><code>Create</code>, <code>First</code>, <code>Find</code>, <code>Take</code>, <code>Save</code>, <code>UpdateXXX</code>, <code>Delete</code>, <code>Scan</code>, <code>Row</code>, <code>Rows</code>…</p><p>这有一个基于上面链式方法代码的立即执行方法的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tx.Find(&amp;user)</span><br></pre></td></tr></table></figure><p>生成的SQL语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;jinzhu&#x27;</span> <span class="keyword">AND</span> age <span class="operator">=</span> <span class="number">30</span> <span class="keyword">AND</span> active <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><p><code>Scopes</code>，Scope是建立在链式操作的基础之上的。</p><p>基于它，你可以抽取一些通用逻辑，写出更多可重用的函数库。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AmountGreaterThan1000</span><span class="params">(db *gorm.DB)</span> *<span class="title">gorm</span>.<span class="title">DB</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> db.Where(<span class="string">&quot;amount &gt; ?&quot;</span>, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PaidWithCreditCard</span><span class="params">(db *gorm.DB)</span> *<span class="title">gorm</span>.<span class="title">DB</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> db.Where(<span class="string">&quot;pay_mode_sign = ?&quot;</span>, <span class="string">&quot;C&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PaidWithCod</span><span class="params">(db *gorm.DB)</span> *<span class="title">gorm</span>.<span class="title">DB</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> db.Where(<span class="string">&quot;pay_mode_sign = ?&quot;</span>, <span class="string">&quot;C&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OrderStatus</span><span class="params">(status []<span class="keyword">string</span>)</span> <span class="title">func</span> <span class="params">(db *gorm.DB)</span> *<span class="title">gorm</span>.<span class="title">DB</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">func</span> <span class="params">(db *gorm.DB)</span> *<span class="title">gorm</span>.<span class="title">DB</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> db.Scopes(AmountGreaterThan1000).Where(<span class="string">&quot;status IN (?)&quot;</span>, status)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">db.Scopes(AmountGreaterThan1000, PaidWithCreditCard).Find(&amp;orders)</span><br><span class="line"><span class="comment">// 查找所有金额大于 1000 的信用卡订单</span></span><br><span class="line"></span><br><span class="line">db.Scopes(AmountGreaterThan1000, PaidWithCod).Find(&amp;orders)</span><br><span class="line"><span class="comment">// 查找所有金额大于 1000 的 COD 订单</span></span><br><span class="line"></span><br><span class="line">db.Scopes(AmountGreaterThan1000, OrderStatus([]<span class="keyword">string</span>&#123;<span class="string">&quot;paid&quot;</span>, <span class="string">&quot;shipped&quot;</span>&#125;)).Find(&amp;orders)</span><br><span class="line"><span class="comment">// 查找所有金额大于 1000 且已付款或者已发货的订单</span></span><br></pre></td></tr></table></figure><h3 id="多个立即执行方法"><a href="#多个立即执行方法" class="headerlink" title="多个立即执行方法"></a>多个立即执行方法</h3><p>Multiple Immediate Methods，在 GORM 中使用多个立即执行方法时，后一个立即执行方法会复用前一个<strong>立即执行方法</strong>的条件 (不包括内联条件) 。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.Where(<span class="string">&quot;name LIKE ?&quot;</span>, <span class="string">&quot;jinzhu%&quot;</span>).Find(&amp;users, <span class="string">&quot;id IN (?)&quot;</span>, []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;).Count(&amp;count)</span><br></pre></td></tr></table></figure><p>生成的 Sql</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;jinzhu%&#x27;</span> <span class="keyword">AND</span> id <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;jinzhu%&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><h3 id="更新所有字段"><a href="#更新所有字段" class="headerlink" title="更新所有字段"></a>更新所有字段</h3><p><code>Save()</code>默认会更新该对象的所有字段，即使你没有赋值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.First(&amp;user)</span><br><span class="line"></span><br><span class="line">user.Name = <span class="string">&quot;七米&quot;</span></span><br><span class="line">user.Age = <span class="number">99</span></span><br><span class="line">db.Save(&amp;user)</span><br><span class="line"></span><br><span class="line"><span class="comment">////  UPDATE `users` SET `created_at` = &#x27;2020-02-16 12:52:20&#x27;, `updated_at` = &#x27;2020-02-16 12:54:55&#x27;, `deleted_at` = NULL, `name` = &#x27;七米&#x27;, `age` = 99, `active` = true  WHERE `users`.`deleted_at` IS NULL AND `users`.`id` = 1</span></span><br></pre></td></tr></table></figure><h3 id="更新修改字段"><a href="#更新修改字段" class="headerlink" title="更新修改字段"></a>更新修改字段</h3><p>如果你只希望更新指定字段，可以使用<code>Update</code>或者<code>Updates</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新单个属性，如果它有变化</span></span><br><span class="line">db.Model(&amp;user).Update(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="comment">//// UPDATE users SET name=&#x27;hello&#x27;, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE id=111;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据给定的条件更新单个属性</span></span><br><span class="line">db.Model(&amp;user).Where(<span class="string">&quot;active = ?&quot;</span>, <span class="literal">true</span>).Update(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="comment">//// UPDATE users SET name=&#x27;hello&#x27;, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE id=111 AND active=true;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 map 更新多个属性，只会更新其中有变化的属性</span></span><br><span class="line">db.Model(&amp;user).Updates(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>, <span class="string">&quot;active&quot;</span>: <span class="literal">false</span>&#125;)</span><br><span class="line"><span class="comment">//// UPDATE users SET name=&#x27;hello&#x27;, age=18, active=false, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE id=111;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 struct 更新多个属性，只会更新其中有变化且为非零值的字段</span></span><br><span class="line">db.Model(&amp;user).Updates(User&#123;Name: <span class="string">&quot;hello&quot;</span>, Age: <span class="number">18</span>&#125;)</span><br><span class="line"><span class="comment">//// UPDATE users SET name=&#x27;hello&#x27;, age=18, updated_at = &#x27;2013-11-17 21:34:10&#x27; WHERE id = 111;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 警告：当使用 struct 更新时，GORM只会更新那些非零值的字段</span></span><br><span class="line"><span class="comment">// 对于下面的操作，不会发生任何更新，&quot;&quot;, 0, false 都是其类型的零值</span></span><br><span class="line">db.Model(&amp;user).Updates(User&#123;Name: <span class="string">&quot;&quot;</span>, Age: <span class="number">0</span>, Active: <span class="literal">false</span>&#125;)</span><br></pre></td></tr></table></figure><h3 id="更新选定字段"><a href="#更新选定字段" class="headerlink" title="更新选定字段"></a>更新选定字段</h3><p>如果你想更新或忽略某些字段，你可以使用 <code>Select</code>，<code>Omit</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.Model(&amp;user).Select(<span class="string">&quot;name&quot;</span>).Updates(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>, <span class="string">&quot;active&quot;</span>: <span class="literal">false</span>&#125;)</span><br><span class="line"><span class="comment">//// UPDATE users SET name=&#x27;hello&#x27;, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE id=111;</span></span><br><span class="line"></span><br><span class="line">db.Model(&amp;user).Omit(<span class="string">&quot;name&quot;</span>).Updates(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>, <span class="string">&quot;active&quot;</span>: <span class="literal">false</span>&#125;)</span><br><span class="line"><span class="comment">//// UPDATE users SET age=18, active=false, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE id=111;</span></span><br></pre></td></tr></table></figure><h3 id="无Hooks更新"><a href="#无Hooks更新" class="headerlink" title="无Hooks更新"></a>无Hooks更新</h3><p>上面的更新操作会自动运行 model 的 <code>BeforeUpdate</code>, <code>AfterUpdate</code> 方法，更新 <code>UpdatedAt</code> 时间戳, 在更新时保存其 <code>Associations</code>, 如果你不想调用这些方法，你可以使用 <code>UpdateColumn</code>， <code>UpdateColumns</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新单个属性，类似于 `Update`</span></span><br><span class="line">db.Model(&amp;user).UpdateColumn(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="comment">//// UPDATE users SET name=&#x27;hello&#x27; WHERE id = 111;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新多个属性，类似于 `Updates`</span></span><br><span class="line">db.Model(&amp;user).UpdateColumns(User&#123;Name: <span class="string">&quot;hello&quot;</span>, Age: <span class="number">18</span>&#125;)</span><br><span class="line"><span class="comment">//// UPDATE users SET name=&#x27;hello&#x27;, age=18 WHERE id = 111;</span></span><br></pre></td></tr></table></figure><h3 id="批量更新"><a href="#批量更新" class="headerlink" title="批量更新"></a>批量更新</h3><p>批量更新时<code>Hooks（钩子函数）</code>不会运行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">db.Table(<span class="string">&quot;users&quot;</span>).Where(<span class="string">&quot;id IN (?)&quot;</span>, []<span class="keyword">int</span>&#123;<span class="number">10</span>, <span class="number">11</span>&#125;).Updates(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>&#125;)</span><br><span class="line"><span class="comment">//// UPDATE users SET name=&#x27;hello&#x27;, age=18 WHERE id IN (10, 11);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 struct 更新时，只会更新非零值字段，若想更新所有字段，请使用map[string]interface&#123;&#125;</span></span><br><span class="line">db.Model(User&#123;&#125;).Updates(User&#123;Name: <span class="string">&quot;hello&quot;</span>, Age: <span class="number">18</span>&#125;)</span><br><span class="line"><span class="comment">//// UPDATE users SET name=&#x27;hello&#x27;, age=18;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 `RowsAffected` 获取更新记录总数</span></span><br><span class="line">db.Model(User&#123;&#125;).Updates(User&#123;Name: <span class="string">&quot;hello&quot;</span>, Age: <span class="number">18</span>&#125;).RowsAffected</span><br></pre></td></tr></table></figure><h3 id="使用SQL表达式更新"><a href="#使用SQL表达式更新" class="headerlink" title="使用SQL表达式更新"></a>使用SQL表达式更新</h3><p>先查询表中的第一条数据保存至user变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user User</span><br><span class="line">db.First(&amp;user)</span><br><span class="line">db.Model(&amp;user).Update(<span class="string">&quot;age&quot;</span>, gorm.Expr(<span class="string">&quot;age * ? + ?&quot;</span>, <span class="number">2</span>, <span class="number">100</span>))</span><br><span class="line"><span class="comment">//// UPDATE `users` SET `age` = age * 2 + 100, `updated_at` = &#x27;2020-02-16 13:10:20&#x27;  WHERE `users`.`id` = 1;</span></span><br><span class="line"></span><br><span class="line">db.Model(&amp;user).Updates(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;age&quot;</span>: gorm.Expr(<span class="string">&quot;age * ? + ?&quot;</span>, <span class="number">2</span>, <span class="number">100</span>)&#125;)</span><br><span class="line"><span class="comment">//// UPDATE &quot;users&quot; SET &quot;age&quot; = age * &#x27;2&#x27; + &#x27;100&#x27;, &quot;updated_at&quot; = &#x27;2020-02-16 13:05:51&#x27; WHERE `users`.`id` = 1;</span></span><br><span class="line"></span><br><span class="line">db.Model(&amp;user).UpdateColumn(<span class="string">&quot;age&quot;</span>, gorm.Expr(<span class="string">&quot;age - ?&quot;</span>, <span class="number">1</span>))</span><br><span class="line"><span class="comment">//// UPDATE &quot;users&quot; SET &quot;age&quot; = age - 1 WHERE &quot;id&quot; = &#x27;1&#x27;;</span></span><br><span class="line"></span><br><span class="line">db.Model(&amp;user).Where(<span class="string">&quot;age &gt; 10&quot;</span>).UpdateColumn(<span class="string">&quot;age&quot;</span>, gorm.Expr(<span class="string">&quot;age - ?&quot;</span>, <span class="number">1</span>))</span><br><span class="line"><span class="comment">//// UPDATE &quot;users&quot; SET &quot;age&quot; = age - 1 WHERE &quot;id&quot; = &#x27;1&#x27; AND quantity &gt; 10;</span></span><br></pre></td></tr></table></figure><h3 id="修改Hooks中的值"><a href="#修改Hooks中的值" class="headerlink" title="修改Hooks中的值"></a>修改Hooks中的值</h3><p>如果你想修改 <code>BeforeUpdate</code>, <code>BeforeSave</code> 等 Hooks 中更新的值，你可以使用 <code>scope.SetColumn</code>, 例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(user *User)</span> <span class="title">BeforeSave</span><span class="params">(scope *gorm.Scope)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> pw, err := bcrypt.GenerateFromPassword(user.Password, <span class="number">0</span>); err == <span class="literal">nil</span> &#123;</span><br><span class="line">    scope.SetColumn(<span class="string">&quot;EncryptedPassword&quot;</span>, pw)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其它更新选项"><a href="#其它更新选项" class="headerlink" title="其它更新选项"></a>其它更新选项</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为 update SQL 添加其它的 SQL</span></span><br><span class="line">db.Model(&amp;user).Set(<span class="string">&quot;gorm:update_option&quot;</span>, <span class="string">&quot;OPTION (OPTIMIZE FOR UNKNOWN)&quot;</span>).Update(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="comment">//// UPDATE users SET name=&#x27;hello&#x27;, updated_at = &#x27;2013-11-17 21:34:10&#x27; WHERE id=111 OPTION (OPTIMIZE FOR UNKNOWN);</span></span><br></pre></td></tr></table></figure><h2 id="删除记录"><a href="#删除记录" class="headerlink" title="删除记录"></a>删除记录</h2><h3 id="删除记录-1"><a href="#删除记录-1" class="headerlink" title="删除记录"></a>删除记录</h3><blockquote><p><strong>警告</strong> 删除记录时，请确保主键字段有值，<code>GORM</code> 会通过主键去删除记录，如果主键为空，<code>GORM</code> 会删除该 <code>model</code> 的所有记录。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除现有记录</span></span><br><span class="line">db.Delete(&amp;email)</span><br><span class="line"><span class="comment">//// DELETE from emails where id=10;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为删除 SQL 添加额外的 SQL 操作</span></span><br><span class="line">db.Set(<span class="string">&quot;gorm:delete_option&quot;</span>, <span class="string">&quot;OPTION (OPTIMIZE FOR UNKNOWN)&quot;</span>).Delete(&amp;email)</span><br><span class="line"><span class="comment">//// DELETE from emails where id=10 OPTION (OPTIMIZE FOR UNKNOWN);</span></span><br></pre></td></tr></table></figure><h3 id="批量删除"><a href="#批量删除" class="headerlink" title="批量删除"></a>批量删除</h3><p>删除全部匹配的记录</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.Where(<span class="string">&quot;email LIKE ?&quot;</span>, <span class="string">&quot;%jinzhu%&quot;</span>).Delete(Email&#123;&#125;)</span><br><span class="line"><span class="comment">//// DELETE from emails where email LIKE &quot;%jinzhu%&quot;;</span></span><br><span class="line"></span><br><span class="line">db.Delete(Email&#123;&#125;, <span class="string">&quot;email LIKE ?&quot;</span>, <span class="string">&quot;%jinzhu%&quot;</span>)</span><br><span class="line"><span class="comment">//// DELETE from emails where email LIKE &quot;%jinzhu%&quot;;</span></span><br></pre></td></tr></table></figure><h3 id="软删除"><a href="#软删除" class="headerlink" title="软删除"></a>软删除</h3><p>如果一个 <code>model</code> 有 <code>DeletedAt</code> 字段，他将自动获得软删除的功能！ 当调用 <code>Delete</code> 方法时， 记录不会真正的从数据库中被删除， 只会将<code>DeletedAt</code> 字段的值会被设置为当前时间</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">db.Delete(&amp;user)</span><br><span class="line"><span class="comment">//// UPDATE users SET deleted_at=&quot;2013-10-29 10:23&quot; WHERE id = 111;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量删除</span></span><br><span class="line">db.Where(<span class="string">&quot;age = ?&quot;</span>, <span class="number">20</span>).Delete(&amp;User&#123;&#125;)</span><br><span class="line"><span class="comment">//// UPDATE users SET deleted_at=&quot;2013-10-29 10:23&quot; WHERE age = 20;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询记录时会忽略被软删除的记录</span></span><br><span class="line">db.Where(<span class="string">&quot;age = 20&quot;</span>).Find(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE age = 20 AND deleted_at IS NULL;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Unscoped 方法可以查询被软删除的记录</span></span><br><span class="line">db.Unscoped().Where(<span class="string">&quot;age = 20&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE age = 20;</span></span><br></pre></td></tr></table></figure><h3 id="物理删除"><a href="#物理删除" class="headerlink" title="物理删除"></a>物理删除</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unscoped 方法可以物理删除记录</span></span><br><span class="line">db.Unscoped().Delete(&amp;order)</span><br><span class="line"><span class="comment">//// DELETE FROM orders WHERE id=10;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;GORM框架在Go中的简单运用&lt;/p&gt;</summary>
    
    
    
    <category term="Go" scheme="http://xucoud.github.io/categories/Go/"/>
    
    <category term="ORM" scheme="http://xucoud.github.io/categories/Go/ORM/"/>
    
    
    <category term="Go" scheme="http://xucoud.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go内存分配器</title>
    <link href="http://xucoud.github.io/2021/10/21/Go%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8/"/>
    <id>http://xucoud.github.io/2021/10/21/Go%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8/</id>
    <published>2021-10-21T15:00:52.000Z</published>
    <updated>2021-10-22T16:00:28.381Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Go 语言内存分配器的实现原理的简单理解</p><span id="more"></span><p>​        程序中的数据和变量都会被分配到程序所在的虚拟内存中，内存中包含两个最重要的区域——栈区（Stack）和堆区（Heap）。函数调用的<strong>参数</strong>、<strong>返回值</strong>以及<strong>局部变量</strong>大都会被分配到<strong>栈</strong>上，这部分内存会由编译器进行管理；不同编程语言使用不同的方法管理堆区的内存，<code>C++</code> 等编程语言会由<strong>工程师主动申请和释放内存</strong>，<code>Go</code> 以及 <code>Java</code> 等编程语言会由<strong>工程师和编译器共同管理</strong>，堆中的对象由<strong>内存分配器</strong>分配并由<strong>垃圾收集器</strong>回收。</p><h2 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h2><p>​        内存管理一般包含三个不同的组件，分别是<strong>用户程序（Mutator）</strong>、<strong>分配器（Allocator）</strong>和<strong>收集器（Collector）</strong>，当用户程序申请内存时，它会通过内存分配器申请新的内存，而分配器会负责从堆中初始化相应的内存区域。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/2/17098fd22760b5c7~tplv-t2oaga2asx-watermark.awebp" class="lazyload" data-srcset="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/2/17098fd22760b5c7~tplv-t2oaga2asx-watermark.awebp" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="mutator-allocator-collector"></p><p>​        Go 语言的内存分配器实现非常复杂，在分析内存分配器的实现之前，我们需要了解内存分配的设计原理，帮助我们更快掌握内存的分配过程。这里将要详细介内存分配器的分配方法以及 Go 语言内存分配器的分级分配方法、虚拟内存布局和地址空间。</p><h3 id="分配方法"><a href="#分配方法" class="headerlink" title="分配方法"></a>分配方法</h3><p>​        编程语言的内存分配器一般包含两种分配方法，一种是线性分配器（Sequential Allocator，Bump Allocator），另一种是空闲链表分配器（Free-List Allocator），这两种分配方法有着不同的实现机制和特性。</p><h4 id="线性分配器"><a href="#线性分配器" class="headerlink" title="线性分配器"></a>线性分配器</h4><p>​        线性分配（Bump Allocator）是一种高效的内存分配方法，但是有较大的局限性。当我们在编程语言中使用线性分配器，我们只需要在内存中维护一个指向内存特定位置的指针，当用户程序申请内存时，分配器只需要检查剩余的空闲内存、返回分配的内存区域并修改指针在内存中的位置，即移动下图中的指针：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/2/17098fd227d99925~tplv-t2oaga2asx-watermark.awebp" class="lazyload" data-srcset="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/2/17098fd227d99925~tplv-t2oaga2asx-watermark.awebp" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="bump-allocator"></p><ul><li><p>优点：</p><ul><li><p>较快的执行速度</p></li><li><p>较低的实现复杂度</p></li></ul></li><li><p>缺点</p><ul><li>线性分配器无法在内存被释放时重用内存。</li><li>如果一个程序的内存大小超过了每个内存块的大小，那么系统则会出现内存覆盖的问题</li></ul></li></ul><p>如下图所示，如果已经分配的内存被回收，线性分配器是无法重新利用红色的这部分内存的：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/2/17098fd22858c1d9~tplv-t2oaga2asx-watermark.awebp" class="lazyload" data-srcset="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/2/17098fd22858c1d9~tplv-t2oaga2asx-watermark.awebp" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="bump-allocator-reclaim-memory"></p><p>​        正是因为线性分配器的这种特性，我们需要合适的垃圾回收算法配合使用。标记压缩（Mark-Compact）、复制回收（Copying GC）和分代回收（Generational GC）等算法可以通过拷贝的方式整理存活对象的碎片，将空闲内存定期合并，这样就能利用线性分配器的效率提升内存分配器的性能了。</p><p>​        因为线性分配器的使用需要配合具有拷贝特性的垃圾回收算法，所以 C 和 C++ 等需要直接对外暴露指针的语言就无法使用该策略。</p><h4 id="空闲链表分配器"><a href="#空闲链表分配器" class="headerlink" title="空闲链表分配器"></a>空闲链表分配器</h4><p>​        因为不同的内存块通过指针构成了链表，所以使用这种方式的分配器可以重新利用回收的资源，但是因为分配内存时需要遍历链表，所以它的时间复杂度是 O(n)O(n)。空闲链表分配器可以选择不同的策略在链表中的内存块中进行选择，最常见的是以下四种：</p><ul><li>首次适应（First-Fit）— 从链表头开始遍历，选择第一个大小大于申请内存的内存块；</li><li>循环首次适应（Next-Fit）— 从上次遍历的结束位置开始遍历，选择第一个大小大于申请内存的内存块；</li><li>最优适应（Best-Fit）— 从链表头遍历整个链表，选择最合适的内存块；</li><li>隔离适应（Segregated-Fit）— 将内存分割成多个链表，每个链表中的内存块大小相同，申请内存时先找到满足条件的链表，再从链表中选择合适的内存块；</li></ul><p>上述四种策略的前三种就不过多介绍了，Go 语言使用的内存分配策略与第四种策略有些相似，我们通过下图了解该策略的原理：</p><p><img src="https://img.draveness.me/2020-02-29-15829868066452-segregated-list.png" class="lazyload" data-srcset="https://img.draveness.me/2020-02-29-15829868066452-segregated-list.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="segregated-list"></p><p>​        如上图所示，该策略会将内存分割成由 4、8、16、32 字节的内存块组成的链表，当我们向内存分配器申请 8 字节的内存时，它会在上图中找到满足条件的空闲内存块并返回。隔离适应的分配策略减少了需要遍历的内存块数量，提高了内存分配的效率。</p><h3 id="分级分配"><a href="#分级分配" class="headerlink" title="分级分配"></a>分级分配</h3><p>​        线程缓存分配（Thread-Caching Malloc，<code>TCMalloc</code>）是用于分配内存的机制，它比 <code>glibc</code> 中的 <code>malloc</code> 还要快很多。Go 语言的内存分配器就借鉴了 <code>TCMalloc</code> 的设计实现高速的内存分配，它的核心理念是使用多级缓存将对象根据大小分类，并按照类别实施不同的分配策略。</p><h4 id="对象大小"><a href="#对象大小" class="headerlink" title="对象大小"></a>对象大小</h4><p>​        Go 语言的内存分配器会根据申请分配的内存大小选择不同的处理逻辑，运行时根据对象的大小将对象分成微对象、小对象和大对象三种：</p><table><thead><tr><th align="center">类别</th><th align="center">大小</th></tr></thead><tbody><tr><td align="center">微对象</td><td align="center"><code>(0, 16B)</code></td></tr><tr><td align="center">小对象</td><td align="center"><code>[16B, 32KB]</code></td></tr><tr><td align="center">大对象</td><td align="center"><code>(32KB, +∞)</code></td></tr></tbody></table><p>​        因为程序中的绝大多数对象的大小都在 32KB 以下，而申请的内存大小影响 Go 语言运行时分配内存的过程和开销，所以分别处理大对象和小对象有利于提高内存分配器的性能。</p><h4 id="多级缓存"><a href="#多级缓存" class="headerlink" title="多级缓存"></a>多级缓存</h4><p>​        内存分配器不仅会区别对待大小不同的对象，还会将内存分成不同的级别分别管理，TCMalloc 和 Go 运行时分配器都会引入线程缓存（<code>Thread Cache</code>）、中心缓存（<code>Central Cache</code>）和页堆（<code>Page Heap</code>）三个组件分级管理内存：</p><p><img src="https://img.draveness.me/2020-02-29-15829868066457-multi-level-cache.png" class="lazyload" data-srcset="https://img.draveness.me/2020-02-29-15829868066457-multi-level-cache.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="multi-level-cache"></p><p>​        线程缓存属于每一个独立的线程，它能够满足线程上绝大多数的内存分配需求，因为不涉及多线程，所以也不需要使用互斥锁来保护内存，这能够减少锁竞争带来的性能损耗。当线程缓存不能满足需求时，运行时会使用中心缓存作为补充解决小对象的内存分配，在遇到 32KB 以上的对象时，内存分配器会选择页堆直接分配大内存。</p><p>​        这种多层级的内存分配设计与计算机操作系统中的多级缓存有些类似，因为多数的对象都是小对象，我们可以通过线程缓存和中心缓存提供足够的内存空间，发现资源不足时从上一级组件中获取更多的内存资源。</p><h3 id="虚拟内存布局"><a href="#虚拟内存布局" class="headerlink" title="虚拟内存布局"></a>虚拟内存布局</h3><p>​        这里会介绍 Go 语言堆区内存地址空间的设计以及演进过程，在 Go 语言 1.10 以前的版本，堆区的内存空间都是连续的；但是在 1.11 版本，Go 团队使用稀疏的堆内存空间替代了连续的内存，解决了连续内存带来的限制以及在特殊场景下可能出现的问题。</p><h4 id="线性内存"><a href="#线性内存" class="headerlink" title="线性内存"></a>线性内存</h4><p>​        Go 语言程序的 1.10 版本在启动时会初始化整片虚拟内存区域，如下所示的三个区域 <code>spans</code>、<code>bitmap</code> 和 <code>arena</code> 分别预留了 512MB、16GB 以及 512GB 的内存空间，这些内存并不是真正存在的物理内存，而是虚拟内存：</p><p><img src="https://img.draveness.me/2020-10-19-16031147347484/heap-before-go-1-10.png" class="lazyload" data-srcset="https://img.draveness.me/2020-10-19-16031147347484/heap-before-go-1-10.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="heap-before-go-1-10"></p><ul><li><code>spans</code> 区域存储了指向内存管理单元 <code>runtime.mspan</code>会管理几页的内存空间，每页大小为 8KB；</li><li><code>bitmap</code> 用于标识 <code>arena</code> 区域中的那些地址保存了对象，位图中的每个字节都会表示堆区中的 32 字节是否空闲；</li><li><code>arena</code> 区域是真正的堆区，运行时会将 8KB 看做一页，这些内存页中存储了所有在堆上初始化的对象；</li></ul><p>​        对于任意一个地址，我们都可以根据 <code>arena</code> 的基地址计算该地址所在的页数并通过 <code>spans</code> 数组获得管理该片内存的管理单元 <code>runtime.mspan</code></p><p>​        Go 语言在垃圾回收时会根据指针的地址判断对象是否在堆中，并通过上一段中介绍的过程找到管理该对象的 <code>runtime.mspan</code>Go 混合使用时会导致程序崩溃：</p><ol><li>分配的内存地址会发生冲突，导致堆的初始化和扩容失败；</li><li>没有被预留的大块内存可能会被分配给 C 语言的二进制，导致扩容后的堆不连续；</li></ol><p>​        线性的堆内存需要预留大块的内存空间，但是申请大块的内存空间而不使用是不切实际的，不预留内存空间却会在特殊场景下造成程序崩溃。虽然连续内存的实现比较简单，但是这些问题也没有办法忽略。</p><h4 id="稀疏内存"><a href="#稀疏内存" class="headerlink" title="稀疏内存"></a>稀疏内存</h4><p>​        稀疏内存是 Go 语言在 1.11 中提出的方案，使用稀疏的内存布局不仅能移除堆大小的上限，还能解决 C 和 Go 混合使用时的地址空间冲突问题。不过因为基于稀疏内存的内存管理失去了内存的连续性这一假设，这也使内存管理变得更加复杂：</p><p><img src="https://img.draveness.me/2020-02-29-15829868066468-heap-after-go-1-11.png" class="lazyload" data-srcset="https://img.draveness.me/2020-02-29-15829868066468-heap-after-go-1-11.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="heap-after-go-1-11"></p><p>如上图所示，运行时使用二维的 <code>runtime.heapArena</code>单元都会管理 64MB 的内存空间：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> heapArena <span class="keyword">struct</span> &#123;</span><br><span class="line">bitmap       [heapArenaBitmapBytes]<span class="keyword">byte</span></span><br><span class="line">spans        [pagesPerArena]*mspan</span><br><span class="line">pageInUse    [pagesPerArena / <span class="number">8</span>]<span class="keyword">uint8</span></span><br><span class="line">pageMarks    [pagesPerArena / <span class="number">8</span>]<span class="keyword">uint8</span></span><br><span class="line">pageSpecials [pagesPerArena / <span class="number">8</span>]<span class="keyword">uint8</span></span><br><span class="line">checkmarks   *checkmarksMap</span><br><span class="line">zeroedBase   <span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        该结构体中的 <code>bitmap</code> 和 <code>spans</code> 与线性内存中的 <code>bitmap</code> 和 <code>spans</code> 区域一一对应，<code>zeroedBase</code> 字段指向了该结构体管理的内存的基地址。上述设计将原有的连续大内存切分成稀疏的小内存，而用于管理这些内存的元信息也被切成了小块。</p><p>​        不同平台和架构的二维数组大小可能完全不同，如果我们的 Go 语言服务在 Linux 的 x86-64 架构上运行，二维数组的一维大小会是 1，而二维大小是 4,194,304，因为每一个指针占用 8 字节的内存空间，所以元信息的总大小为 32MB。由于每个 <code>runtime.heapArena</code>都会管理 64MB 的内存，整个堆区最多可以管理 256TB 的内存，这比之前的 512GB 多好几个数量级。</p><p>​        由于内存的管理变得更加复杂，上述改动对垃圾回收稍有影响，大约会增加 1% 的垃圾回收开销，不过这也是我们为了解决已有问题必须付出的成本。</p><h3 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h3><p>​        因为所有的内存最终都是要从操作系统中申请的，所以 Go 语言的运行时构建了操作系统的内存管理抽象层，该抽象层将运行时管理的地址空间分成以下四种状态：</p><table><thead><tr><th align="center">状态</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center"><code>None</code></td><td align="center">内存没有被保留或者映射，是地址空间的默认状态</td></tr><tr><td align="center"><code>Reserved</code></td><td align="center">运行时持有该地址空间，但是访问该内存会导致错误</td></tr><tr><td align="center"><code>Prepared</code></td><td align="center">内存被保留，一般没有对应的物理内存访问该片内存的行为是未定义的可以快速转换到 <code>Ready</code> 状态</td></tr><tr><td align="center"><code>Ready</code></td><td align="center">可以被安全访问</td></tr></tbody></table><p>​        每个不同的操作系统都会包含一组用于管理内存的特定方法，这些方法可以让内存地址空间在不同的状态之间转换，我们可以通过下图了解不同状态之间的转换过程：</p><p><img src="https://img.draveness.me/2020-02-29-15829868066474-memory-regions-states-and-transitions.png" class="lazyload" data-srcset="https://img.draveness.me/2020-02-29-15829868066474-memory-regions-states-and-transitions.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="memory-regions-states-and-transitions"></p><p>​        运行时中包含多个操作系统实现的状态转换方法，所有的实现都包含在以 <code>mem_</code> 开头的文件中，本节将介绍 Linux 操作系统对上图中方法的实现：</p><ul><li><code>runtime.sysAlloc</code>会从操作系统中获取一大块可用的内存空间，可能为几百 KB 或者几 MB；</li><li><code>runtime.sysFree</code>会在程序发生内存不足（Out-of Memory，OOM）时调用并无条件地返回内存；</li><li><code>runtime.sysReserve</code>会保留操作系统中的一片内存区域，访问这片内存会触发异常；</li><li><code>runtime.sysMap</code>保证内存区域可以快速转换至就绪状态；</li><li><code>runtime.sysUsed</code>通知操作系统应用程序需要使用该内存区域，保证内存区域可以安全访问；</li><li><code>runtime.sysUnused</code>通知操作系统虚拟内存对应的物理内存已经不再需要，可以重用物理内存；</li><li><code>runtime.sysFault</code>将内存区域转换成保留状态，主要用于运行时的调试；</li></ul><p>​        运行时使用 Linux 提供的 <code>mmap</code>、<code>munmap</code> 和 <code>madvise</code> 等系统调用实现了操作系统的内存管理抽象层，抹平了不同操作系统的差异，为运行时提供了更加方便的接口，除了 Linux 之外，运行时还实现了 BSD、Darwin、Plan9 以及 Windows 等平台上抽象层。</p><h2 id="内存管理组件"><a href="#内存管理组件" class="headerlink" title="内存管理组件"></a>内存管理组件</h2><p>​        Go 语言的内存分配器包含内存管理单元、线程缓存、中心缓存和页堆几个重要组件，本节将介绍这几种最重要组件对应的数据结构 <code>runtime.mspan</code>、<code> runtime.mcache</code>、<code>runtime.mcentral</code>、<code>runtime.mheap</code>，我们会详细介绍它们在内存分配器中的作用以及实现。</p><p><img src="https://img.draveness.me/2020-02-29-15829868066479-go-memory-layout.png" class="lazyload" data-srcset="https://img.draveness.me/2020-02-29-15829868066479-go-memory-layout.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="go-memory-layout"></p><p>​        所有的 Go 语言程序都会在启动时初始化如上图所示的内存布局，每一个处理器都会分配一个线程缓存 <code>runtime.mcache</code>，用于处理微对象和小对象的分配，它们会持有内存管理单元 <code>runtime.mspan</code></p><p>​        每个类型的内存管理单元都会管理特定大小的对象，当内存管理单元中不存在空闲对象时，它们会从 <code>runtime.mheap</code>持有的 134 个中心缓存 <code>runtime.mcentral</code>中获取新的内存单元，中心缓存属于全局的堆结构体 <code>runtime.mheap</code>，它会从操作系统中申请内存。</p><p>​        在 amd64 的 Linux 操作系统上，<code>runtime.mheap</code>会持有 4,194,304 <code>runtime.heapArena</code>，每个 <code>runtime.heapArena</code>都会管理 64MB 的内存，单个 Go 语言程序的内存上限也就是 256TB。</p><h3 id="内存管理单元"><a href="#内存管理单元" class="headerlink" title="内存管理单元"></a>内存管理单元</h3><p><code>runtime.mspan</code>是 Go 语言内存管理的基本单元，该结构体中包含 <code>next</code> 和 <code>prev</code> 两个字段，它们分别指向了前一个和后一个 <code>runtime.mspan</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mspan <span class="keyword">struct</span> &#123;</span><br><span class="line">next *mspan</span><br><span class="line">prev *mspan</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        串联后的上述结构体会构成如下双向链表，运行时会使用 <code>runtime.mSpanList</code>存储双向链表的头结点和尾节点并在线程缓存以及中心缓存中使用。</p><p><img src="https://img.draveness.me/2020-02-29-15829868066485-mspan-and-linked-list.png" class="lazyload" data-srcset="https://img.draveness.me/2020-02-29-15829868066485-mspan-and-linked-list.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="mspan-and-linked-list"></p><p>​        因为相邻的管理单元会互相引用，所以我们可以从任意一个结构体访问双向链表中的其他节点。</p><h4 id="页和内存"><a href="#页和内存" class="headerlink" title="页和内存"></a>页和内存</h4><p>​        每个 <code>runtime.mspan</code>都管理 <code>npages</code> 个大小为 8KB 的页，这里的页不是操作系统中的内存页，它们是操作系统内存页的整数倍，该结构体会使用下面这些字段来管理内存页的分配和回收：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mspan <span class="keyword">struct</span> &#123;</span><br><span class="line">startAddr <span class="keyword">uintptr</span> <span class="comment">// 起始地址</span></span><br><span class="line">npages    <span class="keyword">uintptr</span> <span class="comment">// 页数</span></span><br><span class="line">freeindex <span class="keyword">uintptr</span></span><br><span class="line"></span><br><span class="line">allocBits  *gcBits</span><br><span class="line">gcmarkBits *gcBits</span><br><span class="line">allocCache <span class="keyword">uint64</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>startAddr</code> 和 <code>npages</code> — 确定该结构体管理的多个页所在的内存，每个页的大小都是 8KB；</li><li><code>freeindex</code> — 扫描页中空闲对象的初始索引；</li><li><code>allocBits</code> 和 <code>gcmarkBits</code> — 分别用于标记内存的占用和回收情况；</li><li><code>allocCache</code> — <code>allocBits</code> 的补码，可以用于快速查找内存中未被使用的内存；</li></ul><p>​        <code>runtime.mspan</code>会以两种不同的视角看待管理的内存，当结构体管理的内存不足时，运行时会以页为单位向堆申请内存：</p><p><img src="https://img.draveness.me/2020-02-29-15829868066492-mspan-and-pages.png" class="lazyload" data-srcset="https://img.draveness.me/2020-02-29-15829868066492-mspan-and-pages.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="mspan-and-pages"></p><p>​        当用户程序或者线程向 <code>runtime.mspan</code>申请内存时，它会使用 <code>allocCache</code> 字段以对象为单位在管理的内存中快速查找待分配的空间：</p><p><img src="https://img.draveness.me/2020-02-29-15829868066499-mspan-and-objects.png" class="lazyload" data-srcset="https://img.draveness.me/2020-02-29-15829868066499-mspan-and-objects.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="mspan-and-objects"></p><p>​        如果我们能在内存中找到空闲的内存单元会直接返回，当内存中不包含空闲的内存时，上一级的组件 <code>runtime.mcache</code>会为调用 <code>runtime.mcache.refill</code>更新内存管理单元以满足为更多对象分配内存的需求。</p><h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4><p>​        运行时会使用 <code>runtime.mSpanStateBox</code>存储内存管理单元的状态 <code>runtime.mSpanState</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mspan <span class="keyword">struct</span> &#123;</span><br><span class="line">...</span><br><span class="line">state       mSpanStateBox</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        该状态可能处于 <code>mSpanDead</code>、<code>mSpanInUse</code>、<code>mSpanManual</code> 和 <code>mSpanFree</code> 四种情况。当 <code>runtime.mspan</code>在空闲堆中，它会处于 <code>mSpanFree</code> 状态；当 <code>runtime.mspan</code>已经被分配时，它会处于 <code>mSpanInUse</code>、<code>mSpanManual</code> 状态，运行时会遵循下面的规则转换该状态：</p><ul><li>在垃圾回收的任意阶段，可能从 <code>mSpanFree</code> 转换到 <code>mSpanInUse</code> 和 <code>mSpanManual</code>；</li><li>在垃圾回收的清除阶段，可能从 <code>mSpanInUse</code> 和 <code>mSpanManual</code> 转换到 <code>mSpanFree</code>；</li><li>在垃圾回收的标记阶段，不能从 <code>mSpanInUse</code> 和 <code>mSpanManual</code> 转换到 <code>mSpanFree</code>；</li></ul><p>设置 <code>runtime.mspan</code>状态的操作必须是原子性的以避免垃圾回收造成的线程竞争问题。</p><h4 id="跨度类"><a href="#跨度类" class="headerlink" title="跨度类"></a>跨度类</h4><p><code>runtime.spanClass</code>是<code>runtime.mspan</code>的跨度类，它决定了内存管理单元中存储的对象大小和个数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mspan <span class="keyword">struct</span> &#123;</span><br><span class="line">...</span><br><span class="line">spanclass   spanClass</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        Go 语言的内存管理模块中一共包含 67 种跨度类，每一个跨度类都会存储特定大小的对象并且包含特定数量的页数以及对象，所有的数据都会被预选计算好并存储在 <code>runtime.class_to_size</code>和 <code>runtime.class_to_allocnpages</code>等变量中：</p><table><thead><tr><th align="center">class</th><th align="right">bytes/obj</th><th align="right">bytes/span</th><th align="right">objects</th><th align="center">tail waste</th><th align="center">max waste</th></tr></thead><tbody><tr><td align="center">1</td><td align="right">8</td><td align="right">8192</td><td align="right">1024</td><td align="center">0</td><td align="center">87.50%</td></tr><tr><td align="center">2</td><td align="right">16</td><td align="right">8192</td><td align="right">512</td><td align="center">0</td><td align="center">43.75%</td></tr><tr><td align="center">3</td><td align="right">24</td><td align="right">8192</td><td align="right">341</td><td align="center">0</td><td align="center">29.24%</td></tr><tr><td align="center">4</td><td align="right">32</td><td align="right">8192</td><td align="right">256</td><td align="center">0</td><td align="center">46.88%</td></tr><tr><td align="center">5</td><td align="right">48</td><td align="right">8192</td><td align="right">170</td><td align="center">32</td><td align="center">31.52%</td></tr><tr><td align="center">6</td><td align="right">64</td><td align="right">8192</td><td align="right">128</td><td align="center">0</td><td align="center">23.44%</td></tr><tr><td align="center">7</td><td align="right">80</td><td align="right">8192</td><td align="right">102</td><td align="center">32</td><td align="center">19.07%</td></tr><tr><td align="center">…</td><td align="right">…</td><td align="right">…</td><td align="right">…</td><td align="center">…</td><td align="center">…</td></tr><tr><td align="center">67</td><td align="right">32768</td><td align="right">32768</td><td align="right">1</td><td align="center">0</td><td align="center">12.50%</td></tr></tbody></table><p>​        上表展示了对象大小从 8B 到 32KB，总共 67 种跨度类的大小、存储的对象数以及浪费的内存空间，以表中的第四个跨度类为例，跨度类为 5 的 <code>runtime.mspan</code>中对象的大小上限为 48 字节、管理 1 个页、最多可以存储 170 个对象。因为内存需要按照页进行管理，所以在尾部会浪费 32 字节的内存，当页中存储的对象都是 33 字节时，最多会浪费 31.52% 的资源：</p><p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20211022232330.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20211022232330.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20211022232321306"></p><p><img src="https://img.draveness.me/2020-02-29-15829868066504-mspan-max-waste-memory.png" class="lazyload" data-srcset="https://img.draveness.me/2020-02-29-15829868066504-mspan-max-waste-memory.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="mspan-max-waste-memory"></p><p>​        除了上述 67 个跨度类之外，运行时中还包含 ID 为 0 的特殊跨度类，它能够管理大于 32KB 的特殊对象，我们会在后面详细介绍大对象的分配过程，在这里就不展开说明了。</p><p>​        跨度类中除了存储类别的 ID 之外，它还会存储一个 <code>noscan</code> 标记位，该标记位表示对象是否包含指针，垃圾回收会对包含指针的 <code>runtime.mspan</code>结构体进行扫描。我们可以通过下面的几个函数和方法了解 ID 和标记位的底层存储方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeSpanClass</span><span class="params">(sizeclass <span class="keyword">uint8</span>, noscan <span class="keyword">bool</span>)</span> <span class="title">spanClass</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> spanClass(sizeclass&lt;&lt;<span class="number">1</span>) | spanClass(bool2int(noscan))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sc spanClass)</span> <span class="title">sizeclass</span><span class="params">()</span> <span class="title">int8</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">int8</span>(sc &gt;&gt; <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sc spanClass)</span> <span class="title">noscan</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> sc&amp;<span class="number">1</span> != <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        <code>runtime.spanClass</code>是一个 <code>uint8</code> 类型的整数，它的前 7 位存储着跨度类的 ID，最后一位表示是否包含指针，该类型提供的两个方法能够帮我们快速获取对应的字段。</p><h3 id="线程缓存"><a href="#线程缓存" class="headerlink" title="线程缓存"></a>线程缓存</h3><p><code>runtime.mcache</code>是 Go 语言中的线程缓存，它会与线程上的处理器一一绑定，主要用来缓存用户程序申请的微小对象。每一个线程缓存都持有 68 * 2 个 <code>runtime.mspan</code>，这些内存管理单元都存储在结构体的 <code>alloc</code> 字段中：</p><p><img src="https://img.draveness.me/2020-02-29-15829868066512-mcache-and-mspans.png" class="lazyload" data-srcset="https://img.draveness.me/2020-02-29-15829868066512-mcache-and-mspans.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="mcache-and-mspans"></p><p>​        线程缓存在刚刚被初始化时是不包含 <code>runtime.mspan</code>的，只有当用户程序申请内存时才会从上一级组件获取新的 <code>runtime.mspan</code>满足内存分配的需求。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>运行时在初始化处理器时会调用 <code>runtime.allocmcache</code>初始化线程缓存，该函数会在系统栈中使用 <code>runtime.mheap</code>中的线程缓存分配器初始化新的 <code>runtime.mcache</code>结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">allocmcache</span><span class="params">()</span> *<span class="title">mcache</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> c *mcache</span><br><span class="line">systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">lock(&amp;mheap_.lock)</span><br><span class="line">c = (*mcache)(mheap_.cachealloc.alloc())</span><br><span class="line">c.flushGen = mheap_.sweepgen</span><br><span class="line">unlock(&amp;mheap_.lock)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> c.alloc &#123;</span><br><span class="line">c.alloc[i] = &amp;emptymspan</span><br><span class="line">&#125;</span><br><span class="line">c.nextSample = nextSample()</span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        就像我们在上面提到的，初始化后的 <code>runtime.mcache</code>中的所有 <code>runtime.mspan</code>都是空的占位符 <code>emptymspan</code>。</p><h4 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h4><p>​        <code>runtime.mcache.refill</code>会为线程缓存获取一个指定跨度类的内存管理单元，被替换的单元不能包含空闲的内存空间，而获取的单元中需要至少包含一个空闲对象用于分配内存：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcache)</span> <span class="title">refill</span><span class="params">(spc spanClass)</span></span> &#123;</span><br><span class="line">s := c.alloc[spc]</span><br><span class="line">s = mheap_.central[spc].mcentral.cacheSpan()</span><br><span class="line">c.alloc[spc] = s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        如上述代码所示，该方法会从中心缓存中申请新的 <code>runtime.mspan</code>存储到线程缓存中，这也是向线程缓存插入内存管理单元的唯一方法。</p><h4 id="微分配器"><a href="#微分配器" class="headerlink" title="微分配器"></a>微分配器</h4><p>​        线程缓存中还包含几个用于分配微对象的字段，下面的这三个字段组成了微对象分配器，专门管理 16 字节以下的对象：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mcache <span class="keyword">struct</span> &#123;</span><br><span class="line">tiny             <span class="keyword">uintptr</span></span><br><span class="line">tinyoffset       <span class="keyword">uintptr</span></span><br><span class="line">local_tinyallocs <span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        微分配器只会用于分配非指针类型的内存，上述三个字段中 <code>tiny</code> 会指向堆中的一片内存，<code>tinyOffset</code> 是下一个空闲内存所在的偏移量，最后的 <code>local_tinyallocs</code> 会记录内存分配器中分配的对象个数。</p><h3 id="中心缓存"><a href="#中心缓存" class="headerlink" title="中心缓存"></a>中心缓存</h3><p>​        <code>runtime.mcentral</code>是内存分配器的中心缓存，与线程缓存不同，访问中心缓存中的内存管理单元需要使用互斥锁：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mcentral <span class="keyword">struct</span> &#123;</span><br><span class="line">spanclass spanClass</span><br><span class="line">partial  [<span class="number">2</span>]spanSet</span><br><span class="line">full     [<span class="number">2</span>]spanSet</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        每个中心缓存都会管理某个跨度类的内存管理单元，它会同时持有两个 <code>runtime.spanSet</code>，分别存储包含空闲对象和不包含空闲对象的内存管理单元。</p><h4 id="内存管理单元-1"><a href="#内存管理单元-1" class="headerlink" title="内存管理单元"></a>内存管理单元</h4><p>​        线程缓存会通过中心缓存的 <code>runtime.mcentral.cacheSpan</code>方法获取新的内存管理单元，该方法的实现比较复杂，我们可以将其分成以下几个部分：</p><ol><li><p>调用 <code>runtime.mcentral.partialSwept</code> 从清理过的、包含空闲空间的 <code>runtime.spanSet</code> 结构中查找可以使用的内存管理单元；</p></li><li><p>调用 <code>runtime.mcentral.partialUnswept</code> 从未被清理过的、有空闲对象的 <code>runtime.spanSet</code> 结构中查找可以使用的内存管理单元；</p></li><li><p>调用 <code>runtime.mcentral.fullUnswept</code> 获取未被清理的、不包含空闲空间的 <code>runtime.spanSet</code> 中获取内存管理单元并通过 <code>runtime.mspan.sweep </code>清理它的内存空间；</p></li><li><p>调用 <code>runtime.mcentral.grow</code> 从堆中申请新的内存管理单元；</p></li><li><p>更新内存管理单元的 <code>allocCache</code> 等字段帮助快速分配内存；</p></li></ol><p>​       首先我们会在中心缓存的空闲集合中查找可用的 <code>runtime.mspan</code>，运行时总是会先从获取清理过的内存管理单元，后检查未清理的内存管理单元：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcentral)</span> <span class="title">cacheSpan</span><span class="params">()</span> *<span class="title">mspan</span></span> &#123;</span><br><span class="line">sg := mheap_.sweepgen</span><br><span class="line">spanBudget := <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s *mspan</span><br><span class="line"><span class="keyword">if</span> s = c.partialSwept(sg).pop(); s != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">goto</span> havespan</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ; spanBudget &gt;= <span class="number">0</span>; spanBudget-- &#123;</span><br><span class="line">s = c.partialUnswept(sg).pop()</span><br><span class="line"><span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> atomic.Load(&amp;s.sweepgen) == sg<span class="number">-2</span> &amp;&amp; atomic.Cas(&amp;s.sweepgen, sg<span class="number">-2</span>, sg<span class="number">-1</span>) &#123;</span><br><span class="line">、s.sweep(<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">goto</span> havespan</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        当找到需要回收的内存单元时，运行时会触发<code>runtime.mspan.swee</code>p 进行清理，如果在包含空闲空间的集合中没有找到管理单元，那么运行时尝试会从未清理的集合中获取：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcentral)</span> <span class="title">cacheSpan</span><span class="params">()</span> *<span class="title">mspan</span></span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> ; spanBudget &gt;= <span class="number">0</span>; spanBudget-- &#123;</span><br><span class="line">s = c.fullUnswept(sg).pop()</span><br><span class="line"><span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> atomic.Load(&amp;s.sweepgen) == sg<span class="number">-2</span> &amp;&amp; atomic.Cas(&amp;s.sweepgen, sg<span class="number">-2</span>, sg<span class="number">-1</span>) &#123;</span><br><span class="line">、s.sweep(<span class="literal">true</span>)</span><br><span class="line">、freeIndex := s.nextFreeIndex()</span><br><span class="line"><span class="keyword">if</span> freeIndex != s.nelems &#123;</span><br><span class="line">s.freeindex = freeIndex</span><br><span class="line"><span class="keyword">goto</span> havespan</span><br><span class="line">&#125;</span><br><span class="line">、c.fullSwept(sg).push(s)</span><br><span class="line">&#125;</span><br><span class="line">、&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        如果<code>runtime.mcentral</code>通过上述两个阶段都没有找到可用的单元，它会调用 <code>runtime.mcentral.grow</code> 触发扩容从堆中申请新的内存：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcentral)</span> <span class="title">cacheSpan</span><span class="params">()</span> *<span class="title">mspan</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">s = c.grow()</span><br><span class="line"><span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">havespan:</span><br><span class="line">freeByteBase := s.freeindex &amp;^ (<span class="number">64</span> - <span class="number">1</span>)</span><br><span class="line">whichByte := freeByteBase / <span class="number">8</span></span><br><span class="line">s.refillAllocCache(whichByte)</span><br><span class="line"></span><br><span class="line">s.allocCache &gt;&gt;= s.freeindex % <span class="number">64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        无论通过哪种方法获取到了内存单元，该方法的最后都会更新内存单元的 <code>allocBits</code> 和 <code>allocCache</code> 等字段，让运行时在分配内存时能够快速找到空闲的对象。</p><h4 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h4><p>​        中心缓存的扩容方法 <code>runtime.mcentral.grow</code> 会根据预先计算的 <code>class_to_allocnpages</code> 和 <code>class_to_size</code> 获取待分配的页数以及跨度类并调用 <code>runtime.mheap.alloc</code> 获取新的 <code>runtime.mspan</code> 结构：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcentral)</span> <span class="title">grow</span><span class="params">()</span> *<span class="title">mspan</span></span> &#123;</span><br><span class="line">npages := <span class="keyword">uintptr</span>(class_to_allocnpages[c.spanclass.sizeclass()])</span><br><span class="line">size := <span class="keyword">uintptr</span>(class_to_size[c.spanclass.sizeclass()])</span><br><span class="line"></span><br><span class="line">s := mheap_.alloc(npages, c.spanclass, <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">n := (npages &lt;&lt; _PageShift) &gt;&gt; s.divShift * <span class="keyword">uintptr</span>(s.divMul) &gt;&gt; s.divShift2</span><br><span class="line">s.limit = s.base() + size*n</span><br><span class="line">heapBitsForAddr(s.base()).initSpan(s)</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取了 <code>runtime.mspan</code> 后，我们会在上述方法中初始化 limit 字段并清除该结构在堆上对应的位图。</p><h3 id="页堆"><a href="#页堆" class="headerlink" title="页堆"></a>页堆</h3><p>​        <code>runtime.mheap</code> 是内存分配的核心结构体，Go 语言程序会将其作为全局变量存储，而堆上初始化的所有对象都由该结构体统一管理，该结构体中包含两组非常重要的字段，其中一个是全局的中心缓存列表 <code>central</code>，另一个是管理堆区内存区域的 <code>arenas</code> 以及相关字段。</p><p>​        页堆中包含一个长度为 136 的 <code>runtime.mcentral</code> 数组，其中 68 个为跨度类需要 <code>scan</code> 的中心缓存，另外的 68 个是 <code>noscan</code> 的中心缓存：</p><p><img src="https://img.draveness.me/2020-02-29-15829868066525-mheap-and-mcentrals.png" class="lazyload" data-srcset="https://img.draveness.me/2020-02-29-15829868066525-mheap-and-mcentrals.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="mheap-and-mcentrals"></p><p>​        我们在设计原理一节中已经介绍过 Go 语言所有的内存空间都由如下所示的二维矩阵 <code>runtime.heapArena</code> 管理，这个二维矩阵管理的内存可以是不连续的：</p><p><img src="https://img.draveness.me/2020-02-29-15829868066531-mheap-and-memories.png" class="lazyload" data-srcset="https://img.draveness.me/2020-02-29-15829868066531-mheap-and-memories.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="mheap-and-memories"></p><p>​        在除了 Windows 以外的 64 位操作系统中，每一个 <code>runtime.heapArena</code> 都会管理 64MB 的内存空间，如下所示的表格展示了不同平台上 Go 语言程序管理的堆区大小以及 <code>runtime.heapArena</code> 占用的内存空间：</p><table><thead><tr><th align="right">平台</th><th align="right">地址位数</th><th align="right">Arena 大小</th><th align="right">一维大小</th><th align="right">二维大小</th></tr></thead><tbody><tr><td align="right">*/64-bit</td><td align="right">48</td><td align="right">64MB</td><td align="right">1</td><td align="right">4M (32MB)</td></tr><tr><td align="right">windows/64-bit</td><td align="right">48</td><td align="right">4MB</td><td align="right">64</td><td align="right">1M (8MB)</td></tr><tr><td align="right">*/32-bit</td><td align="right">32</td><td align="right">4MB</td><td align="right">1</td><td align="right">1024 (4KB)</td></tr><tr><td align="right">*/mips(le)</td><td align="right">31</td><td align="right">4MB</td><td align="right">1</td><td align="right">512 (2KB)</td></tr></tbody></table><p>​        本节将介绍页堆的初始化、内存分配以及内存管理单元分配的过程，这些过程能够帮助我们理解全局变量页堆与其他组件的关系以及它管理内存的方式。</p><h4 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h4><p>​        堆区的初始化会使用<code> runtime.mheap.init</code> 方法，我们能看到该方法初始化了非常多的结构体和字段，不过其中初始化的两类变量比较重要：</p><ol><li><code>spanalloc</code>、<code>cachealloc</code> 以及 <code>arenaHintAlloc</code> 等 <code>runtime.fixalloc</code>类型的空闲链表分配器；</li><li><code>central</code> 切片中 <code>runtime.mcentral</code>类型的中心缓存；</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">h.spanalloc.init(unsafe.Sizeof(mspan&#123;&#125;), recordspan, unsafe.Pointer(h), &amp;memstats.mspan_sys)</span><br><span class="line">h.cachealloc.init(unsafe.Sizeof(mcache&#123;&#125;), <span class="literal">nil</span>, <span class="literal">nil</span>, &amp;memstats.mcache_sys)</span><br><span class="line">h.specialfinalizeralloc.init(unsafe.Sizeof(specialfinalizer&#123;&#125;), <span class="literal">nil</span>, <span class="literal">nil</span>, &amp;memstats.other_sys)</span><br><span class="line">h.specialprofilealloc.init(unsafe.Sizeof(specialprofile&#123;&#125;), <span class="literal">nil</span>, <span class="literal">nil</span>, &amp;memstats.other_sys)</span><br><span class="line">h.arenaHintAlloc.init(unsafe.Sizeof(arenaHint&#123;&#125;), <span class="literal">nil</span>, <span class="literal">nil</span>, &amp;memstats.other_sys)</span><br><span class="line"></span><br><span class="line">h.spanalloc.zero = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> h.central &#123;</span><br><span class="line">h.central[i].mcentral.init(spanClass(i))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">h.pages.init(&amp;h.lock, &amp;memstats.gc_sys)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        堆中初始化的多个空闲链表分配器与设计原理中提到的分配器没有太多区别，当我们调用 <code>runtime.fixalloc.init</code> 初始化分配器时，需要传入待初始化的结构体大小等信息，这会帮助分配器分割待分配的内存，它提供了以下两个用于分配和释放内存的方法：</p><ol><li><code>runtime.fixalloc.alloc</code>  — 获取下一个空闲的内存空间；</li><li><code>runtime.fixalloc.free </code> — 释放指针指向的内存空间；</li></ol><p>​        除了这些空闲链表分配器之外，我们还会在该方法中初始化所有的中心缓存，这些中心缓存会维护全局的内存管理单元，各个线程会通过中心缓存获取新的内存单元。</p><h4 id="内存管理单元-2"><a href="#内存管理单元-2" class="headerlink" title="内存管理单元"></a>内存管理单元</h4><p>​        <code>runtime.mheap</code> 是内存分配器中的核心组件，运行时会通过它的 <code>runtime.mheap.alloc</code> 方法在系统栈中获取新的 <code>runtime.mspan</code> 单元：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span> <span class="title">alloc</span><span class="params">(npages <span class="keyword">uintptr</span>, spanclass spanClass, needzero <span class="keyword">bool</span>)</span> *<span class="title">mspan</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> s *mspan</span><br><span class="line">systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> h.sweepdone == <span class="number">0</span> &#123;</span><br><span class="line">h.reclaim(npages)</span><br><span class="line">&#125;</span><br><span class="line">s = h.allocSpan(npages, <span class="literal">false</span>, spanclass, &amp;memstats.heap_inuse)</span><br><span class="line">&#125;)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        为了阻止内存的大量占用和堆的增长，我们在分配对应页数的内存前需要先调用 <code>runtime.mheap.reclaim</code> 方法回收一部分内存，随后运行时通过 <code>runtime.mheap.allocSpan</code> 分配新的内存管理单元，我们会将该方法的执行过程拆分成两个部分：</p><ol><li>从堆上分配新的内存页和内存管理单元 <code>runtime.mspan</code>；</li><li>初始化内存管理单元并将其加入 <code>runtime.mheap</code> 持有内存单元列表；</li></ol><p>首先我们需要在堆上申请 <code>npages</code> 数量的内存页并初始化 <code>runtime.mspan</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span> <span class="title">allocSpan</span><span class="params">(npages <span class="keyword">uintptr</span>, typ spanAllocType, spanclass spanClass)</span> <span class="params">(s *mspan)</span></span> &#123;</span><br><span class="line">gp := getg()</span><br><span class="line">base, scav := <span class="keyword">uintptr</span>(<span class="number">0</span>), <span class="keyword">uintptr</span>(<span class="number">0</span>)</span><br><span class="line">pp := gp.m.p.ptr()</span><br><span class="line"><span class="keyword">if</span> pp != <span class="literal">nil</span> &amp;&amp; npages &lt; pageCachePages/<span class="number">4</span> &#123;</span><br><span class="line">c := &amp;pp.pcache</span><br><span class="line">base, scav = c.alloc(npages)</span><br><span class="line"><span class="keyword">if</span> base != <span class="number">0</span> &#123;</span><br><span class="line">s = h.tryAllocMSpan()</span><br><span class="line"><span class="keyword">if</span> s != <span class="literal">nil</span> &amp;&amp; gcBlackenEnabled == <span class="number">0</span> &amp;&amp; (manual || spanclass.sizeclass() != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">goto</span> HaveSpan</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> base == <span class="number">0</span> &#123;</span><br><span class="line">base, scav = h.pages.alloc(npages)</span><br><span class="line"><span class="keyword">if</span> base == <span class="number">0</span> &#123;</span><br><span class="line">h.grow(npages)</span><br><span class="line">            base, scav = h.pages.alloc(npages)</span><br><span class="line"><span class="keyword">if</span> base == <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">&quot;grew heap, but no adequate free space found&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">s = h.allocMSpanLocked()</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        上述方法会通过处理器的页缓存 <code>runtime.pageCache</code> 或者全局的页分配器 <code>runtime.pageAlloc</code> 两种途径从堆中申请内存：</p><ol><li><p>如果申请的内存比较小，获取申请内存的处理器并尝试调用 <code>runtime.pageCache.alloc</code>获取内存区域的基地址和大小；</p></li><li><p>如果申请的内存比较大或者线程的页缓存中内存不足，会通过 <code>runtime.pageAlloc.alloc</code>在页堆上申请内存；</p></li><li><p>如果发现页堆上的内存不足，会尝试通过<code>runtime.mheap.grow</code> 扩容并重新调用<code>runtime.pageAlloc.alloc</code>申请内存；</p><ol><li>如果申请到内存，意味着扩容成功；</li><li>如果没有申请到内存，意味着扩容失败，宿主机可能不存在空闲内存，运行时会直接中止当前程序；</li></ol></li></ol><p>​        无论通过哪种方式获得内存页，我们都会在该函数中分配新的 <code>runtime.mspan</code> 结构体；该方法的剩余部分会通过页数、内存空间以及跨度类等参数初始化它的多个字段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span> <span class="title">alloc</span><span class="params">(npages <span class="keyword">uintptr</span>, spanclass spanClass, needzero <span class="keyword">bool</span>)</span> *<span class="title">mspan</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">HaveSpan:</span><br><span class="line">s.init(base, npages)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">s.freeindex = <span class="number">0</span></span><br><span class="line">s.allocCache = ^<span class="keyword">uint64</span>(<span class="number">0</span>)</span><br><span class="line">s.gcmarkBits = newMarkBits(s.nelems)</span><br><span class="line">s.allocBits = newAllocBits(s.nelems)</span><br><span class="line">h.setSpans(s.base(), npages, s)</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，我们通过调用 <code>runtime.mspan.init</code> 设置参数初始化刚刚分配的 <code>runtime.mspan</code> 结构并通过 <code>runtime.mheaps.setSpans</code> 建立页堆与内存单元的联系。</p><h4 id="扩容-1"><a href="#扩容-1" class="headerlink" title="扩容"></a>扩容</h4><p>​        <code>runtime.mheap.grow</code> 会向操作系统申请更多的内存空间，传入的页数经过对齐可以得到期望的内存大小，我们可以将该方法的执行过程分成以下几个部分：</p><ol><li>通过传入的页数获取期望分配的内存空间大小以及内存的基地址；</li><li>如果 <code>arena</code> 区域没有足够的空间，调用 <code>runtime.mheap.sysAlloc</code>从操作系统中申请更多的内存；</li><li>扩容 <code>runtime.mheap </code>持有的 <code>arena</code> 区域并更新页分配器的元信息；</li><li>在某些场景下，调用 <code>runtime.pageAlloc.scavenge</code>回收不再使用的空闲内存页；</li></ol><p>​        在页堆扩容的过程中，<code>runtime.mheap.sysAlloc</code>是页堆用来申请虚拟内存的方法，我们会分几部分介绍该方法的实现。首先，该方法会尝试在预保留的区域申请内存：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span> <span class="title">sysAlloc</span><span class="params">(n <span class="keyword">uintptr</span>)</span> <span class="params">(v unsafe.Pointer, size <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line">n = alignUp(n, heapArenaBytes)</span><br><span class="line"></span><br><span class="line">v = h.arena.alloc(n, heapArenaBytes, &amp;memstats.heap_sys)</span><br><span class="line"><span class="keyword">if</span> v != <span class="literal">nil</span> &#123;</span><br><span class="line">size = n</span><br><span class="line"><span class="keyword">goto</span> mapped</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        上述代码会调用线性分配器的 <code>runtime.linearAlloc.alloc</code> 在预先保留的内存中申请一块可以使用的空间。如果没有可用的空间，我们会根据页堆的<code>arenaHints</code>在目标地址上尝试扩容：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span> <span class="title">sysAlloc</span><span class="params">(n <span class="keyword">uintptr</span>)</span> <span class="params">(v unsafe.Pointer, size <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> h.arenaHints != <span class="literal">nil</span> &#123;</span><br><span class="line">hint := h.arenaHints</span><br><span class="line">p := hint.addr</span><br><span class="line">v = sysReserve(unsafe.Pointer(p), n)</span><br><span class="line"><span class="keyword">if</span> p == <span class="keyword">uintptr</span>(v) &#123;</span><br><span class="line">hint.addr = p</span><br><span class="line">size = n</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">h.arenaHints = hint.next</span><br><span class="line">h.arenaHintAlloc.free(unsafe.Pointer(hint))</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">sysMap(v, size, &amp;memstats.heap_sys)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        <code>runtime.sysReserve</code> 和<code> runtime.sysMap</code> 是上述代码的核心部分，它们会从操作系统中申请内存并将内存转换至 <code>Prepared </code>状态。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span> <span class="title">sysAlloc</span><span class="params">(n <span class="keyword">uintptr</span>)</span> <span class="params">(v unsafe.Pointer, size <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">mapped:</span><br><span class="line"><span class="keyword">for</span> ri := arenaIndex(<span class="keyword">uintptr</span>(v)); ri &lt;= arenaIndex(<span class="keyword">uintptr</span>(v)+size<span class="number">-1</span>); ri++ &#123;</span><br><span class="line">l2 := h.arenas[ri.l1()]</span><br><span class="line">r := (*heapArena)(h.heapArenaAlloc.alloc(unsafe.Sizeof(*r), sys.PtrSize, &amp;memstats.gc_sys))</span><br><span class="line">...</span><br><span class="line">h.allArenas = h.allArenas[:<span class="built_in">len</span>(h.allArenas)+<span class="number">1</span>]</span><br><span class="line">h.allArenas[<span class="built_in">len</span>(h.allArenas)<span class="number">-1</span>] = ri</span><br><span class="line">atomic.StorepNoWB(unsafe.Pointer(&amp;l2[ri.l2()]), unsafe.Pointer(r))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        <code>runtime.mheap.sysAlloc</code> 方法在最后会初始化一个新的 <code>runtime.heapArena</code> 来管理刚刚申请的内存空间，该结构会被加入页堆的二维矩阵中。</p><h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p>​        堆上所有的对象都会通过调用<code> runtime.newobject</code> 函数分配内存，该函数会调用 <code>runtime.mallocgc </code>分配指定大小的内存空间，这也是用户程序向堆上申请内存空间的必经函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocgc</span><span class="params">(size <span class="keyword">uintptr</span>, typ *_type, needzero <span class="keyword">bool</span>)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">mp := acquirem()</span><br><span class="line">mp.mallocing = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">c := gomcache()</span><br><span class="line"><span class="keyword">var</span> x unsafe.Pointer</span><br><span class="line">noscan := typ == <span class="literal">nil</span> || typ.ptrdata == <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> size &lt;= maxSmallSize &#123;</span><br><span class="line"><span class="keyword">if</span> noscan &amp;&amp; size &lt; maxTinySize &#123;</span><br><span class="line"><span class="comment">// 微对象分配</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 小对象分配</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 大对象分配</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">publicationBarrier()</span><br><span class="line">mp.mallocing = <span class="number">0</span></span><br><span class="line">releasem(mp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        上述代码使用 <code>runtime.gomcache</code>获取线程缓存并判断申请内存的类型是否为指针。我们从这个代码片段可以看出 <code>runtime.mallocgc</code> 会根据对象的大小执行不同的分配逻辑，在前面的章节也曾经介绍过运行时根据对象大小将它们分成微对象、小对象和大对象，这里会根据大小选择不同的分配逻辑：</p><p><img src="https://img.draveness.me/2020-02-29-15829868066537-allocator-and-memory-size.png" class="lazyload" data-srcset="https://img.draveness.me/2020-02-29-15829868066537-allocator-and-memory-size.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="allocator-and-memory-size"></p><ul><li>微对象 <code>(0, 16B)</code> — 先使用微型分配器，再依次尝试线程缓存、中心缓存和堆分配内存；</li><li>小对象 <code>[16B, 32KB]</code> — 依次尝试使用线程缓存、中心缓存和堆分配内存；</li><li>大对象 <code>(32KB, +∞)</code> — 直接在堆上分配内存；</li></ul><h3 id="微对象"><a href="#微对象" class="headerlink" title="微对象"></a>微对象</h3><p>​        Go 语言运行时将小于 16 字节的对象划分为微对象，它会使用线程缓存上的微分配器提高微对象分配的性能，我们主要使用它来分配较小的字符串以及逃逸的临时变量。微分配器可以将多个较小的内存分配请求合入同一个内存块中，只有当内存块中的所有对象都需要被回收时，整片内存才可能被回收。</p><p>​        微分配器管理的对象不可以是指针类型，管理多个对象的内存块大小 <code>maxTinySize</code> 是可以调整的，在默认情况下，内存块的大小为 16 字节。<code>maxTinySize</code> 的值越大，组合多个对象的可能性就越高，内存浪费也就越严重；<code>maxTinySize</code> 越小，内存浪费就会越少，不过无论如何调整，8 的倍数都是一个很好的选择。</p><p><img src="https://img.draveness.me/2020-02-29-15829868066543-tiny-allocator.png" class="lazyload" data-srcset="https://img.draveness.me/2020-02-29-15829868066543-tiny-allocator.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="tiny-allocator"></p><p>​        如上图所示，微分配器已经在 16 字节的内存块中分配了 12 字节的对象，如果下一个待分配的对象小于 4 字节，它会直接使用上述内存块的剩余部分，减少内存碎片，不过该内存块只有所有对象都被标记为垃圾时才会回收。</p><p>​        线程缓存 <code>runtime.mcache</code> 中的 <code>tiny </code>字段指向了 <code>maxTinySize</code> 大小的块，如果当前块中还包含大小合适的空闲内存，运行时会通过基地址和偏移量获取并返回这块内存：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocgc</span><span class="params">(size <span class="keyword">uintptr</span>, typ *_type, needzero <span class="keyword">bool</span>)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> size &lt;= maxSmallSize &#123;</span><br><span class="line"><span class="keyword">if</span> noscan &amp;&amp; size &lt; maxTinySize &#123;</span><br><span class="line">off := c.tinyoffset</span><br><span class="line"><span class="keyword">if</span> off+size &lt;= maxTinySize &amp;&amp; c.tiny != <span class="number">0</span> &#123;</span><br><span class="line">x = unsafe.Pointer(c.tiny + off)</span><br><span class="line">c.tinyoffset = off + size</span><br><span class="line">c.local_tinyallocs++</span><br><span class="line">releasem(mp)</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        当内存块中不包含空闲的内存时，下面的这段代码会先从线程缓存找到跨度类对应的内存管理单元 <code>runtime.mspan</code>，调用 <code>runtime.nextFreeFast</code> 获取空闲的内存；当不存在空闲内存时，我们会调用 <code>runtime.mcache.nextFree</code> 从中心缓存或者页堆中获取可分配的内存块：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocgc</span><span class="params">(size <span class="keyword">uintptr</span>, typ *_type, needzero <span class="keyword">bool</span>)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> size &lt;= maxSmallSize &#123;</span><br><span class="line"><span class="keyword">if</span> noscan &amp;&amp; size &lt; maxTinySize &#123;</span><br><span class="line">...</span><br><span class="line">span := c.alloc[tinySpanClass]</span><br><span class="line">v := nextFreeFast(span)</span><br><span class="line"><span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">v, _, _ = c.nextFree(tinySpanClass)</span><br><span class="line">&#125;</span><br><span class="line">x = unsafe.Pointer(v)</span><br><span class="line">(*[<span class="number">2</span>]<span class="keyword">uint64</span>)(x)[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">(*[<span class="number">2</span>]<span class="keyword">uint64</span>)(x)[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> size &lt; c.tinyoffset || c.tiny == <span class="number">0</span> &#123;</span><br><span class="line">c.tiny = <span class="keyword">uintptr</span>(x)</span><br><span class="line">c.tinyoffset = size</span><br><span class="line">&#125;</span><br><span class="line">size = maxTinySize</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        获取新的空闲内存块之后，上述代码会清空空闲内存中的数据、更新构成微对象分配器的几个字段 <code>tiny</code> 和 <code>tinyoffset</code> 并返回新的空闲内存。</p><h3 id="小对象"><a href="#小对象" class="headerlink" title="小对象"></a>小对象</h3><p>​        小对象是指大小为 16 字节到 32,768 字节的对象以及所有小于 16 字节的指针类型的对象，小对象的分配可以被分成以下的三个步骤：</p><ol><li>确定分配对象的大小以及跨度类 <code>runtime.spanClass</code>;</li><li>从线程缓存、中心缓存或者堆中获取内存管理单元并从内存管理单元找到空闲的内存空间；</li><li>调用 <code>runtime.memclrNoHeapPointers </code>清空空闲内存中的所有数据；</li></ol><p>​        确定待分配的对象大小以及跨度类需要使用预先计算好的 <code>size_to_class8</code>、<code>size_to_class128</code> 以及 <code>class_to_size</code> 字典，这些字典能够帮助我们快速获取对应的值并构建 <code>runtime.spanClass</code>;</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocgc</span><span class="params">(size <span class="keyword">uintptr</span>, typ *_type, needzero <span class="keyword">bool</span>)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> size &lt;= maxSmallSize &#123;</span><br><span class="line">...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">var</span> sizeclass <span class="keyword">uint8</span></span><br><span class="line"><span class="keyword">if</span> size &lt;= smallSizeMax<span class="number">-8</span> &#123;</span><br><span class="line">sizeclass = size_to_class8[(size+smallSizeDiv<span class="number">-1</span>)/smallSizeDiv]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">sizeclass = size_to_class128[(size-smallSizeMax+largeSizeDiv<span class="number">-1</span>)/largeSizeDiv]</span><br><span class="line">&#125;</span><br><span class="line">size = <span class="keyword">uintptr</span>(class_to_size[sizeclass])</span><br><span class="line">spc := makeSpanClass(sizeclass, noscan)</span><br><span class="line">span := c.alloc[spc]</span><br><span class="line">v := nextFreeFast(span)</span><br><span class="line"><span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">v, span, _ = c.nextFree(spc)</span><br><span class="line">&#125;</span><br><span class="line">x = unsafe.Pointer(v)</span><br><span class="line"><span class="keyword">if</span> needzero &amp;&amp; span.needzero != <span class="number">0</span> &#123;</span><br><span class="line">memclrNoHeapPointers(unsafe.Pointer(v), size)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        在上述代码片段中，我们会重点分析两个方法的实现原理，它们分别是 <code>runtime.nextFreeFas</code>t 和 <code>runtime.mcache.nextFree</code>，这两个方法会帮助我们获取空闲的内存空间。<code>runtime.nextFreeFast </code>会利用内存管理单元中的 <code>allocCache</code> 字段，快速找到该字段为 1 的位数，我们在上面介绍过 1 表示该位对应的内存空间是空闲的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nextFreeFast</span><span class="params">(s *mspan)</span> <span class="title">gclinkptr</span></span> &#123;</span><br><span class="line">theBit := sys.Ctz64(s.allocCache)</span><br><span class="line"><span class="keyword">if</span> theBit &lt; <span class="number">64</span> &#123;</span><br><span class="line">result := s.freeindex + <span class="keyword">uintptr</span>(theBit)</span><br><span class="line"><span class="keyword">if</span> result &lt; s.nelems &#123;</span><br><span class="line">freeidx := result + <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> freeidx%<span class="number">64</span> == <span class="number">0</span> &amp;&amp; freeidx != s.nelems &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">s.allocCache &gt;&gt;= <span class="keyword">uint</span>(theBit + <span class="number">1</span>)</span><br><span class="line">s.freeindex = freeidx</span><br><span class="line">s.allocCount++</span><br><span class="line"><span class="keyword">return</span> gclinkptr(result*s.elemsize + s.base())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        找到了空闲的对象后，我们就可以更新内存管理单元的 <code>allocCache</code>、<code>freeindex</code> 等字段并返回该片内存；如果我们没有找到空闲的内存，运行时会通过<code> runtime.mcache.nextFree</code> 找到新的内存管理单元：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcache)</span> <span class="title">nextFree</span><span class="params">(spc spanClass)</span> <span class="params">(v gclinkptr, s *mspan, shouldhelpgc <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">s = c.alloc[spc]</span><br><span class="line">freeIndex := s.nextFreeIndex()</span><br><span class="line"><span class="keyword">if</span> freeIndex == s.nelems &#123;</span><br><span class="line">c.refill(spc)</span><br><span class="line">s = c.alloc[spc]</span><br><span class="line">freeIndex = s.nextFreeIndex()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">v = gclinkptr(freeIndex*s.elemsize + s.base())</span><br><span class="line">s.allocCount++</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        在上述方法中，如果我们在线程缓存中没有找到可用的内存管理单元，会通过前面介绍的 <code>runtime.mcache.refill</code> 使用中心缓存中的内存管理单元替换已经不存在可用对象的结构体，该方法会调用新结构体的 <code>runtime.mspan.nextFreeIndex</code> 获取空闲的内存并返回。</p><h3 id="大对象"><a href="#大对象" class="headerlink" title="大对象"></a>大对象</h3><p>​        运行时对于大于 32KB 的大对象会单独处理，我们不会从线程缓存或者中心缓存中获取内存管理单元，而是直接调用 <code>runtime.mcache.allocLarge</code>分配大片内存：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocgc</span><span class="params">(size <span class="keyword">uintptr</span>, typ *_type, needzero <span class="keyword">bool</span>)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> size &lt;= maxSmallSize &#123;</span><br><span class="line">...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">var</span> s *mspan</span><br><span class="line">span = c.allocLarge(size, needzero, noscan)</span><br><span class="line">span.freeindex = <span class="number">1</span></span><br><span class="line">span.allocCount = <span class="number">1</span></span><br><span class="line">x = unsafe.Pointer(span.base())</span><br><span class="line">size = span.elemsize</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">publicationBarrier()</span><br><span class="line">mp.mallocing = <span class="number">0</span></span><br><span class="line">releasem(mp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>runtime.mcache.allocLarge</code> 会计算分配该对象所需要的页数，它按照 8KB 的倍数在堆上申请内存：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcache)</span> <span class="title">allocLarge</span><span class="params">(size <span class="keyword">uintptr</span>, needzero <span class="keyword">bool</span>, noscan <span class="keyword">bool</span>)</span> *<span class="title">mspan</span></span> &#123;</span><br><span class="line">npages := size &gt;&gt; _PageShift</span><br><span class="line"><span class="keyword">if</span> size&amp;_PageMask != <span class="number">0</span> &#123;</span><br><span class="line">npages++</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">s := mheap_.alloc(npages, spc, needzero)</span><br><span class="line">mheap_.central[spc].mcentral.fullSwept(mheap_.sweepgen).push(s)</span><br><span class="line">s.limit = s.base() + size</span><br><span class="line">heapBitsForAddr(s.base()).initSpan(s)</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        申请内存时会创建一个跨度类为 0 的 <code>runtime.spanClass</code> 并调用 <code>runtime.mheap.alloc </code>分配一个管理对应内存的管理单元。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>​        内存分配是 Go 语言运行时内存管理的核心逻辑，运行时的内存分配器使用类似 <code>TCMalloc</code> 的分配策略将对象根据大小分类，并设计多层级的组件提高内存分配器的性能。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Go 语言内存分配器的实现原理的简单理解&lt;/p&gt;</summary>
    
    
    
    <category term="Go" scheme="http://xucoud.github.io/categories/Go/"/>
    
    <category term="内存分配" scheme="http://xucoud.github.io/categories/Go/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    
    
    <category term="Go" scheme="http://xucoud.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>GC垃圾回收</title>
    <link href="http://xucoud.github.io/2021/10/21/GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <id>http://xucoud.github.io/2021/10/21/GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</id>
    <published>2021-10-21T14:46:08.000Z</published>
    <updated>2021-12-03T15:39:13.604Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Go中垃圾收集器的详细介绍。</p><span id="more"></span><p>​        编程语言的内存管理系统除了负责堆内存的分配之外，它还需要负责回收不再使用的对象和内存空间，这个功能就需要用到垃圾收集器来实现。</p><p>​        在几乎所有的现代编程语言中，垃圾收集器都是一个复杂的系统，为了在不影响用户程序的情况下回收废弃的内存需要付出非常多的努力，Java 的垃圾收集机制是一个很好的例子，Java 8 中包含线性、并发、并行标记清除和 G1 四个垃圾收集器，想要理解它们的工作原理和实现细节需要花费很多的精力。</p><h2 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h2><p>​        今天的编程语言通常会使用手动和自动两种方式管理内存，C、C++ 以及 Rust 等编程语言使用手动的方式管理内存，工程师需要主动申请或者释放内存；而 Python、Ruby、Java 和 Go 等语言使用自动的内存管理系统，一般都是垃圾收集机制，不过 Objective-C 却选择了自动引用计数，虽然引用计数也是自动的内存管理机制，但是我们在这里不会详细介绍它，本节的重点还是垃圾收集。</p><p>​        相信很多人对垃圾收集器的印象都是暂停程序（Stop the world，STW），随着用户程序申请越来越多的内存，系统中的垃圾也逐渐增多；当程序的内存占用达到一定阈值时，整个应用程序就会全部暂停，垃圾收集器会扫描已经分配的所有对象并回收不再使用的内存空间，当这个过程结束后，用户程序才可以继续执行，Go 语言在早期也使用这种策略实现垃圾收集，但是今天的实现已经复杂了很多。</p><p><img src="https://img.draveness.me/2020-03-16-15843705141774-mutator-allocator-collector.png" class="lazyload" data-srcset="https://img.draveness.me/2020-03-16-15843705141774-mutator-allocator-collector.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="mutator-allocator-collector"></p><p>​        在上图中，用户程序（Mutator）会通过内存分配器（Allocator）在堆上申请内存，而垃圾收集器（Collector）负责回收堆上的内存空间，内存分配器和垃圾收集器共同管理着程序中的堆内存空间。</p><h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><p>​        标记清除（Mark-Sweep）算法是最常见的垃圾收集算法，标记清除收集器是跟踪式垃圾收集器，其执行过程可以分成标记（Mark）和清除（Sweep）两个阶段：</p><ol><li>标记阶段 — 从根对象出发查找并标记堆中所有存活的对象；</li><li>清除阶段 — 遍历堆中的全部对象，回收未被标记的垃圾对象并将回收的内存加入空闲链表；</li></ol><p>​        如下图所示，内存空间中包含多个对象，我们从根对象出发依次遍历对象的子对象并将从根节点可达的对象都标记成存活状态，即 A、C 和 D 三个对象，剩余的 B、E 和 F 三个对象因为从根节点不可达，所以会被当做垃圾：</p><p><img src="https://img.draveness.me/2020-03-16-15843705141797-mark-sweep-mark-phase.png" class="lazyload" data-srcset="https://img.draveness.me/2020-03-16-15843705141797-mark-sweep-mark-phase.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="mark-sweep-mark-phase"></p><p>​        标记阶段结束后会进入清除阶段，在该阶段中收集器会依次遍历堆中的所有对象，释放其中没有被标记的 B、E 和 F 三个对象并将新的空闲内存空间以链表的结构串联起来，方便内存分配器的使用。</p><p><img src="https://img.draveness.me/2020-03-16-15843705141803-mark-sweep-sweep-phase.png" class="lazyload" data-srcset="https://img.draveness.me/2020-03-16-15843705141803-mark-sweep-sweep-phase.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="mark-sweep-sweep-phase"></p><p>​        这里介绍的是最传统的标记清除算法，垃圾收集器从垃圾收集的根对象出发，递归遍历这些对象指向的子对象并将所有可达的对象标记成存活；标记阶段结束后，垃圾收集器会依次遍历堆中的对象并清除其中的垃圾，整个过程需要标记对象的存活状态，用户程序在垃圾收集的过程中也不能执行，我们需要用到更复杂的机制来解决 STW 的问题。</p><h3 id="三色抽象"><a href="#三色抽象" class="headerlink" title="三色抽象"></a>三色抽象</h3><p>​        为了解决原始标记清除算法带来的长时间 STW，多数现代的追踪式垃圾收集器都会实现三色标记算法的变种以缩短 STW 的时间。三色标记算法将程序中的对象分成<code>白色</code>、<code>黑色</code>和<code>灰色</code>三类：</p><ul><li>白色对象 — 潜在的垃圾，其内存可能会被垃圾收集器回收；</li><li>黑色对象 — 活跃的对象，包括不存在任何引用外部指针的对象以及从根对象可达的对象；</li><li>灰色对象 — 活跃的对象，因为存在指向白色对象的外部指针，垃圾收集器会扫描这些对象的子对象；</li></ul><p><img src="https://img.draveness.me/2020-03-16-15843705141808-tri-color-objects.png" class="lazyload" data-srcset="https://img.draveness.me/2020-03-16-15843705141808-tri-color-objects.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="tri-color-objects"></p><p>​        在垃圾收集器开始工作时，程序中不存在任何的黑色对象，垃圾收集的根对象会被标记成灰色，垃圾收集器只会从灰色对象集合中取出对象开始扫描，当灰色集合中不存在任何对象时，标记阶段就会结束。</p><p><img src="https://img.draveness.me/2020-03-16-15843705141814-tri-color-mark-sweep.png" class="lazyload" data-srcset="https://img.draveness.me/2020-03-16-15843705141814-tri-color-mark-sweep.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="tri-color-mark-sweep"></p><p>三色标记垃圾收集器的工作原理很简单，我们可以将其归纳成以下几个步骤：</p><ol><li>从灰色对象的集合中选择一个灰色对象并将其标记成黑色；</li><li>将黑色对象指向的所有对象都标记成灰色，保证该对象和被该对象引用的对象都不会被回收；</li><li>重复上述两个步骤直到对象图中不存在灰色对象；</li></ol><p>​        当三色的标记清除的标记阶段结束之后，应用程序的堆中就不存在任何的灰色对象，我们只能看到黑色的存活对象以及白色的垃圾对象，垃圾收集器可以回收这些白色的垃圾，下面是使用三色标记垃圾收集器执行标记后的堆内存，堆中只有对象 D 为待回收的垃圾：</p><p><img src="https://img.draveness.me/2020-03-16-15843705141821-tri-color-mark-sweep-after-mark-phase.png" class="lazyload" data-srcset="https://img.draveness.me/2020-03-16-15843705141821-tri-color-mark-sweep-after-mark-phase.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="tri-color-mark-sweep-after-mark-phase"></p><p>​        因为用户程序可能在标记执行的过程中修改对象的指针，所以三色标记清除算法本身是不可以并发或者增量执行的，它仍然需要 STW，在如下所示的三色标记过程中，用户程序建立了从 A 对象到 D 对象的引用，但是因为程序中已经不存在灰色对象了，所以 D 对象会被垃圾收集器错误地回收。</p><p><img src="https://img.draveness.me/2020-03-16-15843705141828-tri-color-mark-sweep-and-mutator.png" class="lazyload" data-srcset="https://img.draveness.me/2020-03-16-15843705141828-tri-color-mark-sweep-and-mutator.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="tri-color-mark-sweep-and-mutator"></p><p>​        本来不应该被回收的对象却被回收了，这在内存管理中是非常严重的错误，我们将这种错误称为悬挂指针，即指针没有指向特定类型的合法对象，影响了内存的安全性，想要并发或者增量地标记对象还是需要使用屏障技术。</p><h3 id="屏障技术"><a href="#屏障技术" class="headerlink" title="屏障技术"></a>屏障技术</h3><p>​        内存屏障技术是一种屏障指令，它可以让 CPU 或者编译器在执行内存相关操作时遵循特定的约束，目前多数的现代处理器都会乱序执行指令以最大化性能，但是该技术能够保证内存操作的顺序性，在内存屏障前执行的操作一定会先于内存屏障后执行的操作。</p><p>​        想要在并发或者增量的标记算法中保证正确性，我们需要达成以下两种<strong>三色不变性（Tri-color invariant）</strong>中的一种：</p><ul><li>强三色不变性 — 黑色对象不会指向白色对象，只会指向灰色对象或者黑色对象；</li><li>弱三色不变性 — 黑色对象指向的白色对象必须包含一条从灰色对象经由多个白色对象的可达路径；</li></ul><p><img src="https://img.draveness.me/2020-03-16-15843705141834-strong-weak-tricolor-invariant.png" class="lazyload" data-srcset="https://img.draveness.me/2020-03-16-15843705141834-strong-weak-tricolor-invariant.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="strong-weak-tricolor-invariant"></p><p>​        上图分别展示了遵循强三色不变性和弱三色不变性的堆内存，遵循上述两个不变性中的任意一个，我们都能保证垃圾收集算法的正确性，而屏障技术就是在<strong>并发</strong>或者<strong>增量标记</strong>过程中保证三色不变性的重要技术。</p><p>​        垃圾收集中的屏障技术更像是一个钩子方法，它是在用户程序读取对象、创建新对象以及更新对象指针时执行的一段代码，根据操作类型的不同，我们可以将它们分成读屏障（Read barrier）和写屏障（Write barrier）两种，因为读屏障需要在读操作中加入代码片段，对用户程序的性能影响很大，所以编程语言往往都会采用写屏障保证三色不变性。</p><p>​         Go 语言中使了两种写屏障技术，分别是 Dijkstra 提出的插入写屏障和 Yuasa 提出的删除写屏障，这里会分析它们如何保证三色不变性和垃圾收集器的正确性。</p><h4 id="插入写屏障"><a href="#插入写屏障" class="headerlink" title="插入写屏障"></a>插入写屏障</h4><p>​        Dijkstra 在 1978 年提出了插入写屏障，通过如下所示的写屏障，用户程序和垃圾收集器可以在交替工作的情况下保证程序执行的正确性：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">writePointer(slot, ptr):</span><br><span class="line">    shade(ptr)</span><br><span class="line">    *slot = ptr</span><br></pre></td></tr></table></figure><p>​        上述插入写屏障的伪代码非常好理解，每当执行类似 <code>*slot = ptr</code> 的表达式时，我们会执行上述写屏障通过 <code>shade</code> 函数尝试改变指针的颜色。如果 <code>ptr</code> 指针是白色的，那么该函数会将该对象设置成灰色，其他情况则保持不变。</p><p><img src="https://img.draveness.me/2020-03-16-15843705141840-dijkstra-insert-write-barrier.png" class="lazyload" data-srcset="https://img.draveness.me/2020-03-16-15843705141840-dijkstra-insert-write-barrier.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="dijkstra-insert-write-barrier"></p><p>​        假设我们在应用程序中使用 Dijkstra 提出的插入写屏障，在一个垃圾收集器和用户程序交替运行的场景中会出现如上图所示的标记过程：</p><ol><li>垃圾收集器将根对象指向 A 对象标记成黑色并将 A 对象指向的对象 B 标记成灰色；</li><li>用户程序修改 A 对象的指针，将原本指向 B 对象的指针指向 C 对象，这时触发写屏障将 C 对象标记成灰色；</li><li>垃圾收集器依次遍历程序中的其他灰色对象，将它们分别标记成黑色；</li></ol><p>​        Dijkstra 的插入写屏障是一种相对保守的屏障技术，它会将<strong>有存活可能的对象都标记成灰色</strong>以满足强三色不变性。在如上所示的垃圾收集过程中，实际上不再存活的 B 对象最后没有被回收；而如果我们在第二和第三步之间将指向 C 对象的指针改回指向 B，垃圾收集器仍然认为 C 对象是存活的，这些被错误标记的垃圾对象只有在下一个循环才会被回收。</p><p>​        插入式的 Dijkstra 写屏障虽然实现非常简单并且也能保证强三色不变性，但是它也有明显的缺点。因为栈上的对象在垃圾收集中也会被认为是根对象，所以为了保证内存的安全，Dijkstra 必须为栈上的对象增加写屏障或者在标记阶段完成重新对栈上的对象进行扫描，这两种方法各有各的缺点，前者会大幅度增加写入指针的额外开销，后者重新扫描栈对象时需要暂停程序，垃圾收集算法的设计者需要在这两者之间做出权衡。</p><h4 id="删除写屏障"><a href="#删除写屏障" class="headerlink" title="删除写屏障"></a>删除写屏障</h4><p>​        Yuasa 在 1990 年的论文 Real-time garbage collection on general-purpose machines 中提出了删除写屏障，因为一旦该写屏障开始工作，它会保证开启写屏障时堆上所有对象的可达，所以也被称作快照垃圾收集（Snapshot GC）：</p><blockquote><p>This guarantees that no objects will become unreachable to the garbage collector traversal all objects which are live at the beginning of garbage collection will be reached even if the pointers to them are overwritten.</p></blockquote><p>该算法会使用如下所示的写屏障保证增量或者并发执行垃圾收集时程序的正确性：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">writePointer(slot, ptr)</span><br><span class="line">    shade(*slot)</span><br><span class="line">    *slot = ptr</span><br></pre></td></tr></table></figure><p>​        上述代码会在老对象的引用被删除时，将白色的老对象涂成灰色，这样删除写屏障就可以保证弱三色不变性，老对象引用的下游对象一定可以被灰色对象引用。</p><p><img src="https://img.draveness.me/2021-01-02-16095599123266-yuasa-delete-write-barrier.png" class="lazyload" data-srcset="https://img.draveness.me/2021-01-02-16095599123266-yuasa-delete-write-barrier.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="yuasa-delete-write-barrier"></p><p>​        假设我们在应用程序中使用 Yuasa 提出的删除写屏障，在一个垃圾收集器和用户程序交替运行的场景中会出现如上图所示的标记过程：</p><ol><li>垃圾收集器将根对象指向 A 对象标记成黑色并将 A 对象指向的对象 B 标记成灰色；</li><li>用户程序将 A 对象原本指向 B 的指针指向 C，触发删除写屏障，但是因为 B 对象已经是灰色的，所以不做改变；</li><li><strong>用户程序将 B 对象原本指向 C 的指针删除，触发删除写屏障，白色的 C 对象被涂成灰色</strong>；</li><li>垃圾收集器依次遍历程序中的其他灰色对象，将它们分别标记成黑色；</li></ol><p>​        上述过程中的第三步触发了 Yuasa 删除写屏障的着色，因为用户程序删除了 B 指向 C 对象的指针，所以 C 和 D 两个对象会分别违反强三色不变性和弱三色不变性：</p><ul><li>强三色不变性 — 黑色的 A 对象直接指向白色的 C 对象；</li><li>弱三色不变性 — 垃圾收集器无法从某个灰色对象出发，经过几个连续的白色对象访问白色的 C 和 D 两个对象；</li></ul><p>​        Yuasa 删除写屏障通过对 C 对象的着色，保证了 C 对象和下游的 D 对象能够在这一次垃圾收集的循环中存活，避免发生悬挂指针以保证用户程序的正确性。</p><h3 id="增量和并发"><a href="#增量和并发" class="headerlink" title="增量和并发"></a>增量和并发</h3><p>​        传统的垃圾收集算法会在垃圾收集的执行期间暂停应用程序，一旦触发垃圾收集，垃圾收集器会抢占 CPU 的使用权占据大量的计算资源以完成标记和清除工作，然而很多追求实时的应用程序无法接受长时间的 STW。</p><p><img src="https://img.draveness.me/2020-03-16-15843705141852-stop-the-world-collector.png" class="lazyload" data-srcset="https://img.draveness.me/2020-03-16-15843705141852-stop-the-world-collector.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="stop-the-world-collector"></p><p>​        远古时代的计算资源还没有今天这么丰富，今天的计算机往往都是多核的处理器，垃圾收集器一旦开始执行就会浪费大量的计算资源，为了减少应用程序暂停的最长时间和垃圾收集的总暂停时间，我们会使用下面的策略优化现代的垃圾收集器：</p><ul><li>增量垃圾收集 — 增量地标记和清除垃圾，降低应用程序暂停的最长时间；</li><li>并发垃圾收集 — 利用多核的计算资源，在用户程序执行时并发标记和清除垃圾；</li></ul><p>​        因为增量和并发两种方式都可以与用户程序交替运行，所以我们需要<strong>使用屏障技术</strong>保证垃圾收集的正确性；与此同时，应用程序也不能等到内存溢出时触发垃圾收集，因为当内存不足时，应用程序已经无法分配内存，这与直接暂停程序没有什么区别，增量和并发的垃圾收集需要提前触发并在内存不足前完成整个循环，避免程序的长时间暂停。</p><h4 id="增量收集器"><a href="#增量收集器" class="headerlink" title="增量收集器"></a>增量收集器</h4><p>​        增量式（Incremental）的垃圾收集是减少程序最长暂停时间的一种方案，它可以将原本时间较长的暂停时间切分成多个更小的 GC 时间片，虽然从垃圾收集开始到结束的时间更长了，但是这也减少了应用程序暂停的最大时间：</p><p><img src="https://img.draveness.me/2020-03-16-15843705141864-incremental-collector.png" class="lazyload" data-srcset="https://img.draveness.me/2020-03-16-15843705141864-incremental-collector.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="incremental-collector"></p><p>​        需要注意的是，增量式的垃圾收集需要与三色标记法一起使用，为了保证垃圾收集的正确性，我们需要在垃圾收集开始前打开写屏障，这样用户程序修改内存都会先经过写屏障的处理，保证了堆内存中对象关系的强三色不变性或者弱三色不变性。虽然增量式的垃圾收集能够减少最大的程序暂停时间，但是增量式收集也会增加一次 GC 循环的总时间，在垃圾收集期间，因为写屏障的影响用户程序也需要承担额外的计算开销，所以增量式的垃圾收集也不是只带来好处的，但是总体来说还是利大于弊。</p><h4 id="并发收集器"><a href="#并发收集器" class="headerlink" title="并发收集器"></a>并发收集器</h4><p>​        并发（Concurrent）的垃圾收集不仅能够减少程序的最长暂停时间，还能减少整个垃圾收集阶段的时间，通过开启读写屏障、<strong>利用多核优势与用户程序并行执行</strong>，并发垃圾收集器确实能够减少垃圾收集对应用程序的影响：</p><p><img src="https://img.draveness.me/2020-03-16-15843705141871-concurrent-collector.png" class="lazyload" data-srcset="https://img.draveness.me/2020-03-16-15843705141871-concurrent-collector.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="concurrent-collector"></p><p>​        虽然并发收集器能够与用户程序一起运行，但是并不是所有阶段都可以与用户程序一起运行，部分阶段还是需要暂停用户程序的，不过与传统的算法相比，并发的垃圾收集可以将能够并发执行的工作尽量并发执行；当然，因为读写屏障的引入，并发的垃圾收集器也一定会带来额外开销，不仅会增加垃圾收集的总时间，还会影响用户程序，这是我们在设计垃圾收集策略时必须要注意的。</p><h2 id="演进过程"><a href="#演进过程" class="headerlink" title="演进过程"></a>演进过程</h2><p>​        Go 语言的垃圾收集器从诞生的第一天起就一直在演进，除了少数几个版本没有大更新之外，几乎每次发布的小版本都会提升垃圾收集的性能，而与性能一同提升的还有垃圾收集器代码的复杂度，本节将从 Go 语言 v1.0 版本开始分析垃圾收集器的演进过程。</p><ol><li><p>v1.0 — 完全串行的标记和清除过程，需要暂停整个程序；</p></li><li><p>v1.1 — 在多核主机并行执行垃圾收集的标记和清除阶段；</p></li><li><p>v1.3 — 运行时基于只有指针类型的值包含指针的假设增加了对栈内存的精确扫描支持，实现了真正精确的垃圾收集；</p><ul><li>将 <code>unsafe.Pointer</code> 类型转换成整数类型的值认定为不合法的，可能会造成悬挂指针等严重问题；</li></ul></li><li><p>v1.5 — 实现了基于<strong>三色标记清扫</strong>的并发垃圾收集器；</p><ul><li>大幅度降低垃圾收集的延迟从<code>几百 ms</code> 降低至 <code>10ms</code> 以下；</li><li>计算垃圾收集启动的合适时间并通过并发加速垃圾收集的过程；</li></ul></li><li><p>v1.6 — 实现了<strong>去中心化</strong>的垃圾收集协调器；</p><ul><li>基于显式的状态机使得任意 <code>Goroutine</code> 都能触发垃圾收集的状态迁移；</li><li>使用密集的位图替代空闲链表表示的堆内存，降低清除阶段的 CPU 占用；</li></ul></li><li><p>v1.7 — 通过<strong>并行栈收缩</strong>将垃圾收集的时间缩短至 2ms 以内；</p></li><li><p>v1.8 — 使用<strong>混合写屏障</strong>将垃圾收集的时间缩短至 0.5ms 以内；</p></li><li><p>v1.9 — 彻底移除暂停程序的重新扫描栈的过程；</p></li><li><p>v1.10 — 更新了垃圾收集调频器（Pacer）的实现，分离软硬堆大小的目标；</p></li><li><p>v1.12 — 使用<strong>新的标记终止算法</strong>简化垃圾收集器的几个阶段；</p></li><li><p>v1.13 — 通过新的 Scavenger 解决瞬时内存占用过高的应用程序向操作系统归还内存的问题；</p></li><li><p>v1.14 — 使用全新的页分配器<strong>优化内存分配的速度</strong>；</p></li></ol><p>​        我们从 Go 语言垃圾收集器的演进能够看到该组件的实现和算法变得越来越复杂，最开始的垃圾收集器还是不精确的单线程 STW 收集器，但是最新版本的垃圾收集器却支持并发垃圾收集、去中心化协调等特性，我们在这里将介绍与最新版垃圾收集器相关的组件和特性。</p><h3 id="并发垃圾收集"><a href="#并发垃圾收集" class="headerlink" title="并发垃圾收集"></a>并发垃圾收集</h3><p>​        Go 语言在 v1.5 中引入了并发的垃圾收集器，该垃圾收集器使用了我们上面提到的三色抽象和写屏障技术保证垃圾收集器执行的正确性，如何实现并发的垃圾收集器在这里就不展开介绍了，我们来了解一些并发垃圾收集器的工作流程。</p><p>​        首先，并发垃圾收集器必须在合适的时间点触发垃圾收集循环，假设我们的 Go 语言程序运行在一台 4 核的物理机上，那么在垃圾收集开始后，收集器会占用 25% 计算资源在后台来扫描并标记内存中的对象：</p><p><img src="https://img.draveness.me/2020-03-16-15843705141877-golang-concurrent-collector.png" class="lazyload" data-srcset="https://img.draveness.me/2020-03-16-15843705141877-golang-concurrent-collector.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="golang-concurrent-collector"></p><p>​        Go 语言的并发垃圾收集器会在扫描对象之前暂停程序做一些标记对象的准备工作，其中包括启动后台标记的垃圾收集器以及开启写屏障，如果在后台执行的垃圾收集器不够快，应用程序申请内存的速度超过预期，运行时会让申请内存的应用程序辅助完成垃圾收集的扫描阶段，在标记和标记终止阶段结束之后就会进入异步的清理阶段，将不用的内存增量回收。</p><p>​        v1.5 版本实现的并发垃圾收集策略由专门的 Goroutine 负责在处理器之间同步和协调垃圾收集的状态。当其他的 Goroutine 发现需要触发垃圾收集时，它们需要将该信息通知给负责修改状态的主 Goroutine，然而这个通知的过程会带来一定的延迟，这个延迟的时间窗口很可能是不可控的，用户程序会在这段时间继续分配内存。</p><p>​        v1.6 引入了去中心化的垃圾收集协调机制，将垃圾收集器变成一个显式的状态机，任意的 Goroutine 都可以调用方法触发状态的迁移，常见的状态迁移方法包括以下几个</p><ul><li><code>runtime.gcStart</code> — 从 <code>_GCoff</code> 转换至<code> _GCmark</code> 阶段，进入并发标记阶段并打开写屏障；</li><li><code>runtime.gcMarkDone</code> — 如果所有可达对象都已经完成扫描，调用 <code>runtime.gcMarkTermination</code>；</li><li><code>runtime.gcMarkTermination</code> — 从<code> _GCmark</code> 转换 <code>_GCmarktermination</code> 阶段，进入标记终止阶段并在完成后进入 <code>_GCoff</code>；</li></ul><p>​        上述的三个方法是在与 <code>runtime: replace GC coordinator with state machine</code> 问题相关的提交中引入的，它们移除了过去中心化的状态迁移过程。</p><h3 id="回收堆目标"><a href="#回收堆目标" class="headerlink" title="回收堆目标"></a>回收堆目标</h3><p>​        STW 的垃圾收集器虽然需要暂停程序，但是它能够有效地控制堆内存的大小，Go 语言运行时的默认配置会在堆内存达到上一次垃圾收集的 2 倍时，触发新一轮的垃圾收集，这个行为可以通过环境变量 <code>GOGC</code> 调整，在默认情况下它的值为 100，即增长 100% 的堆内存才会触发 GC。</p><p><img src="https://img.draveness.me/2020-03-16-15843705141883-stop-the-world-garbage-collector-heap.png" class="lazyload" data-srcset="https://img.draveness.me/2020-03-16-15843705141883-stop-the-world-garbage-collector-heap.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="stop-the-world-garbage-collector-heap"></p><p>​        因为并发垃圾收集器会与程序一起运行，所以它无法准确的控制堆内存的大小，并发收集器需要在达到目标前触发垃圾收集，这样才能够保证内存大小的可控，并发收集器需要尽可能保证垃圾收集结束时的堆内存与用户配置的 <code>GOGC</code> 一致。</p><p><img src="https://img.draveness.me/2020-03-16-15843705141890-concurrent-garbage-collector-heap.png" class="lazyload" data-srcset="https://img.draveness.me/2020-03-16-15843705141890-concurrent-garbage-collector-heap.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="concurrent-garbage-collector-heap"></p><p>​        Go 语言 v1.5 引入并发垃圾收集器的同时使用垃圾收集调步（Pacing）算法计算触发的垃圾收集的最佳时间，确保触发的时间既不会浪费计算资源，也不会超出预期的堆大小。如上图所示，其中黑色的部分是上一次垃圾收集后标记的堆大小，绿色部分是上次垃圾收集结束后新分配的内存，因为我们使用并发垃圾收集，所以黄色的部分就是在垃圾收集期间分配的内存，最后的红色部分是垃圾收集结束时与目标的差值，我们希望尽可能减少红色部分内存，降低垃圾收集带来的额外开销以及程序的暂停时间。</p><p>​        垃圾收集调步算法是跟随 v1.5 一同引入的，该算法的目标是优化堆的增长速度和垃圾收集器的 CPU 利用率，而在 v1.10 版本中又对该算法进行了优化，将原有的目的堆大小拆分成了软硬两个目标<a href="https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/#fn:24">24</a>，因为调整垃圾收集的执行频率涉及较为复杂的公式，对理解垃圾收集原理帮助较为有限，本节就不展开介绍了，感兴趣的读者可以自行阅读。</p><h3 id="混合写屏障"><a href="#混合写屏障" class="headerlink" title="混合写屏障"></a>混合写屏障</h3><p>​        在 Go 语言 v1.7 版本之前，运行时会使用 Dijkstra 插入写屏障保证强三色不变性，但是运行时并没有在所有的垃圾收集根对象上开启插入写屏障。因为应用程序可能包含成百上千的 Goroutine，而垃圾收集的根对象一般包括全局变量和栈对象，如果运行时需要在几百个 Goroutine 的栈上都开启写屏障，会带来巨大的额外开销，所以 Go 团队在实现上选择了在标记阶段完成时<strong>暂停程序、将所有栈对象标记为灰色并重新扫描</strong>，在活跃 Goroutine 非常多的程序中，重新扫描的过程需要占用 10 ~ 100ms 的时间。</p><p>​        Go 语言在 v1.8 组合 Dijkstra 插入写屏障和 Yuasa 删除写屏障构成了如下所示的混合写屏障，该写屏障会<strong>将被覆盖的对象标记成灰色并在当前栈没有扫描时将新对象也标记成灰色</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">writePointer(slot, ptr):</span><br><span class="line">    shade(*slot)</span><br><span class="line">    <span class="keyword">if</span> current stack is grey:</span><br><span class="line">        shade(ptr)</span><br><span class="line">    *slot = ptr</span><br></pre></td></tr></table></figure><p>​        为了移除栈的重扫描过程，除了引入混合写屏障之外，在垃圾收集的标记阶段，我们还需要<strong>将创建的所有新对象都标记成黑色</strong>，防止新分配的栈内存和堆内存中的对象被错误地回收，因为栈内存在标记阶段最终都会变为黑色，所以不再需要重新扫描栈空间。</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>​        在介绍垃圾收集器的演进过程之前，我们需要初步了解最新垃圾收集器的执行周期，这对我们了解其全局的设计会有比较大的帮助。Go 语言的垃圾收集可以分成清除终止、标记、标记终止和清除四个不同阶段，它们分别完成了不同的工作：</p><p><img src="https://img.draveness.me/2020-03-16-15843705141897-garbage-collector-phaes.png" class="lazyload" data-srcset="https://img.draveness.me/2020-03-16-15843705141897-garbage-collector-phaes.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="garbage-collector-phases"></p><ol><li>清理终止阶段；<ol><li><strong>暂停程序</strong>，所有的处理器在这时会进入安全点（Safe point）；</li><li>如果当前垃圾收集循环是强制触发的，我们还需要处理还未被清理的内存管理单元；</li></ol></li><li>标记阶段；<ol><li>将状态切换至 <code>_GCmark</code>、开启写屏障、用户程序协助（Mutator Assists）并将根对象入队；</li><li>恢复执行程序，标记进程和用于协助的用户程序会开始并发标记内存中的对象，写屏障会将被覆盖的指针和新指针都标记成灰色，而所有新创建的对象都会被直接标记成黑色；</li><li>开始扫描根对象，包括所有 Goroutine 的栈、全局对象以及不在堆中的运行时数据结构，扫描 Goroutine 栈期间会暂停当前处理器；</li><li>依次处理灰色队列中的对象，将对象标记成黑色并将它们指向的对象标记成灰色；</li><li>使用分布式的终止算法检查剩余的工作，发现标记阶段完成后进入标记终止阶段；</li></ol></li><li>标记终止阶段；<ol><li><strong>暂停程序</strong>、将状态切换至 <code>_GCmarktermination</code> 并关闭辅助标记的用户程序；</li><li>清理处理器上的线程缓存；</li></ol></li><li>清理阶段；<ol><li>将状态切换至 <code>_GCoff</code> 开始清理阶段，初始化清理状态并关闭写屏障；</li><li>恢复用户程序，所有新创建的对象会标记成白色；</li><li>后台并发清理所有的内存管理单元，当 Goroutine 申请新的内存管理单元时就会触发清理；</li></ol></li></ol><p>​        运行时虽然只会使用 <code>_GCoff</code>、<code>_GCmark</code> 和 <code>_GCmarktermination</code> 三个状态表示垃圾收集的全部阶段，但是在实现上却复杂很多，本节将按照垃圾收集的不同阶段详细分析其实现原理。</p><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>​        在垃圾收集中有一些比较重要的全局变量，在分析其过程之前，我们会先逐一介绍这些重要的变量，这些变量在垃圾收集的各个阶段中会反复出现，所以理解他们的功能是非常重要的，我们先介绍一些比较简单的变量：</p><ul><li><code>runtime.gcphase</code> 是垃圾收集器当前处于的阶段，可能处于 <code>_GCoff</code>、<code>_GCmark </code>和 <code>_GCmarktermination</code>，<code>Goroutine</code> 在读取或者修改该阶段时需要保证原子性；</li><li><code>runtime.gcBlackenEnabled</code> 是一个布尔值，当垃圾收集处于标记阶段时，该变量会被置为 1，在这里辅助垃圾收集的用户程序和后台标记的任务可以将对象涂黑；</li><li><code>runtime.gcController</code> 实现了垃圾收集的调步算法，它能够决定触发并行垃圾收集的时间和待处理的工作；</li><li><code>runtime.gcpercent</code> 是触发垃圾收集的内存增长百分比，默认情况下为 100，即堆内存相比上次垃圾收集增长 100% 时应该触发 GC，并行的垃圾收集器会在到达该目标前完成垃圾收集；</li><li><code>runtime.writeBarrier</code> 是一个包含写屏障状态的结构体，其中的 enabled 字段表示写屏障的开启与关闭；</li><li><code>runtime.worldsema </code>是全局的信号量，获取该信号量的线程有权利暂停当前应用程序；</li></ul><p>除了上述全局的变量之外，我们在这里还需要简单了解一下 <code>runtime.work </code>变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> work <span class="keyword">struct</span> &#123;</span><br><span class="line">full  lfstack</span><br><span class="line">empty lfstack</span><br><span class="line">pad0  cpu.CacheLinePad</span><br><span class="line"></span><br><span class="line">wbufSpans <span class="keyword">struct</span> &#123;</span><br><span class="line">lock mutex</span><br><span class="line">free mSpanList</span><br><span class="line">busy mSpanList</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">nproc  <span class="keyword">uint32</span></span><br><span class="line">tstart <span class="keyword">int64</span></span><br><span class="line">nwait  <span class="keyword">uint32</span></span><br><span class="line">ndone  <span class="keyword">uint32</span></span><br><span class="line">...</span><br><span class="line">mode gcMode</span><br><span class="line">cycles <span class="keyword">uint32</span></span><br><span class="line">...</span><br><span class="line">stwprocs, maxprocs <span class="keyword">int32</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        该结构体中包含大量垃圾收集的相关字段，例如：表示完成的垃圾收集循环的次数、当前循环时间和 CPU 的利用率、垃圾收集的模式等等，我们会在后面的小节中见到该结构体中的更多字段。</p><h3 id="触发时机"><a href="#触发时机" class="headerlink" title="触发时机"></a>触发时机</h3><p>​        运行时会通过如下所示的 <code>runtime.gcTrigger.test</code> 方法决定是否需要触发垃圾收集，当满足触发垃圾收集的基本条件时 — 允许垃圾收集、程序没有崩溃并且没有处于垃圾收集循环，该方法会根据三种不同方式触发进行不同的检查：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t gcTrigger)</span> <span class="title">test</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> !memstats.enablegc || panicking != <span class="number">0</span> || gcphase != _GCoff &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> t.kind &#123;</span><br><span class="line"><span class="keyword">case</span> gcTriggerHeap:</span><br><span class="line"><span class="keyword">return</span> memstats.heap_live &gt;= memstats.gc_trigger</span><br><span class="line"><span class="keyword">case</span> gcTriggerTime:</span><br><span class="line"><span class="keyword">if</span> gcpercent &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">lastgc := <span class="keyword">int64</span>(atomic.Load64(&amp;memstats.last_gc_nanotime))</span><br><span class="line"><span class="keyword">return</span> lastgc != <span class="number">0</span> &amp;&amp; t.now-lastgc &gt; forcegcperiod</span><br><span class="line"><span class="keyword">case</span> gcTriggerCycle:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">int32</span>(t.n-work.cycles) &gt; <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>gcTriggerHeap</code> — 堆内存的分配达到控制器计算的触发堆大小；</li><li><code>gcTriggerTime</code> — 如果一定时间内没有触发，就会触发新的循环，该触发条件由 <code>runtime.forcegcperiod</code>变量控制，默认为 2 分钟；</li><li><code>gcTriggerCycle</code> — 如果当前没有开启垃圾收集，则触发新的循环；</li></ol><p>​        用于开启垃圾收集的方法 <code>runtime.gcStart</code> 会接收一个 <code>runtime.gcTrigger</code> 类型的谓词，所有出现 <code>runtime.gcTrigger</code> 结构体的位置都是触发垃圾收集的代码：</p><ul><li><code>runtime.sysmon</code> 和 <code>runtime.forcegchelper</code> — 后台运行定时检查和垃圾收集；</li><li><code>runtime.GC</code> — 用户程序手动触发垃圾收集；</li><li> <code>runtime.mallocgc </code>— 申请内存时根据堆大小触发垃圾收集；</li></ul><p><img src="https://img.draveness.me/2020-03-16-15843705141903-garbage-collector-trigger.png" class="lazyload" data-srcset="https://img.draveness.me/2020-03-16-15843705141903-garbage-collector-trigger.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="garbage-collector-trigger"></p><p>​        除了使用后台运行的系统监控器和强制垃圾收集助手触发垃圾收集之外，另外两个方法会从任意处理器上触发垃圾收集，这种不需要中心组件协调的方式是在 v1.6 版本中引入的，接下来我们将展开介绍这三种不同的触发时机。</p><h4 id="后台触发"><a href="#后台触发" class="headerlink" title="后台触发"></a>后台触发</h4><p>​        运行时会在应用程序启动时在后台开启一个用于强制触发垃圾收集的 Goroutine，该 Goroutine 的职责非常简单 — 调用 <code>runtime.gcStart</code> 尝试启动新一轮的垃圾收集：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> forcegchelper()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">forcegchelper</span><span class="params">()</span></span> &#123;</span><br><span class="line">forcegc.g = getg()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">lock(&amp;forcegc.lock)</span><br><span class="line">atomic.Store(&amp;forcegc.idle, <span class="number">1</span>)</span><br><span class="line">goparkunlock(&amp;forcegc.lock, waitReasonForceGGIdle, traceEvGoBlock, <span class="number">1</span>)</span><br><span class="line">gcStart(gcTrigger&#123;kind: gcTriggerTime, now: nanotime()&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        为了减少对计算资源的占用，该 Goroutine 会在循环中调用 <code> runtime.goparkunlock</code> 主动陷入休眠等待其他 Goroutine 的唤醒，<code>runtime.forcegchelper </code>在大多数时间都是陷入休眠的，但是它会被系统监控器 <code>runtime.sysmon</code> 在满足垃圾收集条件时唤醒：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sysmon</span><span class="params">()</span></span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> t := (gcTrigger&#123;kind: gcTriggerTime, now: now&#125;); t.test() &amp;&amp; atomic.Load(&amp;forcegc.idle) != <span class="number">0</span> &#123;</span><br><span class="line">lock(&amp;forcegc.lock)</span><br><span class="line">forcegc.idle = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> list gList</span><br><span class="line">list.push(forcegc.g)</span><br><span class="line">injectglist(&amp;list)</span><br><span class="line">unlock(&amp;forcegc.lock)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        系统监控在每个循环中都会主动构建一个 <code>runtime.gcTrigger </code>并检查垃圾收集的触发条件是否满足，如果满足条件，系统监控会将 <code>runtime.forcegc</code> 状态中持有的 Goroutine 加入全局队列等待调度器的调度。</p><h4 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a>手动触发</h4><p>​        用户程序会通过 <code>runtime.GC </code>函数在程序运行期间主动通知运行时执行，该方法在调用时会阻塞调用方直到当前垃圾收集循环完成，在垃圾收集期间也可能会通过 STW 暂停整个程序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GC</span><span class="params">()</span></span> &#123;</span><br><span class="line">n := atomic.Load(&amp;work.cycles)</span><br><span class="line">gcWaitOnMark(n)</span><br><span class="line">gcStart(gcTrigger&#123;kind: gcTriggerCycle, n: n + <span class="number">1</span>&#125;)</span><br><span class="line">gcWaitOnMark(n + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> atomic.Load(&amp;work.cycles) == n+<span class="number">1</span> &amp;&amp; sweepone() != ^<span class="keyword">uintptr</span>(<span class="number">0</span>) &#123;</span><br><span class="line">sweep.nbgsweep++</span><br><span class="line">Gosched()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> atomic.Load(&amp;work.cycles) == n+<span class="number">1</span> &amp;&amp; atomic.Load(&amp;mheap_.sweepers) != <span class="number">0</span> &#123;</span><br><span class="line">Gosched()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mp := acquirem()</span><br><span class="line">cycle := atomic.Load(&amp;work.cycles)</span><br><span class="line"><span class="keyword">if</span> cycle == n+<span class="number">1</span> || (gcphase == _GCmark &amp;&amp; cycle == n+<span class="number">2</span>) &#123;</span><br><span class="line">mProf_PostSweep()</span><br><span class="line">&#125;</span><br><span class="line">releasem(mp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>在正式开始垃圾收集前，运行时需要通过 <code>runtime.gcWaitOnMark</code> 等待上一个循环的标记终止、标记和清除终止阶段完成；</li><li>调用 <code>runtime.gcStart </code>触发新一轮的垃圾收集并通过 <code>runtime.gcWaitOnMark </code>等待该轮垃圾收集的标记终止阶段正常结束；</li><li>持续调用 <code>runtime.sweepone</code> 清理全部待处理的内存管理单元并等待所有的清理工作完成，等待期间会调用<code> runtime.Gosched</code> 让出处理器；</li><li>完成本轮垃圾收集的清理工作后，通过 <code>runtime.mProf_PostSweep </code>将该阶段的堆内存状态快照发布出来，我们可以获取这时的内存状态；</li></ol><p>​        手动触发垃圾收集的过程不是特别常见，一般只会在运行时的测试代码中才会出现，不过如果我们认为触发主动垃圾收集是有必要的，我们也可以直接调用该方法，但是作者并不认为这是一种推荐的做法。</p><h4 id="申请内存"><a href="#申请内存" class="headerlink" title="申请内存"></a>申请内存</h4><p>​        最后一个可能会触发垃圾收集的就是 <code>runtime.mallocgc</code> 了，我们在上一节内存分配器中曾经介绍过运行时会将堆上的对象按大小分成微对象、小对象和大对象三类，这三类对象的创建都可能会触发新的垃圾收集循环：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocgc</span><span class="params">(size <span class="keyword">uintptr</span>, typ *_type, needzero <span class="keyword">bool</span>)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">shouldhelpgc := <span class="literal">false</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> size &lt;= maxSmallSize &#123;</span><br><span class="line"><span class="keyword">if</span> noscan &amp;&amp; size &lt; maxTinySize &#123;</span><br><span class="line">...</span><br><span class="line">v := nextFreeFast(span)</span><br><span class="line"><span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">v, _, shouldhelpgc = c.nextFree(tinySpanClass)</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...</span><br><span class="line">v := nextFreeFast(span)</span><br><span class="line"><span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">v, span, shouldhelpgc = c.nextFree(spc)</span><br><span class="line">&#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">shouldhelpgc = <span class="literal">true</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> shouldhelpgc &#123;</span><br><span class="line"><span class="keyword">if</span> t := (gcTrigger&#123;kind: gcTriggerHeap&#125;); t.test() &#123;</span><br><span class="line">gcStart(t)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>当前线程的内存管理单元中不存在空闲空间时，创建微对象和小对象需要调用 <code>runtime.mcache.nextFree</code> 从中心缓存或者页堆中获取新的管理单元，在这时就可能触发垃圾收集；</li><li>当用户程序申请分配 32KB 以上的大对象时，一定会构建 <code>runtime.gcTrigger </code>结构体尝试触发垃圾收集；</li></ol><p>​        通过堆内存触发垃圾收集需要比较<code>runtime.mstats</code>中的两个字段 — 表示垃圾收集中存活对象字节数的 <code>heap_live</code> 和表示触发标记的堆内存大小的 <code>gc_trigger</code>；当内存中存活的对象字节数大于触发垃圾收集的堆大小时，新一轮的垃圾收集就会开始。在这里，我们将分别介绍这两个值的计算过程：</p><ol><li><code>heap_live</code> — 为了减少锁竞争，运行时只会在中心缓存分配或者释放内存管理单元以及在堆上分配大对象时才会更新；</li><li><code>gc_trigger</code> — 在标记终止阶段调用 <code>runtime.gcSetTriggerRatio</code>更新触发下一次垃圾收集的堆大小；</li></ol><p>​        <code>runtime.gcController </code>会在每个循环结束后计算触发比例并通过 <code>runtime.gcSetTriggerRatio</code> 设置 <code>gc_trigger</code>，它能够决定触发垃圾收集的时间以及用户程序和后台处理的标记任务的多少，利用反馈控制的算法根据堆的增长情况和垃圾收集 CPU 利用率确定触发垃圾收集的时机。</p><p>​        你可以在 <code>runtime.gcControllerState.endCycle</code> 中找到 v1.5 提出的垃圾收集调步算法26，并在 <code>runtime.gcControllerState.revise</code> 中找到 v1.10 引入的软硬堆目标分离算法27。</p><h3 id="垃圾收集启动"><a href="#垃圾收集启动" class="headerlink" title="垃圾收集启动"></a>垃圾收集启动</h3><p>​        垃圾收集在启动过程一定会调用 <code>runtime.gcStart</code>，虽然该函数的实现比较复杂，但是它的主要职责是修改全局的垃圾收集状态到 <code>_GCmark </code>并做一些准备工作，我们会分以下几个阶段介绍该函数的实现：</p><ol><li>两次调用 <code>runtime.gcTrigger.test</code>检查是否满足垃圾收集条件；</li><li>暂停程序、在后台启动用于处理标记任务的工作 Goroutine、确定所有内存管理单元都被清理以及其他标记阶段开始前的准备工作；</li><li>进入标记阶段、准备后台的标记工作、根对象的标记工作以及微对象、恢复用户程序，进入并发扫描和标记阶段；</li></ol><p>​        验证垃圾收集条件的同时，该方法还会在循环中不断调用<code>runtime.sweepone</code>清理已经被标记的内存单元，完成上一个垃圾收集循环的收尾工作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcStart</span><span class="params">(trigger gcTrigger)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> trigger.test() &amp;&amp; sweepone() != ^<span class="keyword">uintptr</span>(<span class="number">0</span>) &#123;</span><br><span class="line">sweep.nbgsweep++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">semacquire(&amp;work.startSema)</span><br><span class="line"><span class="keyword">if</span> !trigger.test() &#123;</span><br><span class="line">semrelease(&amp;work.startSema)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        在验证了垃圾收集的条件并完成了收尾工作后，该方法会通过 <code>semacquire</code> 获取全局的 <code>worldsema </code>信号量、调用 <code>runtime.gcBgMarkStartWorkers</code> 启动后台标记任务、在系统栈中调用 <code>runtime.stopTheWorldWithSema</code> 暂停程序并调用<code> runtime.finishsweep_m</code> 保证上一个内存单元的正常回收：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcStart</span><span class="params">(trigger gcTrigger)</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">semacquire(&amp;worldsema)</span><br><span class="line">gcBgMarkStartWorkers()</span><br><span class="line">work.stwprocs, work.maxprocs = gomaxprocs, gomaxprocs</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">systemstack(stopTheWorldWithSema)</span><br><span class="line">systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">finishsweep_m()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">work.cycles++</span><br><span class="line">gcController.startCycle()</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        除此之外，上述过程还会修改全局变量 <code>runtime.work</code> 持有的状态，包括垃圾收集需要的 Goroutine 数量以及已完成的循环数。</p><p>​        在完成全部的准备工作后，该方法就进入了执行的最后阶段。在该阶段中，我们会修改全局的垃圾收集状态到 <code>_GCmark </code>并依次执行下面的步骤：</p><ol><li>调用 <code>runtime.gcBgMarkPrepare</code> 初始化后台扫描需要的状态；</li><li>调用<code>runtime.gcMarkRootPrepare</code>扫描栈上、全局变量等根对象并将它们加入队列；</li><li>设置全局变量 <code>runtime.gcBlackenEnabled</code>，用户程序和标记任务可以将对象涂黑；</li><li>调用<code>runtime.startTheWorldWithSema</code>启动程序，后台任务也会开始标记堆中的对象；</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcStart</span><span class="params">(trigger gcTrigger)</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">setGCPhase(_GCmark)</span><br><span class="line"></span><br><span class="line">gcBgMarkPrepare()</span><br><span class="line">gcMarkRootPrepare()</span><br><span class="line"></span><br><span class="line">atomic.Store(&amp;gcBlackenEnabled, <span class="number">1</span>)</span><br><span class="line">systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">now = startTheWorldWithSema(trace.enabled)</span><br><span class="line">work.pauseNS += now - work.pauseStart</span><br><span class="line">work.tMark = now</span><br><span class="line">&#125;)</span><br><span class="line">semrelease(&amp;work.startSema)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        在分析垃圾收集的启动过程中，我们省略了几个关键的过程，其中包括暂停和恢复应用程序和后台任务的启动，下面将详细分析这几个过程的实现原理。</p><h4 id="暂停与恢复程序"><a href="#暂停与恢复程序" class="headerlink" title="暂停与恢复程序"></a>暂停与恢复程序</h4><p>​        <code>runtime.stopTheWorldWithSema </code>和 <code>runtime.startTheWorldWithSema</code> 是一对用于暂停和恢复程序的核心函数，它们有着完全相反的功能，但是程序的暂停会比恢复要复杂一些，我们来看一下前者的实现原理：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stopTheWorldWithSema</span><span class="params">()</span></span> &#123;</span><br><span class="line">_g_ := getg()</span><br><span class="line">sched.stopwait = gomaxprocs</span><br><span class="line">atomic.Store(&amp;sched.gcwaiting, <span class="number">1</span>)</span><br><span class="line">preemptall()</span><br><span class="line">_g_.m.p.ptr().status = _Pgcstop</span><br><span class="line">sched.stopwait--</span><br><span class="line"><span class="keyword">for</span> _, p := <span class="keyword">range</span> allp &#123;</span><br><span class="line">s := p.status</span><br><span class="line"><span class="keyword">if</span> s == _Psyscall &amp;&amp; atomic.Cas(&amp;p.status, s, _Pgcstop) &#123;</span><br><span class="line">p.syscalltick++</span><br><span class="line">sched.stopwait--</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">p := pidleget()</span><br><span class="line"><span class="keyword">if</span> p == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">p.status = _Pgcstop</span><br><span class="line">sched.stopwait--</span><br><span class="line">&#125;</span><br><span class="line">wait := sched.stopwait &gt; <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> wait &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">if</span> notetsleep(&amp;sched.stopnote, <span class="number">100</span>*<span class="number">1000</span>) &#123;</span><br><span class="line">noteclear(&amp;sched.stopnote)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">preemptall()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        暂停程序主要使用了 <code>runtime.preemptall</code>，该函数会调用我们在前面介绍过的 <code>runtime.preemptone</code>，因为程序中活跃的最大处理数为<code> gomaxprocs</code>，所以<code> runtime.stopTheWorldWithSema</code> 在每次发现停止的处理器时都会对该变量减一，直到所有的处理器都停止运行。该函数会依次停止当前处理器、等待处于系统调用的处理器以及获取并抢占空闲的处理器，处理器的状态在该函数返回时都会被更新至 <code>_Pgcstop</code>，等待垃圾收集器的重新唤醒。</p><p>程序恢复过程会使用<code> runtime.startTheWorldWithSema</code>，该函数的实现也相对比较简单：</p><ol><li>调用 <code>runtime.netpoll</code> 从网络轮询器中获取待处理的任务并加入全局队列；</li><li>调用<code> runtime.procresize</code> 扩容或者缩容全局的处理器；</li><li>调用<code> runtime.notewakeup</code> 或者<code> runtime.newm</code> 依次唤醒处理器或者为处理器创建新的线程；</li><li>如果当前待处理的 Goroutine 数量过多，创建额外的处理器辅助完成任务；</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startTheWorldWithSema</span><span class="params">(emitTraceEvent <span class="keyword">bool</span>)</span> <span class="title">int64</span></span> &#123;</span><br><span class="line">mp := acquirem()</span><br><span class="line"><span class="keyword">if</span> netpollinited() &#123;</span><br><span class="line">list := netpoll(<span class="number">0</span>)</span><br><span class="line">injectglist(&amp;list)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">procs := gomaxprocs</span><br><span class="line">p1 := procresize(procs)</span><br><span class="line">sched.gcwaiting = <span class="number">0</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> p1 != <span class="literal">nil</span> &#123;</span><br><span class="line">p := p1</span><br><span class="line">p1 = p1.link.ptr()</span><br><span class="line"><span class="keyword">if</span> p.m != <span class="number">0</span> &#123;</span><br><span class="line">mp := p.m.ptr()</span><br><span class="line">p.m = <span class="number">0</span></span><br><span class="line">mp.nextp.set(p)</span><br><span class="line">notewakeup(&amp;mp.park)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">newm(<span class="literal">nil</span>, p)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> atomic.Load(&amp;sched.npidle) != <span class="number">0</span> &amp;&amp; atomic.Load(&amp;sched.nmspinning) == <span class="number">0</span> &#123;</span><br><span class="line">wakep()</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        程序的暂停和启动过程都比较简单，暂停程序会使用 <code>runtime.preemptall</code> 抢占所有的处理器，恢复程序时会使用<code>runtime.notewakeup</code>或者 <code>runtime.newm </code>唤醒程序中的处理器。</p><h4 id="后台标记模式"><a href="#后台标记模式" class="headerlink" title="后台标记模式"></a>后台标记模式</h4><p>​        在垃圾收集启动期间，运行时会调用 <code>runtime.gcBgMarkStartWorkers </code>为全局每个处理器创建用于执行后台标记任务的 Goroutine，每一个 Goroutine 都会运行 <code>runtime.gcBgMarkWorker</code>，所有运行 <code>runtime.gcBgMarkWorker</code> 的 Goroutine 在启动后都会陷入休眠等待调度器的唤醒：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcBgMarkStartWorkers</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> gcBgMarkWorkerCount &lt; gomaxprocs &#123;</span><br><span class="line"><span class="keyword">go</span> gcBgMarkWorker()</span><br><span class="line"></span><br><span class="line">notetsleepg(&amp;work.bgMarkReady, <span class="number">-1</span>)</span><br><span class="line">noteclear(&amp;work.bgMarkReady)</span><br><span class="line"></span><br><span class="line">gcBgMarkWorkerCount++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        这些 Goroutine 与处理器是一一对应的关系，当垃圾收集处于标记阶段并且当前处理器不需要做任何任务时，<code>runtime.findrunnable</code> 会在当前处理器上执行该 Goroutine 辅助并发的对象标记：</p><p><img src="https://img.draveness.me/2020-03-16-15843705141909-p-and-bg-mark-worker.png" class="lazyload" data-srcset="https://img.draveness.me/2020-03-16-15843705141909-p-and-bg-mark-worker.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="p-and-bg-mark-worker"></p><p>​        调度器在调度循环 <code>runtime.schedule</code> 中还可以通过垃圾收集控制器的 <code>runtime.gcControllerState.findRunnabledGCWorker</code> 获取并执行用于后台标记的任务。</p><p>​        用于并发扫描对象的工作协程 Goroutine 总共有三种不同的模式 <code>runtime.gcMarkWorkerMode</code>，这三种不同模式的 Goroutine 在标记对象时使用完全不同的策略，垃圾收集控制器会按照需要执行不同类型的工作协程：</p><ul><li><code>gcMarkWorkerDedicatedMode</code> — 处理器专门负责标记对象，不会被调度器抢占；</li><li><code>gcMarkWorkerFractionalMode</code> — 当垃圾收集的后台 CPU 使用率达不到预期时（默认为 25%），启动该类型的工作协程帮助垃圾收集达到利用率的目标，因为它只占用同一个 CPU 的部分资源，所以可以被调度；</li><li><code>gcMarkWorkerIdleMode</code> — 当处理器没有可以执行的 Goroutine 时，它会运行垃圾收集的标记任务直到被抢占；</li></ul><p>​        <code>runtime.gcControllerState.startCycle</code> 会根据全局处理器的个数以及垃圾收集的 CPU 利用率计算出上述的  <code>dedicatedMarkWorkersNeeded</code> 和 <code>fractionalUtilizationGoal</code> 以决定不同模式的工作协程的数量。</p><p>​        因为后台标记任务的 CPU 利用率为 25%，如果主机是 4 核或者 8 核，那么垃圾收集需要 1 个或者 2 个专门处理相关任务的 Goroutine；不过如果主机是 3 核或者 6 核，因为无法被 4 整除，所以这时需要 0 个或者 1 个专门处理垃圾收集的 Goroutine，运行时需要占用某个 CPU 的部分时间，使用 <code>gcMarkWorkerFractionalMode</code> 模式的协程保证 CPU 的利用率。</p><p><img src="https://img.draveness.me/2020-03-16-15843705141916-cpu-number-and-gc-mark-worker-mode.png" class="lazyload" data-srcset="https://img.draveness.me/2020-03-16-15843705141916-cpu-number-and-gc-mark-worker-mode.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="cpu-number-and-gc-mark-worker-mode"></p><p>垃圾收集控制器会在 <code>runtime.gcControllerState.findRunnabledGCWorker</code>方法中设置处理器的 <code>gcMarkWorkerMode</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *gcControllerState)</span> <span class="title">findRunnableGCWorker</span><span class="params">(_p_ *p)</span> *<span class="title">g</span></span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> decIfPositive(&amp;c.dedicatedMarkWorkersNeeded) &#123;</span><br><span class="line">_p_.gcMarkWorkerMode = gcMarkWorkerDedicatedMode</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> c.fractionalUtilizationGoal == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">delta := nanotime() - gcController.markStartTime</span><br><span class="line"><span class="keyword">if</span> delta &gt; <span class="number">0</span> &amp;&amp; <span class="keyword">float64</span>(_p_.gcFractionalMarkTime)/<span class="keyword">float64</span>(delta) &gt; c.fractionalUtilizationGoal &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">_p_.gcMarkWorkerMode = gcMarkWorkerFractionalMode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gp := _p_.gcBgMarkWorker.ptr()</span><br><span class="line">casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line"><span class="keyword">return</span> gp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        上述方法的实现比较清晰，控制器通过 <code>dedicatedMarkWorkersNeeded</code> 决定专门执行标记任务的 Goroutine 数量并根据执行标记任务的时间和总时间决定是否启动<code> gcMarkWorkerFractionalMode</code> 模式的 Goroutine；除了这两种控制器要求的工作协程之外，调度器还会在 <code>runtime.findrunnable </code>中利用空闲的处理器执行垃圾收集以加速该过程：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findrunnable</span><span class="params">()</span> <span class="params">(gp *g, inheritTime <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">stop:</span><br><span class="line"><span class="keyword">if</span> gcBlackenEnabled != <span class="number">0</span> &amp;&amp; _p_.gcBgMarkWorker != <span class="number">0</span> &amp;&amp; gcMarkWorkAvailable(_p_) &#123;</span><br><span class="line">_p_.gcMarkWorkerMode = gcMarkWorkerIdleMode</span><br><span class="line">gp := _p_.gcBgMarkWorker.ptr()</span><br><span class="line">casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line"><span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        三种不同模式的工作协程会相互协同保证垃圾收集的 CPU 利用率达到期望的阈值，在到达目标堆大小前完成标记任务。</p><h3 id="并发扫描与标记辅助"><a href="#并发扫描与标记辅助" class="headerlink" title="并发扫描与标记辅助"></a>并发扫描与标记辅助</h3><p>​        <code>runtime.gcBgMarkWorker</code> 是后台的标记任务执行的函数，该函数的循环中执行了对内存中对象图的扫描和标记，我们分三个部分介绍该函数的实现原理：</p><ol><li>获取当前处理器以及 Goroutine 打包成<code>runtime.gcBgMarkWorkerNode</code>类型的结构并主动陷入休眠等待唤醒；</li><li>根据处理器上的 <code>gcMarkWorkerMode</code> 模式决定扫描任务的策略；</li><li>所有标记任务都完成后，调用 <code>runtime.gcMarkDone</code>方法完成标记阶段；</li></ol><p>​        首先我们来看后台标记任务的准备工作，运行时在这里创建了<code> runtime.gcBgMarkWorkerNode</code>，该结构会预先存储处理器和当前 Goroutine，当我们调用 <code>runtime.gopark</code> 触发休眠时，运行时会在系统栈中安全地建立处理器和后台标记任务的绑定关系：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcBgMarkWorker</span><span class="params">()</span></span> &#123;</span><br><span class="line">gp := getg()</span><br><span class="line"></span><br><span class="line">gp.m.preemptoff = <span class="string">&quot;GC worker init&quot;</span></span><br><span class="line">node := <span class="built_in">new</span>(gcBgMarkWorkerNode)</span><br><span class="line">gp.m.preemptoff = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">node.gp.set(gp)</span><br><span class="line"></span><br><span class="line">node.m.set(acquirem())</span><br><span class="line">notewakeup(&amp;work.bgMarkReady)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">gopark(<span class="function"><span class="keyword">func</span><span class="params">(g *g, parkp unsafe.Pointer)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">node := (*gcBgMarkWorkerNode)(nodep)</span><br><span class="line"><span class="keyword">if</span> mp := node.m.ptr(); mp != <span class="literal">nil</span> &#123;</span><br><span class="line">releasem(mp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gcBgMarkWorkerPool.push(&amp;node.node)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;, unsafe.Pointer(node), waitReasonGCWorkerIdle, traceEvGoBlock, <span class="number">0</span>)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        通过<code>runtime.gopark</code>陷入休眠的 Goroutine 不会进入运行队列，它只会等待垃圾收集控制器或者调度器的直接唤醒；在唤醒后，我们会根据处理器<code>gcMarkWorkerMode</code>选择不同的标记执行策略，不同的执行策略都会调用 <code>runtime.gcDrain</code> 扫描工作缓冲区<code> runtime.gcWork</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">node.m.set(acquirem())</span><br><span class="line"></span><br><span class="line">atomic.Xadd(&amp;work.nwait, <span class="number">-1</span>)</span><br><span class="line">systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">casgstatus(gp, _Grunning, _Gwaiting)</span><br><span class="line"><span class="keyword">switch</span> pp.gcMarkWorkerMode &#123;</span><br><span class="line"><span class="keyword">case</span> gcMarkWorkerDedicatedMode:</span><br><span class="line">gcDrain(&amp;_p_.gcw, gcDrainUntilPreempt|gcDrainFlushBgCredit)</span><br><span class="line"><span class="keyword">if</span> gp.preempt &#123;</span><br><span class="line">lock(&amp;sched.lock)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">gp, _ := runqget(_p_)</span><br><span class="line"><span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">globrunqput(gp)</span><br><span class="line">&#125;</span><br><span class="line">unlock(&amp;sched.lock)</span><br><span class="line">&#125;</span><br><span class="line">gcDrain(&amp;_p_.gcw, gcDrainFlushBgCredit)</span><br><span class="line"><span class="keyword">case</span> gcMarkWorkerFractionalMode:</span><br><span class="line">gcDrain(&amp;_p_.gcw, gcDrainFractional|gcDrainUntilPreempt|gcDrainFlushBgCredit)</span><br><span class="line"><span class="keyword">case</span> gcMarkWorkerIdleMode:</span><br><span class="line">gcDrain(&amp;_p_.gcw, gcDrainIdle|gcDrainUntilPreempt|gcDrainFlushBgCredit)</span><br><span class="line">&#125;</span><br><span class="line">casgstatus(gp, _Gwaiting, _Grunning)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Go</p><p>需要注意的是，<code>gcMarkWorkerDedicatedMode</code> 模式的任务是不能被抢占的，为了减少额外开销，第一次调用  <code>runtime.gcDrain</code> 时是允许抢占的，但是一旦处理器被抢占，当前 Goroutine 会将处理器上的所有可运行的 Goroutine 转移至全局队列中，保证垃圾收集占用的 CPU 资源。</p><p>当所有的后台工作任务都陷入等待并且没有剩余工作时，我们就认为该轮垃圾收集的标记阶段结束了，这时我们会调用 <code>runtime.gcMarkDone</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">incnwait := atomic.Xadd(&amp;work.nwait, +<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> incnwait == work.nproc &amp;&amp; !gcMarkWorkAvailable(<span class="literal">nil</span>) &#123;</span><br><span class="line">releasem(node.m.ptr())</span><br><span class="line">node.m.set(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">gcMarkDone()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        <code>runtime.gcDrain</code> 是用于扫描和标记堆内存中对象的核心方法，除了该方法之外，我们还会介绍工作池、写屏障以及标记辅助的实现原理。</p><h4 id="工作池"><a href="#工作池" class="headerlink" title="工作池"></a>工作池</h4><p>​        在调用<code> runtime.gcDrain</code> 时，运行时会传入处理器上的 <code>runtime.gcWork</code>，这个结构体是垃圾收集器中工作池的抽象，它实现了一个生产者和消费者的模型，我们可以以该结构体为起点从整体理解标记工作：</p><p><img src="https://img.draveness.me/2020-03-16-15843705141923-gc-work-pool.png" class="lazyload" data-srcset="https://img.draveness.me/2020-03-16-15843705141923-gc-work-pool.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="gc-work-pool"></p><p>​        写屏障、根对象扫描和栈扫描都会向工作池中增加额外的灰色对象等待处理，而对象的扫描过程会将灰色对象标记成黑色，同时也可能发现新的灰色对象，当工作队列中不包含灰色对象时，整个扫描过程就会结束。</p><p>​        为了减少锁竞争，运行时在每个处理器上会保存独立的待扫描工作，然而这会遇到与调度器一样的问题 — 不同处理器的资源不平均，导致部分处理器无事可做，调度器引入了工作窃取来解决这个问题，垃圾收集器也使用了差不多的机制平衡不同处理器上的待处理任务。</p><p><img src="https://img.draveness.me/2020-03-16-15843705141929-global-work-and-local-work.png" class="lazyload" data-srcset="https://img.draveness.me/2020-03-16-15843705141929-global-work-and-local-work.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="global-work-and-local-work"></p><p><code>runtime.gcWork.balance</code> 会将处理器本地一部分工作放回全局队列中，让其他的处理器处理，保证不同处理器负载的平衡。</p><p><code>runtime.gcWork</code> 为垃圾收集器提供了生产和消费任务的抽象，该结构体持有了两个重要的工作缓冲区 wbuf1 和 wbuf2，这两个缓冲区分别是主缓冲区和备缓冲区：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> gcWork <span class="keyword">struct</span> &#123;</span><br><span class="line">wbuf1, wbuf2 *workbuf</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> workbufhdr <span class="keyword">struct</span> &#123;</span><br><span class="line">node lfnode <span class="comment">// must be first</span></span><br><span class="line">nobj <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> workbuf <span class="keyword">struct</span> &#123;</span><br><span class="line">workbufhdr</span><br><span class="line">obj [(_WorkbufSize - unsafe.Sizeof(workbufhdr&#123;&#125;)) / sys.PtrSize]<span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        当我们向该结构体中增加或者删除对象时，它总会先操作主缓冲区，一旦主缓冲区空间不足或者没有对象，会触发主备缓冲区的切换；而当两个缓冲区空间都不足或者都为空时，会从全局的工作缓冲区中插入或者获取对象，该结构体相关方法的实现都非常简单，这里就不展开分析了。</p><h4 id="扫描对象"><a href="#扫描对象" class="headerlink" title="扫描对象"></a>扫描对象</h4><p>​        运行时会使用 <code>runtime.gcDrain</code> 扫描工作缓冲区中的灰色对象，它会根据传入 gcDrainFlags 的不同选择不同的策略：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcDrain</span><span class="params">(gcw *gcWork, flags gcDrainFlags)</span></span> &#123;</span><br><span class="line">gp := getg().m.curg</span><br><span class="line">preemptible := flags&amp;gcDrainUntilPreempt != <span class="number">0</span></span><br><span class="line">flushBgCredit := flags&amp;gcDrainFlushBgCredit != <span class="number">0</span></span><br><span class="line">idle := flags&amp;gcDrainIdle != <span class="number">0</span></span><br><span class="line"></span><br><span class="line">initScanWork := gcw.scanWork</span><br><span class="line">checkWork := <span class="keyword">int64</span>(<span class="number">1</span>&lt;&lt;<span class="number">63</span> - <span class="number">1</span>)</span><br><span class="line"><span class="keyword">var</span> check <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line"><span class="keyword">if</span> flags&amp;(gcDrainIdle|gcDrainFractional) != <span class="number">0</span> &#123;</span><br><span class="line">checkWork = initScanWork + drainCheckThreshold</span><br><span class="line"><span class="keyword">if</span> idle &#123;</span><br><span class="line">check = pollWork</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> flags&amp;gcDrainFractional != <span class="number">0</span> &#123;</span><br><span class="line">check = pollFractionalWorkerExit</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>gcDrainUntilPreempt</code> — 当 Goroutine 的 <code>preempt</code> 字段被设置成 true 时返回；</li><li><code>gcDrainIdle</code> — 调用  <code>runtime.pollWork</code>，当处理器上包含其他待执行 Goroutine 时返回；</li><li><code>gcDrainFractional</code> — 调用<code>runtime.pollFractionalWorkerExit</code>，当 CPU 的占用率超过 <code>fractionalUtilizationGoal</code> 的 20% 时返回；</li><li><code>gcDrainFlushBgCredit</code> — 调用 <code>runtime.gcFlushBgCredit </code>计算后台完成的标记任务量以减少并发标记期间的辅助垃圾收集的用户程序的工作量；</li></ul><p>​        运行时会使用本地变量中的 <code>check</code> 检查当前是否应该退出标记任务并让出该处理器。当我们做完准备工作后，就可以开始扫描全局变量中的根对象了，这也是标记阶段中需要最先被执行的任务：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcDrain</span><span class="params">(gcw *gcWork, flags gcDrainFlags)</span></span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> work.markrootNext &lt; work.markrootJobs &#123;</span><br><span class="line"><span class="keyword">for</span> !(preemptible &amp;&amp; gp.preempt) &#123;</span><br><span class="line">job := atomic.Xadd(&amp;work.markrootNext, +<span class="number">1</span>) - <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> job &gt;= work.markrootJobs &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">markroot(gcw, job)</span><br><span class="line"><span class="keyword">if</span> check != <span class="literal">nil</span> &amp;&amp; check() &#123;</span><br><span class="line"><span class="keyword">goto</span> done</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        扫描根对象需要使用<code> runtime.markroot</code>，该函数会扫描缓存、数据段、存放全局变量和静态变量的 BSS 段以及 Goroutine 的栈内存；一旦完成了对根对象的扫描，当前 Goroutine 会开始从本地和全局的工作缓存池中获取待执行的任务：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcDrain</span><span class="params">(gcw *gcWork, flags gcDrainFlags)</span></span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> !(preemptible &amp;&amp; gp.preempt) &#123;</span><br><span class="line"><span class="keyword">if</span> work.full == <span class="number">0</span> &#123;</span><br><span class="line">gcw.balance()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b := gcw.tryGetFast()</span><br><span class="line"><span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">b = gcw.tryGet()</span><br><span class="line"><span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">wbBufFlush(<span class="literal">nil</span>, <span class="number">0</span>)</span><br><span class="line">b = gcw.tryGet()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">scanobject(b, gcw)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> gcw.scanWork &gt;= gcCreditSlack &#123;</span><br><span class="line">atomic.Xaddint64(&amp;gcController.scanWork, gcw.scanWork)</span><br><span class="line"><span class="keyword">if</span> flushBgCredit &#123;</span><br><span class="line">gcFlushBgCredit(gcw.scanWork - initScanWork)</span><br><span class="line">initScanWork = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">checkWork -= gcw.scanWork</span><br><span class="line">gcw.scanWork = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> checkWork &lt;= <span class="number">0</span> &#123;</span><br><span class="line">checkWork += drainCheckThreshold</span><br><span class="line"><span class="keyword">if</span> check != <span class="literal">nil</span> &amp;&amp; check() &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        扫描对象会使用 <code>runtime.scanobject</code>，该函数会从传入的位置开始扫描，扫描期间会调用 <code>runtime.greyobject</code> 为找到的活跃对象上色。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcDrain</span><span class="params">(gcw *gcWork, flags gcDrainFlags)</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">done:</span><br><span class="line"><span class="keyword">if</span> gcw.scanWork &gt; <span class="number">0</span> &#123;</span><br><span class="line">atomic.Xaddint64(&amp;gcController.scanWork, gcw.scanWork)</span><br><span class="line"><span class="keyword">if</span> flushBgCredit &#123;</span><br><span class="line">gcFlushBgCredit(gcw.scanWork - initScanWork)</span><br><span class="line">&#125;</span><br><span class="line">gcw.scanWork = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当本轮的扫描因为外部条件变化而中断时，该函数会通过 <code>runtime.gcFlushBgCredit</code> 记录这次扫描的内存字节数用于减少辅助标记的工作量。</p><p>内存中对象的扫描和标记过程涉及很多位操作和指针操作，相关代码实现比较复杂，我们在这里就不展开介绍相关的内容了，感兴趣的读者可以将 <code>runtime.gcDrain</code> 作为入口研究三色标记的具体过程。</p><h4 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h4><p>写屏障是保证 Go 语言并发标记安全不可或缺的技术，我们需要使用混合写屏障维护对象图的弱三色不变性，然而写屏障的实现需要编译器和运行时的共同协作。在 SSA 中间代码生成阶段，编译器会使用 <code>cmd/compile/internal/ssa.writebarrier </code>在 Store、Move 和 Zero 操作中加入写屏障，生成如下所示的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> writeBarrier.enabled &#123;</span><br><span class="line">  gcWriteBarrier(ptr, val)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  *ptr = val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        当 Go 语言进入垃圾收集阶段时，全局变量 <code>runtime.writeBarrier</code> 中的 enabled 字段会被置成开启，所有的写操作都会调用<code> runtime.gcWriteBarrier</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">TEXT runtime·gcWriteBarrier(SB),NOSPLIT,$<span class="number">28</span></span><br><span class="line">...</span><br><span class="line">get_tls(BX)</span><br><span class="line">MOVLg(BX), BX</span><br><span class="line">MOVLg_m(BX), BX</span><br><span class="line">MOVLm_p(BX), BX</span><br><span class="line">MOVL(p_wbBuf+wbBuf_next)(BX), CX</span><br><span class="line">LEAL<span class="number">8</span>(CX), CX</span><br><span class="line">MOVLCX, (p_wbBuf+wbBuf_next)(BX)</span><br><span class="line">CMPLCX, (p_wbBuf+wbBuf_end)(BX)</span><br><span class="line">MOVLAX, <span class="number">-8</span>(CX)<span class="comment">// 记录值</span></span><br><span class="line">MOVL(DI), BX</span><br><span class="line">MOVLBX, <span class="number">-4</span>(CX)<span class="comment">// 记录 *slot</span></span><br><span class="line">JEQflush</span><br><span class="line">ret:</span><br><span class="line">MOVL<span class="number">20</span>(SP), CX</span><br><span class="line">MOVL<span class="number">24</span>(SP), BX</span><br><span class="line">MOVLAX, (DI) <span class="comment">// 触发写操作</span></span><br><span class="line">RET</span><br><span class="line"></span><br><span class="line">flush:</span><br><span class="line">  ...</span><br><span class="line">CALLruntime·wbBufFlush(SB)</span><br><span class="line">  ...</span><br><span class="line">JMPret</span><br></pre></td></tr></table></figure><p>在上述汇编函数中，DI 寄存器是写操作的目的地址，AX 寄存器中存储了被覆盖的值，该函数会覆盖原来的值并通过 <code>runtime.wbBufFlush</code> 通知垃圾收集器将原值和新值加入当前处理器的工作队列，因为该写屏障的实现比较复杂，所以写屏障对程序的性能还是有比较大的影响，之前只需要一条指令完成的工作，现在需要几十条指令。</p><p>我们在上面提到过 Dijkstra 和 Yuasa 写屏障组成的混合写屏障在开启后，所有新创建的对象都需要被直接涂成黑色，这里的标记过程是由<code> runtime.gcmarknewobject</code> 完成的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocgc</span><span class="params">(size <span class="keyword">uintptr</span>, typ *_type, needzero <span class="keyword">bool</span>)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> gcphase != _GCoff &#123;</span><br><span class="line">gcmarknewobject(span, <span class="keyword">uintptr</span>(x), size, scanSize)</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcmarknewobject</span><span class="params">(span *mspan, obj, size, scanSize <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line">objIndex := span.objIndex(obj)</span><br><span class="line">span.markBitsForIndex(objIndex).setMarked()</span><br><span class="line"></span><br><span class="line">arena, pageIdx, pageMask := pageIndexOf(span.base())</span><br><span class="line"><span class="keyword">if</span> arena.pageMarks[pageIdx]&amp;pageMask == <span class="number">0</span> &#123;</span><br><span class="line">atomic.Or8(&amp;arena.pageMarks[pageIdx], pageMask)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gcw := &amp;getg().m.p.ptr().gcw</span><br><span class="line">gcw.bytesMarked += <span class="keyword">uint64</span>(size)</span><br><span class="line">gcw.scanWork += <span class="keyword">int64</span>(scanSize)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        <code>runtime.mallocgc</code> 会在垃圾收集开始后调用该函数，获取对象对应的内存单元以及标记位 <code>runtime.markBits</code> 并调用 <code>runtime.markBits.setMarked </code>直接将新的对象涂成黑色。</p><h4 id="标记辅助"><a href="#标记辅助" class="headerlink" title="标记辅助"></a>标记辅助</h4><p>​        为了保证用户程序分配内存的速度不会超出后台任务的标记速度，运行时还引入了标记辅助技术，它遵循一条非常简单并且朴实的原则，<strong>分配多少内存就需要完成多少标记任务</strong>。每一个 Goroutine 都持有 <code>gcAssistBytes</code> 字段，这个字段存储了当前 Goroutine 辅助标记的对象字节数。在并发标记阶段期间，当 Goroutine 调用  <code>runtime.mallocgc</code> 分配新对象时，该函数会检查申请内存的 Goroutine 是否处于入不敷出的状态：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocgc</span><span class="params">(size <span class="keyword">uintptr</span>, typ *_type, needzero <span class="keyword">bool</span>)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">var</span> assistG *g</span><br><span class="line"><span class="keyword">if</span> gcBlackenEnabled != <span class="number">0</span> &#123;</span><br><span class="line">assistG = getg()</span><br><span class="line"><span class="keyword">if</span> assistG.m.curg != <span class="literal">nil</span> &#123;</span><br><span class="line">assistG = assistG.m.curg</span><br><span class="line">&#125;</span><br><span class="line">assistG.gcAssistBytes -= <span class="keyword">int64</span>(size)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> assistG.gcAssistBytes &lt; <span class="number">0</span> &#123;</span><br><span class="line">gcAssistAlloc(assistG)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        申请内存时调用的<code>runtime.gcAssistAlloc</code>和扫描内存时调用的<code>runtime.gcFlushBgCredit</code>分别负责借债和还债，通过这套债务管理系统，我们能够保证 Goroutine 在正常运行的同时不会为垃圾收集造成太多的压力，保证在达到堆大小目标时完成标记阶段。</p><p><img src="https://img.draveness.me/2020-03-16-15843705141935-gc-mutator-assist.png" class="lazyload" data-srcset="https://img.draveness.me/2020-03-16-15843705141935-gc-mutator-assist.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="gc-mutator-assist"></p><p>​        每个 Goroutine 持有的 <code>gcAssistBytes</code> 表示当前协程辅助标记的字节数，全局垃圾收集控制器持有的 <code>bgScanCredit</code> 表示后台协程辅助标记的字节数，当本地 Goroutine 分配了较多对象时，可以使用公用的信用 <code>bgScanCredit</code> 偿还。我们先来分析<code> runtime.gcAssistAlloc</code> 的实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcAssistAlloc</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">retry:</span><br><span class="line">debtBytes := -gp.gcAssistBytes</span><br><span class="line">scanWork := <span class="keyword">int64</span>(gcController.assistWorkPerByte * <span class="keyword">float64</span>(debtBytes))</span><br><span class="line"><span class="keyword">if</span> scanWork &lt; gcOverAssistWork &#123;</span><br><span class="line">scanWork = gcOverAssistWork</span><br><span class="line">debtBytes = <span class="keyword">int64</span>(gcController.assistBytesPerWork * <span class="keyword">float64</span>(scanWork))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bgScanCredit := atomic.Loadint64(&amp;gcController.bgScanCredit)</span><br><span class="line">stolen := <span class="keyword">int64</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> bgScanCredit &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> bgScanCredit &lt; scanWork &#123;</span><br><span class="line">stolen = bgScanCredit</span><br><span class="line">gp.gcAssistBytes += <span class="number">1</span> + <span class="keyword">int64</span>(gcController.assistBytesPerWork*<span class="keyword">float64</span>(stolen))</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">stolen = scanWork</span><br><span class="line">gp.gcAssistBytes += debtBytes</span><br><span class="line">&#125;</span><br><span class="line">atomic.Xaddint64(&amp;gcController.bgScanCredit, -stolen)</span><br><span class="line">scanWork -= stolen</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> scanWork == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        该函数会先根据 Goroutine 的 <code>gcAssistBytes</code> 和垃圾收集控制器的配置计算需要完成的标记任务数量，如果全局信用 <code>bgScanCredit</code> 中有可用的点数，那么会减去该点数，因为并发执行没有加锁，所以全局信用可能会被更新成负值，然而在长期来看这不是一个比较重要的问题。</p><p>​        如果全局信用不足以覆盖本地的债务，运行时会在系统栈中调用 <code>runtime.gcAssistAlloc1 </code>执行标记任务，它会直接调用 <code>runtime.gcDrainN</code> 完成指定数量的标记任务并返回：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcAssistAlloc</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">gcAssistAlloc1(gp, scanWork)</span><br><span class="line">&#125;)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> gp.gcAssistBytes &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> gp.preempt &#123;</span><br><span class="line">Gosched()</span><br><span class="line"><span class="keyword">goto</span> retry</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !gcParkAssist() &#123;</span><br><span class="line"><span class="keyword">goto</span> retry</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        如果在完成标记辅助任务后，当前 Goroutine 仍然入不敷出并且 Goroutine 没有被抢占，那么运行时会执行 <code>runtime.gcParkAssist</code>；如果全局信用仍然不足，运行时会通过<code> runtime.gcParkAssist</code> 将当前 Goroutine 陷入休眠、加入全局的辅助标记队列并等待后台标记任务的唤醒。</p><p>​        用于还债的<code>runtime.gcFlushBgCredit</code>的实现比较简单，如果辅助队列中不存在等待的 Goroutine，那么当前的信用会直接加到全局信用 <code>bgScanCredit </code>中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcFlushBgCredit</span><span class="params">(scanWork <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> work.assistQueue.q.empty() &#123;</span><br><span class="line">atomic.Xaddint64(&amp;gcController.bgScanCredit, scanWork)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">scanBytes := <span class="keyword">int64</span>(<span class="keyword">float64</span>(scanWork) * gcController.assistBytesPerWork)</span><br><span class="line"><span class="keyword">for</span> !work.assistQueue.q.empty() &amp;&amp; scanBytes &gt; <span class="number">0</span> &#123;</span><br><span class="line">gp := work.assistQueue.q.pop()</span><br><span class="line"><span class="keyword">if</span> scanBytes+gp.gcAssistBytes &gt;= <span class="number">0</span> &#123;</span><br><span class="line">scanBytes += gp.gcAssistBytes</span><br><span class="line">gp.gcAssistBytes = <span class="number">0</span></span><br><span class="line">ready(gp, <span class="number">0</span>, <span class="literal">false</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">gp.gcAssistBytes += scanBytes</span><br><span class="line">scanBytes = <span class="number">0</span></span><br><span class="line">work.assistQueue.q.pushBack(gp)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> scanBytes &gt; <span class="number">0</span> &#123;</span><br><span class="line">scanWork = <span class="keyword">int64</span>(<span class="keyword">float64</span>(scanBytes) * gcController.assistWorkPerByte)</span><br><span class="line">atomic.Xaddint64(&amp;gcController.bgScanCredit, scanWork)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        如果辅助队列不为空，上述函数会根据每个 Goroutine 的债务数量和已完成的工作决定是否唤醒这些陷入休眠的 Goroutine；如果唤醒所有的 Goroutine 后，标记任务量仍然有剩余，这些标记任务都会加入全局信用中。</p><p><img src="https://img.draveness.me/2020-03-16-15843705141941-global-credit-and-assist-bytes.png" class="lazyload" data-srcset="https://img.draveness.me/2020-03-16-15843705141941-global-credit-and-assist-bytes.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="global-credit-and-assist-bytes"></p><p>​        用户程序辅助标记的核心目的是避免用户程序分配内存影响垃圾收集器完成标记工作的期望时间，它通过维护账户体系保证用户程序不会对垃圾收集造成过多的负担，一旦用户程序分配了大量的内存，该用户程序就会通过辅助标记的方式平衡账本，这个过程会在最后达到相对平衡，保证标记任务在到达期望堆大小时完成。</p><h3 id="标记终止"><a href="#标记终止" class="headerlink" title="标记终止"></a>标记终止</h3><p>当所有处理器的本地任务都完成并且不存在剩余的工作 Goroutine 时，后台并发任务或者辅助标记的用户程序会调用<code> runtime.gcMarkDone</code> 通知垃圾收集器。当所有可达对象都被标记后，该函数会将垃圾收集的状态切换至 <code>_GCmarktermination</code>；如果本地队列中仍然存在待处理的任务，当前方法会将所有的任务加入全局队列并等待其他 Goroutine 完成处理：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcMarkDone</span><span class="params">()</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">top:</span><br><span class="line"><span class="keyword">if</span> !(gcphase == _GCmark &amp;&amp; work.nwait == work.nproc &amp;&amp; !gcMarkWorkAvailable(<span class="literal">nil</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gcMarkDoneFlushed = <span class="number">0</span></span><br><span class="line">systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">gp := getg().m.curg</span><br><span class="line">casgstatus(gp, _Grunning, _Gwaiting)</span><br><span class="line">forEachP(<span class="function"><span class="keyword">func</span><span class="params">(_p_ *p)</span></span> &#123;</span><br><span class="line">wbBufFlush1(_p_)</span><br><span class="line">_p_.gcw.dispose()</span><br><span class="line"><span class="keyword">if</span> _p_.gcw.flushedWork &#123;</span><br><span class="line">atomic.Xadd(&amp;gcMarkDoneFlushed, <span class="number">1</span>)</span><br><span class="line">_p_.gcw.flushedWork = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">casgstatus(gp, _Gwaiting, _Grunning)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> gcMarkDoneFlushed != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">goto</span> top</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        如果运行时中不包含全局任务、处理器中也不存在本地任务，那么当前垃圾收集循环中的灰色对象也都标记成了黑色，我们就可以开始触发垃圾收集的阶段迁移了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcMarkDone</span><span class="params">()</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">getg().m.preemptoff = <span class="string">&quot;gcing&quot;</span></span><br><span class="line">systemstack(stopTheWorldWithSema)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">atomic.Store(&amp;gcBlackenEnabled, <span class="number">0</span>)</span><br><span class="line">gcWakeAllAssists()</span><br><span class="line">schedEnableUser(<span class="literal">true</span>)</span><br><span class="line">nextTriggerRatio := gcController.endCycle()</span><br><span class="line">gcMarkTermination(nextTriggerRatio)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        上述函数在最后会关闭混合写屏障、唤醒所有协助垃圾收集的用户程序、恢复用户 Goroutine 的调度并调用 <code>runtime.gcMarkTermination</code> 进入标记终止阶段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcMarkTermination</span><span class="params">(nextTriggerRatio <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">atomic.Store(&amp;gcBlackenEnabled, <span class="number">0</span>)</span><br><span class="line">setGCPhase(_GCmarktermination)</span><br><span class="line"></span><br><span class="line">_g_ := getg()</span><br><span class="line">gp := _g_.m.curg</span><br><span class="line">casgstatus(gp, _Grunning, _Gwaiting)</span><br><span class="line"></span><br><span class="line">systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">gcMark(startTime)</span><br><span class="line">&#125;)</span><br><span class="line">systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">setGCPhase(_GCoff)</span><br><span class="line">gcSweep(work.mode)</span><br><span class="line">&#125;)</span><br><span class="line">casgstatus(gp, _Gwaiting, _Grunning)</span><br><span class="line">gcSetTriggerRatio(nextTriggerRatio)</span><br><span class="line">wakeScavenger()</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">injectglist(&amp;work.sweepWaiters.list)</span><br><span class="line">systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; startTheWorldWithSema(<span class="literal">true</span>) &#125;)</span><br><span class="line">prepareFreeWorkbufs()</span><br><span class="line">systemstack(freeStackSpans)</span><br><span class="line">systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">forEachP(<span class="function"><span class="keyword">func</span><span class="params">(_p_ *p)</span></span> &#123;</span><br><span class="line">_p_.mcache.prepareForSweep()</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        我们省略了该函数中很多数据统计的代码，包括正在使用的内存大小、本轮垃圾收集的暂停时间、CPU 的利用率等数据，这些数据能够帮助控制器决定下一轮触发垃圾收集的堆大小，除了数据统计之外，该函数还会调用 <code>runtime.gcSweep</code> 重置清理阶段的相关状态并在需要时阻塞清理所有的内存管理单元；<code>_GCmarktermination </code>状态在垃圾收集中并不会持续太久，它会迅速转换至 <code>_GCoff </code>并恢复应用程序，到这里垃圾收集的全过程基本上就结束了，用户程序在申请内存时才会惰性回收内存。</p><h3 id="内存清理"><a href="#内存清理" class="headerlink" title="内存清理"></a>内存清理</h3><p>垃圾收集的清理中包含对象回收器（Reclaimer）和内存单元回收器，这两种回收器使用不同的算法清理堆内存：</p><ul><li><p>对象回收器在内存管理单元中查找并释放未被标记的对象，但是如果 <code>runtime.mspan </code>中的所有对象都没有被标记，整个单元就会被直接回收，该过程会被 <code>runtime.mcentral.cacheSpan </code>或者 <code>runtime.sweepone</code> 异步触发；</p></li><li><p>内存单元回收器会在内存中查找所有的对象都未被标记的<code> runtime.mspan</code>，该过程会被 <code>runtime.mheap.reclaim</code> 触发；</p></li></ul><p><code>runtime.sweepone </code>是我们在垃圾收集过程中经常会见到的函数，它会在堆内存中查找待清理的内存管理单元：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sweepone</span><span class="params">()</span> <span class="title">uintptr</span></span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">var</span> s *mspan</span><br><span class="line">sg := mheap_.sweepgen</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">s = mheap_.nextSpanForSweep()</span><br><span class="line"><span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> state := s.state.get(); state != mSpanInUse &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> s.sweepgen == sg<span class="number">-2</span> &amp;&amp; atomic.Cas(&amp;s.sweepgen, sg<span class="number">-2</span>, sg<span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">npages := ^<span class="keyword">uintptr</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> s != <span class="literal">nil</span> &#123;</span><br><span class="line">npages = s.npages</span><br><span class="line"><span class="keyword">if</span> s.sweep(<span class="literal">false</span>) &#123;</span><br><span class="line">atomic.Xadduintptr(&amp;mheap_.reclaimCredit, npages)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">npages = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_g_.m.locks--</span><br><span class="line"><span class="keyword">return</span> npages</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        查找内存管理单元时会通过 <code>state</code> 和 <code>sweepgen</code> 两个字段判断当前单元是否需要处理。如果内存单元的 <code>sweepgen</code> 等于 <code>mheap.sweepgen - 2</code>，那么意味着当前单元需要清理，如果等于 <code>mheap.sweepgen - 1</code>，那么当前管理单元就正在清理。</p><p>​        所有的回收工作最终都是靠<code> runtime.mspan.sweep</code> 完成的，它会根据并发标记阶段回收内存单元中的垃圾并清除标记以免影响下一轮垃圾收集。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>​        Go 语言垃圾收集器的实现非常复杂，作者认为这是编程语言中最复杂的模块，调度器的复杂度与垃圾收集器完全不是一个级别，我们在分析垃圾收集器的过程中不得不省略很多的实现细节，其中包括并发标记对象的过程、清扫垃圾的具体实现，这些过程设计大量底层的位操作和指针操作，本节中包含所有的相关代码的链接，感兴趣的读者可以自行探索。</p><p>​        垃圾收集是一门非常古老的技术，它的执行速度和利用率很大程度上决定了程序的运行速度，Go 语言为了实现高性能的并发垃圾收集器，使用三色抽象、并发增量回收、混合写屏障、调步算法以及用户程序协助等机制将垃圾收集的暂停时间优化至毫秒级以下，从早期的版本看到今天，我们能体会到其中的工程设计和演进，作者觉得研究垃圾收集的是实现原理还是非常值得的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Go中垃圾收集器的详细介绍。&lt;/p&gt;</summary>
    
    
    
    <category term="Go" scheme="http://xucoud.github.io/categories/Go/"/>
    
    <category term="GC" scheme="http://xucoud.github.io/categories/Go/GC/"/>
    
    
    <category term="Go" scheme="http://xucoud.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>GMP</title>
    <link href="http://xucoud.github.io/2021/10/21/GMP/"/>
    <id>http://xucoud.github.io/2021/10/21/GMP/</id>
    <published>2021-10-21T07:31:41.000Z</published>
    <updated>2021-12-03T16:23:21.544Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Golang 调度器 GMP 原理与调度全分析</p><span id="more"></span><h2 id="GMP基本概念"><a href="#GMP基本概念" class="headerlink" title="GMP基本概念"></a>GMP基本概念</h2><h4 id="G（goroutine）"><a href="#G（goroutine）" class="headerlink" title="G（goroutine）"></a>G（goroutine）</h4><ul><li>调度系统的最基本单位goroutine，存储了goroutine的执行stack信息、goroutine状态以及goroutine的任务函数等。</li><li>在G的眼中只有P，P就是运行G的“CPU”。</li><li>相当于两级线程。</li></ul><h4 id="P（processor）"><a href="#P（processor）" class="headerlink" title="P（processor）"></a>P（processor）</h4><ul><li>P表示逻辑processor，代表线程M的执行的上下文。</li><li>P的最大作用是其拥有的各种G对象队列、链表、cache和状态。</li><li>P的数量也代表了golang的执行并发度，即有多少goroutine可以同时运行。</li></ul><blockquote><p>这里的p虽然表示逻辑处理器，但P并不执行任何代码，对G来说，P相当于CPU核，G只有绑定到P才能被调度。 对M来说，P提供了相关的执行环境(Context)，如内存分配状态(mcache)，任务队列(G)等</p></blockquote><h4 id="M（machine）"><a href="#M（machine）" class="headerlink" title="M（machine）"></a>M（machine）</h4><ul><li>M代表着真正的执行计算资源，可以认为它就是os thread（系统线程）。</li><li>M是真正调度系统的执行者，每个M就像一个勤劳的工作者，总是从各种队列中找到可运行的G，而且这样M的可以同时存在多个。</li><li>M在绑定有效的P后，进入调度循环，而且M并不保留G状态，这是G可以跨M调度的基础。</li></ul><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20211204002304.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20211204002304.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20211204002255511" style="zoom: 50%;" /><h2 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h2><ul><li>runtime<br><code>runtime</code> 也叫运行时，对golang程序很重要，runtime包含了调度、内存管理、垃圾回收、内部数据结构、定时器和各种系统调用的封装等。可以说golang的强大都归功于runtime的实现。</li><li>scheduler<br><code>scheduler</code> 有调度器、日程安排的意思，这里是指调度器，它的工作是将准备好运行的goroutine分散到工作线程中执行。</li><li>TLS(thread local storage)<br><code>TLS</code>全称是Thread Local Storage，代表每个线程中的本地数据。写入TLS中的数据不会干扰到其余线程中的值。Go的协程实现非常依赖于TLS机制，会用于获取系统线程中当前的G和G所属于的M实例。 Go操作TLS会使用系统原生的接口，以Linux X64为例，go在新建M时候会调用 arch_prctl 这个syscall来设置FS寄存器的值为M.tls的地址，运行中每个M的FS寄存器都会指向它们对应的M实例的tls， linux内核调度线程时FS寄存器会跟着线程一起切换，这样go代码只需要访问FS寄存器就可以获取到线程本地的数据。</li><li>spinning<br><code>spinning</code> 表示自旋，字面的意思是自己围绕自己转。在程序里一般指一直重复某块代码。</li><li>systemstack、mcall或asmcgocall<br>每个M启动都有一个叫g0的系统堆栈，runtime通常使用<code>systemstack</code>、<code>mcall</code>或<code>asmcgocall</code>临时切换到系统堆栈，以执行必须不被抢占的任务、不得增加用户堆栈的任务或切换用户goroutines。在系统堆栈上运行的代码隐式不可抢占，垃圾收集器不扫描系统堆栈。在系统堆栈上运行时，不会使用当前用户堆栈执行。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Golang 调度器 GMP 原理与调度全分析&lt;/p&gt;</summary>
    
    
    
    <category term="Go" scheme="http://xucoud.github.io/categories/Go/"/>
    
    <category term="GMP" scheme="http://xucoud.github.io/categories/Go/GMP/"/>
    
    
    <category term="Go" scheme="http://xucoud.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go Module</title>
    <link href="http://xucoud.github.io/2021/10/20/Go-Moudle/"/>
    <id>http://xucoud.github.io/2021/10/20/Go-Moudle/</id>
    <published>2021-10-20T09:15:01.000Z</published>
    <updated>2022-01-04T11:45:55.094Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>go中module的使用方法以及基本介绍</p><span id="more"></span><pre><code>    自从 Go 官方推出 1.11 之后，增加新的依赖管理模块并且更加易于管理项目中所需要的模块。模块是存储在文件树中的 Go 包的集合，其根目录中包含 `go.mod` 文件。 `go.mod` 文件定义了模块的模块路径，它也是用于根目录的导入路径，以及它的依赖性要求。每个依赖性要求都被写为模块路径和特定语义版本。</code></pre><p>​        从 Go 1.11 开始，Go 允许在 <code>$GOPATH/src</code> 外的任何目录下使用 <code>go.mod</code> 创建项目。在 <code>$GOPATH/src</code> 中，为了兼容性，Go 命令仍然在旧的 GOPATH 模式下运行。从 Go 1.13 开始，模块模式将成为默认模式。<br>下面使用的案例都是以 <code>GIN</code> 模块为例。<br>在这之前呢，需要先设置一些环境变量：</p><blockquote><p>export GO111MODULE=on //开启Go Module<br>export GOPROXY=<a href="https://goproxy.io/">https://goproxy.io</a>  // 设置代理</p></blockquote><h2 id="创建一个新模块"><a href="#创建一个新模块" class="headerlink" title="创建一个新模块"></a>创建一个新模块</h2><p>你可以在 $GOPATH/src 之外的任何地方创建一个新的目录。比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir backend &amp;&amp; cd backend</span><br></pre></td></tr></table></figure><p>然后初始化 <code>go mod init backend</code>，成功之后你会发现目录下会生成一个 <code>go.mod</code> 文件.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat go.mod</span><br></pre></td></tr></table></figure><p>内容如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">module backend</span><br><span class="line">go 1.12</span><br></pre></td></tr></table></figure><h2 id="添加依赖项"><a href="#添加依赖项" class="headerlink" title="添加依赖项"></a>添加依赖项</h2><p>创建一个文件 <code>main.go</code> 然后加入以下代码，这里直接 import 了 gin 的依赖包。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line">    r.GET(<span class="string">&quot;/ping&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">            <span class="string">&quot;message&quot;</span>: <span class="string">&quot;pong&quot;</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    r.Run() <span class="comment">// listen and serve on 0.0.0.0:8080</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>go build 之后，会在 go.mod 引入所需要的依赖包。之后再来看看 go.mod 文件的情况。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">module backend</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.12</span></span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">    github.com/gin-contrib/sse v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20190301062529</span><span class="number">-5545</span>eab6dad3 <span class="comment">// indirect</span></span><br><span class="line">    github.com/gin-gonic/gin v1<span class="number">.3</span><span class="number">.0</span></span><br><span class="line">    github.com/golang/protobuf v1<span class="number">.3</span><span class="number">.1</span> <span class="comment">// indirect</span></span><br><span class="line">    github.com/mattn/<span class="keyword">go</span>-isatty v0<span class="number">.0</span><span class="number">.7</span> <span class="comment">// indirect</span></span><br><span class="line">    github.com/ugorji/<span class="keyword">go</span> v1<span class="number">.1</span><span class="number">.4</span> <span class="comment">// indirect</span></span><br><span class="line">    gopkg.in/<span class="keyword">go</span>-playground/validator.v8 v8<span class="number">.18</span><span class="number">.2</span> <span class="comment">// indirect</span></span><br><span class="line">    gopkg.in/yaml.v2 v2<span class="number">.2</span><span class="number">.2</span> <span class="comment">// indirect</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>require 就是 gin 框架所需要的所有依赖包 并且在每个依赖包的后面已经表明了版本号</p><h2 id="升级依赖项"><a href="#升级依赖项" class="headerlink" title="升级依赖项"></a>升级依赖项</h2><p>首先我们需要查看以下我们使用到的依赖列表</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go list -m all</span><br></pre></td></tr></table></figure><p>你会看到所有项目使用的依赖包:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">backend</span><br><span class="line">github.com/gin-contrib/sse v0.0.0-20190301062529-5545eab6dad3</span><br><span class="line">github.com/gin-gonic/gin v1.3.0</span><br><span class="line">github.com/golang/protobuf v1.3.1</span><br><span class="line">github.com/mattn/go-isatty v0.0.7</span><br><span class="line">github.com/ugorji/go v1.1.4</span><br><span class="line">golang.org/x/sys v0.0.0-20190222072716-a9d3bda3a223</span><br><span class="line">gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405</span><br><span class="line">gopkg.in/go-playground/validator.v8 v8.18.2</span><br><span class="line">gopkg.in/yaml.v2 v2.2.2</span><br></pre></td></tr></table></figure><p>​        因为这里使用的是最新的版本，无法升级，所以这里给出一个回退的例子。将 GIN 框架的版本回退到上个版本。这里需要使用一个命令查看依赖的版本历史。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go list -m -versions github.com/gin-gonic/gin</span><br></pre></td></tr></table></figure><p>将会列出 Gin 版本历史</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">github.com/gin-gonic/gin v1.1.1 v1.1.2 v1.1.3 v1.1.4 v1.3.0</span><br></pre></td></tr></table></figure><p>将版本更新到上个版本，这里只是个演示。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/gin-gonic/gin@v1.1.4 // 只需要在依赖后面加上 @version 就可以了</span><br><span class="line">go list -m all</span><br></pre></td></tr></table></figure><p>看到了版本变化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">github.com/gin-gonic/gin v1.1.4</span><br></pre></td></tr></table></figure><p>或者可以使用 <code>go mod</code> 来进行版本的切换，这样就需要两个步骤了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go mod edit -require=&quot;github.com/gin-gonic/gin@v1.1.4&quot; // 修改 go.mod 文件</span><br><span class="line">go tidy //下载更新依赖</span><br></pre></td></tr></table></figure><p><code>go.tidy</code> 会自动清理掉不需要的依赖项，同时可以将依赖项更新到当前版本</p><p>使用起来这是一个很简单过程，只需要几个命令，你便可以知道依赖的版本信息，以及自由选择安装的版本，一切都变得这么简单。</p><h2 id="删除未使用的依赖项"><a href="#删除未使用的依赖项" class="headerlink" title="删除未使用的依赖项"></a>删除未使用的依赖项</h2><p>如果你在项目过程需要移除一些不需要的依赖，可以使用下面的命令来执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod tidy</span><br></pre></td></tr></table></figure><p>更多关于 go mod 的使用命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">go mod</span><br><span class="line">The commands are:    </span><br><span class="line">    download    download modules to local cache</span><br><span class="line">    edit        edit go.mod from tools or scripts</span><br><span class="line">    graph       print module requirement graph</span><br><span class="line">    init        initialize new module in current directory</span><br><span class="line">    tidy        add missing and remove unused modules</span><br><span class="line">    vendor      make vendored copy of dependencies</span><br><span class="line">    verify      verify dependencies have expected content</span><br><span class="line">    why         explain why packages or modules are needed</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;go中module的使用方法以及基本介绍&lt;/p&gt;</summary>
    
    
    
    <category term="Go" scheme="http://xucoud.github.io/categories/Go/"/>
    
    <category term="module" scheme="http://xucoud.github.io/categories/Go/module/"/>
    
    
    <category term="Go" scheme="http://xucoud.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go-Template</title>
    <link href="http://xucoud.github.io/2021/10/17/%E6%A8%A1%E6%9D%BF%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://xucoud.github.io/2021/10/17/%E6%A8%A1%E6%9D%BF%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2021-10-17T08:53:15.000Z</published>
    <updated>2022-01-04T11:45:38.544Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>go中的模板的使用方法和基本介绍</p><span id="more"></span><p>​        Go为我们提供了 <code>text /template</code> 库和 <code>html /template</code> 库这两个模板引擎，模板引<br>擎通过将数据和模板组合在一起生成最终的 HTML ，而处理器负责调用模板引擎并将引<br>擎生成的 HTMl 返回给客户端。<br>​        Go 的模板都是文本文档（其中 Web 应用的模板通常都是 HTML ），它们都嵌入了<br>一些称为 <strong>动作</strong> 的指令。从模板引擎的角度来说，模板就是嵌入了动作的文本（这些文本<br>通常包含在模板文件里面），而模板引擎则通过分析并执行这些文本来生成出另外一些<br>文本。</p><p>​        这两个模板库的使用方式是相同的，但是 html/template 包在渲染页面模板时会在后台进行一些编码以帮助防止造成代码注入（XSS 攻击）。</p><p>​        因为两个模板库都使用相同的接口，因此本文中介绍的所有内容均可用于这两个程序包，但是大多数时候我们都会使用 html/template 程序包来生成 HTML 代码段。</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>在Go中，使用模板只需要三个步骤：</p><ul><li><p>定义模板</p></li><li><p>解析模板</p></li><li><p>执行模板</p></li></ul><h2 id="定义模板"><a href="#定义模板" class="headerlink" title="定义模板"></a>定义模板</h2><p>​        通常我们会将写好的静态网页作为模板，模板文件以<code>.tmpl</code>或<code>.html</code>结尾，这个模板中可以只包含一个<code>HTML</code>页面中的部分代码。</p><h3 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=utf-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Go Web<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        &#123;&#123; . &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​         中间的半角句号 . 它代表模板对象执行 <code>Execute(w, data) </code>传入模板的数据，它是顶级作用域范围内的，根据传入的数据不同渲染不同的内容。. 可以代表 Go 语言中的任何类型，如结构体、Map 等。在写模板的时候，会经常用到.。比如 <code>&#123;&#123;.&#125;&#125;</code>、<code>&#123;&#123;len .&#125;&#125;</code>、<code>&#123;&#123;.Name&#125;&#125;</code>、<code>&#123;&#123;$x.Name&#125;&#125;</code></p> 包裹的内容统称为 `action`，分为两种类型：<ul><li><p>数据求值（data evaluations）</p></li><li><p>控制结构（control structures）</p></li></ul><p>​        action 求值的结果会直接复制到模板中，控制结构和我们写 Go 程序差不多，也是条件语句、循环语句、变量、函数调用等等… 模板中的 action 并不多，我们一个一个看。</p><h2 id="动作"><a href="#动作" class="headerlink" title="动作"></a>动作</h2><h3 id="裁剪空字符"><a href="#裁剪空字符" class="headerlink" title="裁剪空字符"></a>裁剪空字符</h3><p>​        注意裁剪的是替换内容前面或者后面的空字符，你可以理解成模板中  后面的空字符 (包括换行符、制表符、空格等)。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 裁剪 content 前后的空字符</span></span><br><span class="line">&#123;&#123;- content -&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 裁剪 content 前面的空字符</span></span><br><span class="line">&#123;&#123;- content &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 裁剪 content 后面的空字符</span></span><br><span class="line">&#123;&#123; content -&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="文本输出"><a href="#文本输出" class="headerlink" title="文本输出"></a>文本输出</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; pipeline &#125;&#125;</span><br></pre></td></tr></table></figure><p><code>pipeline</code> 代表的数据会产生与调用 <code>fmt.Print</code> 函数类似的输出，例如整数类型的 3 会转换成字符串 “3” 输出。</p><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; <span class="keyword">if</span> pipeline &#125;&#125; T1 &#123;&#123; end &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123; <span class="keyword">if</span> pipeline &#125;&#125; T1 &#123;&#123; <span class="keyword">else</span> &#125;&#125; T0 &#123;&#123; end &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123; <span class="keyword">if</span> pipeline &#125;&#125; T1 &#123;&#123; <span class="keyword">else</span> <span class="keyword">if</span> pipeline &#125;&#125; T0 &#123;&#123; end &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的语法其实是下面的简写</span></span><br><span class="line">&#123;&#123; <span class="keyword">if</span> pipeline &#125;&#125; T1 &#123;&#123; <span class="keyword">else</span> &#125;&#125;&#123;&#123; <span class="keyword">if</span> pipeline &#125;&#125; T0 &#123; &#123;end &#125;&#125;&#123;&#123; end &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123; <span class="keyword">if</span> pipeline &#125;&#125; T1 &#123;&#123; <span class="keyword">else</span> <span class="keyword">if</span> pipeline &#125;&#125; T2 &#123;&#123; <span class="keyword">else</span> &#125;&#125; T0 &#123;&#123; end &#125;&#125;</span><br></pre></td></tr></table></figure><p>​        如果 pipeline 的值为空，不会输出 T1，除此之外 T1 都会被输出。空值有 <code>false</code>、<code>0</code>、 <code>nil</code> 空字符串 <code>&quot;&quot;</code>（长度为 0 的字符串）。</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p><code>if.html</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">content</span>=<span class="string">&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>if<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    &#123;&#123;if .&#125;&#125;</span><br><span class="line">        我成年了</span><br><span class="line">    &#123;&#123;else&#125;&#125;</span><br><span class="line">        我没有成年</span><br><span class="line">    &#123;&#123;end&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>main.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;html/template&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//条件动作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestIf</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">t := template.Must(template.ParseFiles(<span class="string">&quot;if.html&quot;</span>))</span><br><span class="line">age := <span class="number">19</span></span><br><span class="line">t.Execute(w, age &gt; <span class="number">18</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">&quot;/testif&quot;</span>, TestIf)</span><br><span class="line"></span><br><span class="line">http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p>​        在页面中打印出 “我成年了”，如果将 <code>age</code>改为17，那么将打印出 “我没有成年”。</p><p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20211018233641.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20211018233641.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20211018233640106"></p><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; <span class="keyword">range</span> pipeline &#125;&#125; T1 &#123;&#123; end &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个 else 比较有意思，如果 pipeline 的长度为 0 则输出 else 中的内容</span></span><br><span class="line">&#123;&#123; <span class="keyword">range</span> pipeline &#125;&#125; T1 &#123;&#123; <span class="keyword">else</span> &#125;&#125; T0 &#123;&#123; end &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取容器的下标</span></span><br><span class="line">&#123;&#123; <span class="keyword">range</span> $index, $value := pipeline &#125;&#125; T1 &#123;&#123; end &#125;&#125;</span><br></pre></td></tr></table></figure><p>​        循环语句中的 <code>pipeline</code> 的值必须是数组、切片、字典和通道中的一种，即可迭代类型的值，根据值的长度输出多个 T1。</p><ul><li><p>迭代结构体，获取结构体中的字段值使用 字段名方式获取<br><code>&#123;&#123;range . &#125;&#125;</code></p><pre><code>获取结构体的 Name 字段名 &#123;&#123; Name &#125;&#125;</code></pre><p><code>&#123;&#123; end &#125;&#125;</code></p></li><li><p>迭代 Map 时可以设置变量，变量以 开头：<br><code>&#123;&#123; range $k , $v := . &#125;&#125;</code></p><pre><code>键是 `&#123;&#123; $k &#125;&#125; `, 值是 `&#123;&#123; $v&#125;&#125;`</code></pre><p><code>&#123;&#123; end &#125;&#125;</code></p></li><li><p>迭代管道<br><code>&#123;&#123; c1 | c2 | c3 &#125;&#125;</code></p><p>c 1 、 c 2 和 c 3 可以是参数或者函数。管道允许用户将一个参数的输出<br>传递给下一个参数，各个参数之间使用 | 分割。</p></li></ul><h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><p><code>range.hrml</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">content</span>=<span class="string">&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>if<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    &#123;&#123;range .&#125;&#125;</span><br><span class="line">        遍历输出：&#123;&#123;.&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    &#123;&#123;end&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>main.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;html/template&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代动作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestRange</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">t := template.Must(template.ParseFiles(<span class="string">&quot;range.html&quot;</span>))</span><br><span class="line"><span class="keyword">var</span> arg []<span class="keyword">int</span></span><br><span class="line">arg = <span class="built_in">append</span>(arg, <span class="number">1</span>)</span><br><span class="line">arg = <span class="built_in">append</span>(arg, <span class="number">2</span>)</span><br><span class="line">arg = <span class="built_in">append</span>(arg, <span class="number">3</span>)</span><br><span class="line">t.Execute(w, arg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">&quot;/testrange&quot;</span>, TestRange)</span><br><span class="line"></span><br><span class="line">http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20211018233629.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20211018233629.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20211018233620952"></p><h3 id="define"><a href="#define" class="headerlink" title="define"></a>define</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; define <span class="string">&quot;name&quot;</span> &#125;&#125; T &#123;&#123; end &#125;&#125;</span><br></pre></td></tr></table></figure><p>定义命名为 name 的模板。</p><h4 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h4><p><code>define.html</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    &#123;&#123;template &quot;content&quot;&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;define &quot;content&quot;&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;www.baidu.com&quot;</span>&gt;</span>百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br></pre></td></tr></table></figure><p><code>main.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;html/template&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义动作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestDefine</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">t := template.Must(template.ParseFiles(<span class="string">&quot;define.html&quot;</span>))</span><br><span class="line">t.ExecuteTemplate(w, <span class="string">&quot;model&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">&quot;/testdefine&quot;</span>, TestDefine)</span><br><span class="line"></span><br><span class="line">http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20211018233954.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20211018233954.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20211018233952640"></p><h3 id="template"><a href="#template" class="headerlink" title="template"></a>template</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; template <span class="string">&quot;name&quot;</span> &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123; template <span class="string">&quot;name&quot;</span> pipeline &#125;&#125;</span><br></pre></td></tr></table></figure><ul><li>第一种是直接执行名为 <code>name</code> 的模板，模板的全局数据对象<code>.</code> 设置为 <code>ni</code>l。</li><li>第二种是点<code>.</code> 设置为 pipeline 的值，并执行名为 <code>name</code> 的模板。</li></ul><blockquote><p>如果定义了多个template文件，传数据的时候，无法将第一个模板获得的数据自动传给页面中引用的模板，需要自己传数据。</p></blockquote><h4 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h4><p><code>tem1.html</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">content</span>=<span class="string">&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>template<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>后台传入数据是：&#123;&#123;.&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>tmp2模板数据<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    &#123;&#123;template &quot;tem2.html&quot;&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>tmp2模板数据<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    &#123;&#123;template &quot;tem2.html&quot; .&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>tem2.html</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">content</span>=<span class="string">&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>if<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>tmp2中后台传入数据：&#123;&#123;.&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>main.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;html/template&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//模板动作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestTmp</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">t := template.Must(template.ParseFiles(<span class="string">&quot;tem1.html&quot;</span>, <span class="string">&quot;tem2.html&quot;</span>))</span><br><span class="line">t.Execute(w, <span class="string">&quot;太子&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">&quot;/testtmp&quot;</span>, TestTmp)</span><br><span class="line"></span><br><span class="line">http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20211018234246.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20211018234246.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20211018234244937"></p><h3 id="blok"><a href="#blok" class="headerlink" title="blok"></a>blok</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; block <span class="string">&quot;name&quot;</span> pipeline &#125;&#125; T1 &#123;&#123; end &#125;&#125;</span><br></pre></td></tr></table></figure><p>​        block 的语义是如果有命名为 name 的模板，就引用过来执行，如果没有命名为 name 的模板，就是执行自己定义的内容。换句话说，block 可以认为是设置一个默认模板。</p><h4 id="例子-4"><a href="#例子-4" class="headerlink" title="例子"></a>例子</h4><p><code>define2.html</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line">&#123;&#123;define &quot;model&quot;&#125;&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    &#123;&#123;template &quot;content&quot;&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 相当于一个默认模板 --&gt;</span></span><br><span class="line">&#123;&#123;block &quot;content&quot; .&#125;&#125;</span><br><span class="line">    你的年龄是假的吧</span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br></pre></td></tr></table></figure><p><code>content1.html</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">content</span>=<span class="string">&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    &#123;&#123;define &quot;content&quot;&#125;&#125;</span><br><span class="line">        我成年了</span><br><span class="line">    &#123;&#123;end&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>main.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;html/template&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//块动作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestBlock</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">age := <span class="number">17</span></span><br><span class="line"><span class="keyword">var</span> t *template.Template</span><br><span class="line"><span class="keyword">if</span> age &gt; <span class="number">18</span> &#123;</span><br><span class="line">t = template.Must(template.ParseFiles(<span class="string">&quot;define2.html&quot;</span>, <span class="string">&quot;content1.html&quot;</span>))</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">t = template.Must(template.ParseFiles(<span class="string">&quot;define2.html&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line">t.ExecuteTemplate(w, <span class="string">&quot;model&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">&quot;/testblock&quot;</span>, TestBlock)</span><br><span class="line"></span><br><span class="line">http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20211018234809.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20211018234809.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20211018234808110"></p><h3 id="with"><a href="#with" class="headerlink" title="with"></a>with</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; with pipeline &#125;&#125; T1 &#123;&#123; end &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 pipeline 是空值则输出 T0</span></span><br><span class="line">&#123;&#123; with pipeline &#125;&#125; T1 &#123;&#123; <span class="keyword">else</span> &#125;&#125; T0 &#123;&#123; end &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123; with arg &#125;&#125;</span><br><span class="line">    . <span class="comment">// 此时 . 就是 arg</span></span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br></pre></td></tr></table></figure><p><code>with </code>创建一个新的上下文环境，在此环境中的<code>.</code>与外面的 <code>.</code> 无关。</p><p>对于第一种格式，当 <code>pipeline</code> 不为 <code>0</code> 值的时候，点. 设置为 <code>pipeline</code> 运算的值，否则跳过。对于第二种格式，当 <code>pipeline</code> 为 <code>0</code> 值时，执行 <code>else</code> 语句块，否则<code>. </code>设置为 <code>pipeline</code> 运算的值，并执行 T1。</p><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;with .Person&#125;&#125;&#123;&#123; .Name&#125;&#125;&#123;&#123;end&#125;&#125;</span><br></pre></td></tr></table></figure><p>在这个 with 块中<code>.Name</code> 实际上引用的是全局数据对象的<code>.Person.Name</code>。</p><h4 id="例子-5"><a href="#例子-5" class="headerlink" title="例子"></a>例子</h4><p><code>with.html</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">content</span>=<span class="string">&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>if<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    &#123;&#123;with &quot;狸猫&quot;&#125;&#125;</span><br><span class="line">        传入的数据是：&#123;&#123;.&#125;&#125;</span><br><span class="line">    &#123;&#123;end&#125;&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">    &#123;&#123;with &quot;&quot;&#125;&#125;</span><br><span class="line">        传入的数据是：&#123;&#123;.&#125;&#125;</span><br><span class="line">    &#123;&#123;else&#125;&#125;</span><br><span class="line">        数据仍是：&#123;&#123;.&#125;&#125;</span><br><span class="line">    &#123;&#123;end&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>main.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;html/template&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//包含动作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestWith</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">t := template.Must(template.ParseFiles(<span class="string">&quot;with.html&quot;</span>))</span><br><span class="line">t.Execute(w, <span class="string">&quot;太子&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">&quot;/testwith&quot;</span>, TestWith)</span><br><span class="line"></span><br><span class="line">http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20211018234942.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20211018234942.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20211018234941287"></p><h3 id="预定义函数"><a href="#预定义函数" class="headerlink" title="预定义函数"></a>预定义函数</h3><p>​        执行模板时，函数从两个函数字典中查找：首先是模板函数字典，然后是全局函数字典。一般不在模板内定义函数，而是使用Funcs方法添加函数到模板里。</p><p>预定义的全局函数如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">and</span><br><span class="line">    函数返回它的第一个empty参数或者最后一个参数；</span><br><span class="line">    就是说&quot;and x y&quot;等价于&quot;if x then y else x&quot;；所有参数都会执行；</span><br><span class="line">or</span><br><span class="line">    返回第一个非empty参数或者最后一个参数；</span><br><span class="line">    亦即&quot;or x y&quot;等价于&quot;if x then x else y&quot;；所有参数都会执行；</span><br><span class="line">not</span><br><span class="line">    返回它的单个参数的布尔值的否定</span><br><span class="line">len</span><br><span class="line">    返回它的参数的整数类型长度</span><br><span class="line">index</span><br><span class="line">    执行结果为第一个参数以剩下的参数为索引/键指向的值；</span><br><span class="line">    如&quot;index x 1 2 3&quot;返回x[1][2][3]的值；每个被索引的主体必须是数组、切片或者字典。</span><br><span class="line">print</span><br><span class="line">    即fmt.Sprint</span><br><span class="line">printf</span><br><span class="line">    即fmt.Sprintf</span><br><span class="line">println</span><br><span class="line">    即fmt.Sprintln</span><br><span class="line">html</span><br><span class="line">    返回其参数文本表示的HTML逸码等价表示。</span><br><span class="line">urlquery</span><br><span class="line">    返回其参数文本表示的可嵌入URL查询的逸码等价表示。</span><br><span class="line">js</span><br><span class="line">    返回其参数文本表示的JavaScript逸码等价表示。</span><br><span class="line">call</span><br><span class="line">    执行结果是调用第一个参数的返回值，该参数必须是函数类型，其余参数作为调用该函数的参数；</span><br><span class="line">    如&quot;call .X.Y 1 2&quot;等价于go语言里的dot.X.Y(1, 2)；</span><br><span class="line">    其中Y是函数类型的字段或者字典的值，或者其他类似情况；</span><br><span class="line">    call的第一个参数的执行结果必须是函数类型的值（和预定义函数如print明显不同）；</span><br><span class="line">    该函数类型值必须有1到2个返回值，如果有2个则后一个必须是error接口类型；</span><br><span class="line">    如果有2个返回值的方法返回的error非nil，模板执行会中断并返回给调用模板执行者该错误；</span><br></pre></td></tr></table></figure><h3 id="比较函数"><a href="#比较函数" class="headerlink" title="比较函数"></a>比较函数</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">eq      如果arg1 == arg2则返回真</span><br><span class="line">ne      如果arg1 != arg2则返回真</span><br><span class="line">lt      如果arg1 &lt; arg2则返回真</span><br><span class="line">le      如果arg1 &lt;= arg2则返回真</span><br><span class="line">gt      如果arg1 &gt; arg2则返回真</span><br><span class="line">ge      如果arg1 &gt;= arg2则返回真</span><br></pre></td></tr></table></figure><p>为了简化多参数相等检测，eq（只有eq）可以接受2个或更多个参数，它会将第一个参数和其余参数依次比较，返回下式的结果：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;eq arg1 arg2 arg3&#125;&#125;</span><br></pre></td></tr></table></figure><p>比较函数只适用于基本类型（或重定义的基本类型，如”type Celsius float32”）。但是，整数和浮点数不能互相比较。</p><h3 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h3><p>Go的模板支持自定义函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    htmlByte, err := ioutil.ReadFile(<span class="string">&quot;./hello.html&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;read html failed, err:&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 自定义一个夸人的模板函数</span></span><br><span class="line">    kua := <span class="function"><span class="keyword">func</span><span class="params">(arg <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> arg + <span class="string">&quot;真帅&quot;</span>, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 采用链式操作在Parse之前调用Funcs添加自定义的kua函数</span></span><br><span class="line">    tmpl, err := template.New(<span class="string">&quot;hello&quot;</span>).Funcs(template.FuncMap&#123;<span class="string">&quot;kua&quot;</span>: kua&#125;).Parse(<span class="keyword">string</span>(htmlByte))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;create template failed, err:&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    user := UserInfo&#123;</span><br><span class="line">        Name:   <span class="string">&quot;枯藤&quot;</span>,</span><br><span class="line">        Gender: <span class="string">&quot;男&quot;</span>,</span><br><span class="line">        Age:    <span class="number">18</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用user渲染模板，并将结果写入w</span></span><br><span class="line">    tmpl.Execute(w, user)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以在模板文件hello.html中使用我们自定义的kua函数了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;kua .Name&#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="解析模板"><a href="#解析模板" class="headerlink" title="解析模板"></a>解析模板</h2><p>​        在go中，常用的解析模板的函数是<code>template.ParseFiles()</code>，ParseFiles函数创建一个模板并解析filenames指定的文件里的模板定义。返回的模板的名字是第一个文件的文件名（不含扩展名），内容为解析后的第一个文件的内容。至少要提供一个文件。如果发生错误，会停止解析并返回nil。</p><p>但是<code>template.ParseFiles()</code>使用的时候需要返回一个error，为了简化开发，有了另一个函数<code>template.Must()</code>来帮我们处理这个error。Must函数用于包装返回(*Template, error)的函数/方法调用，它会在err非nil时panic，一般用于变量初始化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t = template.Must(template.New(<span class="string">&quot;name&quot;</span>).Parse(<span class="string">&quot;html&quot;</span>))</span><br></pre></td></tr></table></figure><h2 id="执行模板"><a href="#执行模板" class="headerlink" title="执行模板"></a>执行模板</h2><ul><li>Execute</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Template)</span> <span class="title">Execute</span><span class="params">(wr io.Writer, data <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure><p>​        Execute方法将解析好的模板应用到data上，并将输出写入wr。如果执行时出现错误，会停止执行，但有可能已经写入wr部分数据。模板可以安全的并发执行。</p><ul><li>ExecuteTemplate</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (t *Template) ExecuteTemplate(wr io.Writer, name string, data interface&#123;&#125;) error</span><br></pre></td></tr></table></figure><p>​        ExecuteTemplate方法类似Execute，但是使用名为name的t关联的模板产生输出，可以自己指定模板的名字来输出数据。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;go中的模板的使用方法和基本介绍&lt;/p&gt;</summary>
    
    
    
    <category term="Go" scheme="http://xucoud.github.io/categories/Go/"/>
    
    <category term="Web" scheme="http://xucoud.github.io/categories/Go/Web/"/>
    
    
    <category term="Go" scheme="http://xucoud.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Restful</title>
    <link href="http://xucoud.github.io/2021/10/15/Restful/"/>
    <id>http://xucoud.github.io/2021/10/15/Restful/</id>
    <published>2021-10-15T15:28:47.000Z</published>
    <updated>2021-10-15T16:25:57.442Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>对于Restful架构的详细介绍</p><span id="more"></span><p>​        越来越多的人开始意识到，<strong>网站即软件</strong>，而且是一种新型的软件。这种”互联网软件”采用客户端/服务器模式，建立在分布式体系上，通过互联网通信，具有高延时（high latency）、高并发等特点。网站开发，完全可以采用软件开发的模式。但是传统上，软件和网络是两个不同的领域，很少有交集；软件开发主要针对单机环境，网络则主要研究系统之间的通信。互联网的兴起，使得这两个领域开始融合，<strong>现在我们必须考虑，如何开发在互联网环境中使用的软件。</strong>RESTful架构，就是目前最流行的一种互联网软件架构。它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。</p><h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>​        Rest这个词是由<a href="https://en.wikipedia.org/wiki/Roy_Fielding">Roy Thomas Fielding</a>提出的，他在自己的博士论文中写到</p><blockquote><p>本文研究计算机科学两大前沿—-软件和网络—-的交叉点。长期以来，软件研究主要关注软件设计的分类、设计方法的演化，很少客观地评估不同的设计选择对系统行为的影响。而相反地，网络研究主要关注系统之间通信行为的细节、如何改进特定通信机制的表现，常常忽视了一个事实，那就是改变应用程序的互动风格比改变互动协议，对整体表现有更大的影响。<strong>我这篇文章的写作目的，就是想在符合架构原理的前提下，理解和评估以网络为基础的应用软件的架构设计，得到一个功能强、性能好、适宜通信的架构。</strong></p></blockquote><h2 id="名称"><a href="#名称" class="headerlink" title="名称"></a>名称</h2><p>​        Fielding将他对互联网软件的架构原则，定名为REST，即Representational State Transfer的缩写。可以翻译为“表现层状态转化”，或者”表征状态转移“。</p><p>​        如果一个架构符合Rest原则，那么他就是Restful架构。</p><h2 id="涵义"><a href="#涵义" class="headerlink" title="涵义"></a>涵义</h2><p>​        在Rest的翻译“表现层状态转化”中，是没有主语的，其中的“表现层”其实是<strong>资源</strong>的“表现层“。再次对Rest中的单词做进一步的解析。</p><h3 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a><strong>Resource</strong></h3><p>​        “Resource”就是资源，而所谓的资源就是网络上的一个实体，或者是网络上的一个具体信息。它可以是一段文本，一张图片，一段音频······可以通过一个URI（统一资源定位符）指向它，每一种资源都对应一个特定的URI。要想获得这个资源访，问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。</p><p>​        所谓”上网”，就是与互联网上一系列的”资源”互动，调用它的URI，将资源展示给用户。</p><h3 id="Representational"><a href="#Representational" class="headerlink" title="Representational"></a><strong>Representational</strong></h3><p>​        “资源”是一种信息实体，它可以有多种外在表现形式。<strong>我们把”资源”具体呈现出来的形式，叫做它的”表现层”（Representation）。</strong>比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。</p><p>​        URI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的”.html”后缀名是不必要的，因为这个后缀名表示格式，属于”表现层”范畴，而URI应该只代表”资源”的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对”表现层”的描述。</p><h3 id="State-Transfer"><a href="#State-Transfer" class="headerlink" title="State Transfer"></a><strong>State Transfer</strong></h3><p>​        访问网站就是客户端和服务器端的一个互动过程。在这个过程中，涉及到数据和其状态的变化。而互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，<strong>如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是”表现层状态转化”。</strong>客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：<strong>GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。</strong></p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li>“Resource”表示的是一个实体，所以URI不应该含有动词，动词应该放到HTTP协议中。</li></ul><blockquote><p>某个URI是/posts/show/1，其中show是动词，这个URI就设计错了，正确的写法应该是/posts/1，然后用GET方法表示show。</p><p>如果某些动作是HTTP动词表示不了的，应该把动作当成一种资源，比如网上汇款，从账户1向账户2汇款500元，错误的URI是：</p><p>​        POST /accounts/1/transfer/500/to/2</p><p>正确的写法是把动词transfer改成名词transaction，资源不能是动词，但是可以是一种服务：</p><p>​        POST /transaction?from=1&amp;to=2&amp;amount=500.00</p></blockquote><ul><li>不应该在URI中加入版本号</li></ul><blockquote><p>因为不同的版本，可以理解成同一种资源的不同表现形式，所以应该采用同一个URI。版本号可以在HTTP请求头信息的Accept字段中进行区分（参见<a href="http://www.informit.com/articles/article.aspx?p=1566460">Versioning REST Services</a>）：</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>REST四个基本原则：</p><ul><li><p>使用HTTP动词：GET POST PUT DELETE；</p></li><li><p>无状态连接，服务器端不应保存过多上下文状态，即每个请求都是独立的；</p></li><li><p>为每个资源设置URI；</p></li><li><p>通过XML JSON进行数据传递；</p></li></ul><p>​        这种交互模式相当于设计一个函数，函数内部（服务器）过程对客户端不可见，客户端只传递参数接受结果。URI的设计就好象设计参数形式，函数的功能已经包含在网站本身不言自明，不需要再列出来。</p><p>​        Rest只是一种设计风格，具体的URI命名方式应该根据具体环境来做出适当的修改。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;对于Restful架构的详细介绍&lt;/p&gt;</summary>
    
    
    
    <category term="Restful" scheme="http://xucoud.github.io/categories/Restful/"/>
    
    
    <category term="Restful" scheme="http://xucoud.github.io/tags/Restful/"/>
    
  </entry>
  
  <entry>
    <title>K8s</title>
    <link href="http://xucoud.github.io/2021/07/02/K8s/"/>
    <id>http://xucoud.github.io/2021/07/02/K8s/</id>
    <published>2021-07-02T09:01:40.000Z</published>
    <updated>2021-11-27T16:26:31.636Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><span id="more"></span><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Kubernetes是取开头结尾的K和s，之间有8个字母，于是又被称为K8s。Kubernetes是一个由Google公司开发的用于管理云平台中多个主机上的容器化的应用，Kubernetes的目标是让部署容器化的应用简单并且高效（powerful）,Kubernetes提供了应用部署，规划，更新，维护的一种机制。。他是Google借用borg系统的设计理念进而用go语言开发的。K8s集结了Borg设计思想的精华，并且吸收了Borg系统中的经验和教训。</p><p>特点：</p><ul><li>轻量级：消耗的资源少</li><li>开源</li><li>弹性伸缩</li><li>负载均衡：IPVS</li></ul><h2 id="Kubernetes框架"><a href="#Kubernetes框架" class="headerlink" title="Kubernetes框架"></a>Kubernetes框架</h2><p>Kubernetes的组成架构图，可以看到K8s主要由kuberctl，etcd和Internet三部分组成。</p><p>kuberctl就相当于Master，一个领导者，用于和外界交互，接收外界命令，将数据存储到etcd中，进行保存，并将任务发放给对应放入pod，也就是执行者。</p><p>组件：</p><ul><li>Master：主服务器</li><li>etcd：一个可信赖的分布式键值数据库，可用于存储Kubernetes运行过程中产生的关键数据，保存了整个集群的状态，使得集群在崩溃之后，可以进行数据恢复</li><li>Node：节点</li></ul><p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20210702210553.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20210702210553.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><h3 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a>etcd</h3><p>etcd有两个版本：</p><ul><li>v2</li><li>v3（建议使用）</li></ul><p>V2版会将所有的数据都写入内存中</p><p>V3会引入一个本地的磁盘的数据持久化操作，意味着在电脑关机之后，并不是造成数据损坏，会从本地磁盘中进行恢复</p><p>在KubernetesV1.11之前都是默认使用v2（不支持V3，需要自己进行数据备份），之后都是默认使用的v3</p><p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20210702213403.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20210702213403.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210702213401452"></p><p>etcd采用HTTP协议，C/S架构的开发模式，与K8s相同</p><p>HttpServer是对数据进行操作，包括CRUD，认证等，在这里不采用TCP协议是，避免自己的二次开发</p><p>Raft是存在读写操作的数据</p><p>WAL是运行中数据备份，可以进行完整备份，也可以进行临时备份Snapshot，如果需要对一个大文件进行小范围修改，使用临时备份就可以避免多次备份同一数据，消耗太多资源，并且他会在一定时间内对数据进行完整备份Entry，防止临时备份太多，导致后面还原太麻烦，他也会实时的将这些数据存储到本地磁盘Store</p><h3 id="Master（主节点）"><a href="#Master（主节点）" class="headerlink" title="Master（主节点）"></a>Master（主节点）</h3><p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20210702211537.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20210702211537.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210702211535182"></p><p>重要组件：</p><ul><li>scheduler：资源调度器，负责接受任务，资源的调度，按照预定的调度策略将Pod调度到相应的机器上；</li><li>replication controller：副本控制器，维持副本的期望数目</li><li>api server：为所有组件提供了资源操作的唯一入口，并提供认证、授权、访问控制、API注册和发现等机制；</li></ul><p>高可用集群副本数再好是 &gt;= 3的奇数</p><h3 id="Node（工作节点）"><a href="#Node（工作节点）" class="headerlink" title="Node（工作节点）"></a>Node（工作节点）</h3><p>重要组件：</p><ul><li>kuberlet：与dockers的CRL进行交互，操作dockers进行容器的操作，维持Pod的生命周期</li><li>kube proxy：实现负载均衡，以及Pod与Pod之间的通信，他的默认操作对象是FireWall去实现Pod的映射</li><li>docker(也可选择其他容器引擎)</li></ul><h3 id="其他组件"><a href="#其他组件" class="headerlink" title="其他组件"></a>其他组件</h3><ul><li>CoreDNS：负责为整个集群提供DNS服务，实现负载均衡的重要组件，为集群中的SVC创建一个域名IP的对应解析关系，以后访问别的Pod，无需通过Pod的Ip地址，只需通过访问生产的域名，就可以实现访问。</li><li>Ingress Controller：官方只能实现四层代理，Ingress可以实现七层代理</li><li>Heapster：提供资源监控</li><li>Dashboard：给K8s提供一个B/S结构的访问体系</li><li>Federation：提供一个可以跨集群中心多K8s统一管理功能</li><li>Fluentd-elasticsearch：提供集群日志采集、存储与查询</li><li>PromeTheus：提供一个K8s的集群监控能力</li><li>ELK：为K8s集群提供一个日志统一分析介入平台</li></ul><h2 id="Kubernetes核心概念"><a href="#Kubernetes核心概念" class="headerlink" title="Kubernetes核心概念"></a>Kubernetes核心概念</h2><h3 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h3><p>特点：</p><ul><li><p>K8s中最小的部署单元</p></li><li><p>他是一组容器的集合</p></li><li><p>共享网络–每个Pod中的容易都对应同一个端口</p></li><li><p>生命周期短暂</p></li></ul><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><p>基本概念：</p><ul><li>确保预期的Pod副本数量</li><li>有状态应用部署：</li><li>无状态应用部署</li><li>确保所有的Node运行同一个Pod</li><li>一次性任务和定时任务</li></ul><h3 id="Api-Server"><a href="#Api-Server" class="headerlink" title="Api Server"></a>Api Server</h3><ul><li>定义一组Pod的访问规则</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="k8s" scheme="http://xucoud.github.io/categories/k8s/"/>
    
    
    <category term="K8s" scheme="http://xucoud.github.io/tags/K8s/"/>
    
  </entry>
  
  <entry>
    <title>java多线程</title>
    <link href="http://xucoud.github.io/2021/06/06/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://xucoud.github.io/2021/06/06/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2021-06-06T12:10:11.000Z</published>
    <updated>2021-07-18T14:20:12.034Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Java.Thread介绍</p><span id="more"></span><h2 id="线程，进程，多线程"><a href="#线程，进程，多线程" class="headerlink" title="线程，进程，多线程"></a>线程，进程，多线程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><ul><li>程序指令和数据的有序集合，其本身没有任何的运行的含义，是一个静态的概念。</li><li>进程是执行程序的一次执行过程，是一个动态的概念，是系统分配资源的单位，也是基本的执行单位</li><li>每一个进程都是一个实体，都拥有自己的地址空间：包括文本区、数据区、堆区、栈区。</li><li>特点：<ul><li>动态性：进程的实质是程序在<a href="https://baike.baidu.com/item/%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E7%B3%BB%E7%BB%9F">多道程序系统</a>中的一次执行过程，进程是动态产生，动态消亡的。</li><li>并发性：任何进程都可以同其他进程一起并发执行</li><li>独立性：进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位；</li><li><a href="https://baike.baidu.com/item/%E5%BC%82%E6%AD%A5%E6%80%A7">异步性</a>：由于进程间的相互制约，使进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进</li><li>结构特征：进程由程序、数据和<a href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97">进程控制块</a>三部分组成。</li></ul></li></ul><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><ul><li>线程是操作系统能够进行运算调度的最小的单位。</li><li>每个进程至少有一个线程，线程可以利用进程所拥有的资源执行调度和运算。</li><li>线程包含着进程中，是进程的实际运作单位，通常一个进程中包含有多个线程，每个线程执行不同的任务。</li><li>线程是独立调度和分派的基本单位。线程可以为操作系统内核调度的内核线程。</li></ul><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><ul><li>一个进程通常会有多个线程，每个线程都对应着不同的任务。</li><li>多个线程可以并发执行（同时进行），通过提高资源的使用效率来提高系统的效率。</li><li>同时进行并非同一时刻进行，而是在某一时间段内，完成所有任务，任务的运行有先后顺序。</li><li>真正的多线程是指拥有一个CPU有多个内核。</li><li>现在很多多线程都是模拟出来的，即一个CPU的一个核在同一时间内只能执行一个代码，因为切换的，所以就有了同时执行的错觉。</li></ul><h3 id="线程与进程的对比"><a href="#线程与进程的对比" class="headerlink" title="线程与进程的对比"></a>线程与进程的对比</h3><ul><li>进程是操作系统资源分配的基本单位，所有与该进程有关的资源，均会被记录在进程控制块PCB中，以表示该进程所拥有的资源。同一进程下的所有线程共享该进程下的所有资源。</li><li>线程是分配处理机的基本单位，与系统资源分配无关。事实上，正在在处理机上运行的是线程，并非进程。</li><li>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。</li><li>线程在执行的时候需要协作同步，不同进程的线程间要利用消息通信方法实现同步。</li></ul><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p> 并发就是只有一个CPU资源，程序（或线程）之间要竞争得到执行机会。图中的第一个阶段，在A执行的过程中B，C不会执行，因为这段时间内这个CPU资源被A竞争到了，同理，第二个阶段只有B在执行，第三个阶段只有C在执行。其实，并发过程中，A，B，C并不是同时在进行的（微观角度）。但又是同时进行的（宏观角度）。</p><p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20210606203000.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20210606203000.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210606202947627"></p><h3 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h3><p>并行指两个或两个以上事件（或线程）在同一时刻发生，是真正意义上的不同事件或线程在同一时刻，在不同CPU资源上（多核），同时执行。并行，不存在像并发那样竞争CPU资源，等待执行的概念，因为并行状态下的线程分布在不同的CPU上。</p><p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20210606203048.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20210606203048.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210606203045787"></p><h3 id="注意✨"><a href="#注意✨" class="headerlink" title="注意✨"></a>注意✨</h3><ul><li><p>一个程序执行时，至少会有两个线程，一个main()线程（主程序），一个gc()线程（JVM创建的垃圾回收线程）。</p></li><li><p>一个进程中，线程的执行先后顺序是由调度器来控制的，不能人为干预。</p></li><li><p>在对同一份资源进行操作时，会存在资源抢夺的问题，所以需要加入并发控制。</p></li><li><p>线程会带来额外的开销，如CPU调度时间，并发控制时间。</p></li><li><p>每个线程在内存交互式时，如果内存控制不当 会造成数据不一致。</p></li></ul><h2 id="线程创建的三种方式"><a href="#线程创建的三种方式" class="headerlink" title="线程创建的三种方式"></a>线程创建的三种方式</h2><ul><li>继承Thread类</li><li>实现Runnable接口</li><li>实现Callable接口</li></ul><h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><ul><li>重写run()方法，调用start()方法开启线程。</li><li>直接执行run方法也可以开启线程，但是不能开启多线程，只能等该线程执行完毕再执行其他线程。</li><li>执行start()方法，则会开启多线程，多个线程交替执行。</li><li>线程开启不一定立即执行，由CPU进行调度。</li><li>容易出现oop单继承局限性。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建线程</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        <span class="comment">//一个线程不可启动多个start</span></span><br><span class="line">        <span class="comment">//要创建多个线程要创建多个对象</span></span><br><span class="line">        <span class="comment">//每次重新执行，结果可能都不相同</span></span><br><span class="line">        myThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                System.out.println(i + <span class="string">&quot;******&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20210606205200.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20210606205200.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210606205156778"></p><h3 id="实现Ruannable接口"><a href="#实现Ruannable接口" class="headerlink" title="实现Ruannable接口"></a>实现Ruannable接口</h3><ul><li>重写run方法，创建线程实现类对象，创建对象代理，调用start方法，开启线程</li><li>一个对象可以创建多个线程。</li><li>避免单继承局限性，灵活方便。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//案例一</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">myThread</span><span class="params">(String title)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.title = title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(title + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> myThread(<span class="string">&quot;aaaaa&quot;</span>));</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> myThread(<span class="string">&quot;bbbbb&quot;</span>));</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> myThread(<span class="string">&quot;ccccc&quot;</span>));</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20210606230840.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20210606230840.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210606230837679"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//案例二</span></span><br><span class="line"><span class="comment">//模拟抢火车票</span></span><br><span class="line"><span class="comment">//多个线程操作同一个对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket_nums = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//判断是否有票</span></span><br><span class="line">            <span class="keyword">if</span> (ticket_nums &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//模拟延时</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-&gt;拿到第&quot;</span> + ticket_nums + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">            ticket_nums--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个runnable对象</span></span><br><span class="line">        TestThread1 ticket = <span class="keyword">new</span> TestThread1();</span><br><span class="line">        <span class="comment">//创建多个线程操作同一对象</span></span><br><span class="line">        <span class="keyword">new</span> Thread(ticket,<span class="string">&quot;小明&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(ticket,<span class="string">&quot;小红&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(ticket,<span class="string">&quot;黄牛&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：在这个案例中，多个线程操作同一个对象，会出现线程不安全的问题，即同一种票卖给了不同的人，数据紊乱。</p></blockquote><p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20210607231715.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20210607231715.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210607231705318"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//案例三</span></span><br><span class="line"><span class="comment">//模拟龟兔赛跑</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String winner;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//模拟兔子睡觉,只要兔子睡觉了，乌龟必赢</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread().getName().equals(<span class="string">&quot;兔子&quot;</span>) &amp;&amp; i%<span class="number">10</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">boolean</span> flag = gameOver(i);</span><br><span class="line">            <span class="comment">//判断游戏是否结束</span></span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;--&gt;跑了&quot;</span>+i+<span class="string">&quot;步&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否有胜利者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">gameOver</span><span class="params">(<span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">        <span class="comment">//胜利者是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (winner != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//是否到达终点</span></span><br><span class="line">        <span class="keyword">if</span> (step == <span class="number">100</span>)&#123;</span><br><span class="line">            winner = Thread.currentThread().getName();</span><br><span class="line">            System.out.println(<span class="string">&quot;胜利者是:&quot;</span>+winner);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestThread2 t = <span class="keyword">new</span> TestThread2();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(t,<span class="string">&quot;兔子&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(t,<span class="string">&quot;乌龟&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h3><ul><li>重写call方法，创建线程池，将线程提交到线程池开启，最后关闭线程池；</li><li>可以返回值</li><li>可以处理异常</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过ExecutorService创建线程池来实现多线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread3</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> +<span class="string">&quot;线程执行完毕&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        TestThread3 t1 = <span class="keyword">new</span> TestThread3();</span><br><span class="line">        TestThread3 t2 = <span class="keyword">new</span> TestThread3();</span><br><span class="line">        TestThread3 t3 = <span class="keyword">new</span> TestThread3();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建执行服务</span></span><br><span class="line">        ExecutorService ser = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//提交执行</span></span><br><span class="line">        Future&lt;String&gt; tr1 = ser.submit(t1);</span><br><span class="line">        Future&lt;String&gt; tr2 = ser.submit(t2);</span><br><span class="line">        Future&lt;String&gt; tr3 = ser.submit(t3);</span><br><span class="line">        <span class="comment">//获取结果</span></span><br><span class="line">        String r1 = tr1.get();</span><br><span class="line">        String r2 = tr2.get();</span><br><span class="line">        String r3 = tr3.get();</span><br><span class="line"></span><br><span class="line">        System.out.println(r1);</span><br><span class="line">        System.out.println(r2);</span><br><span class="line">        System.out.println(r3);</span><br><span class="line">        <span class="comment">//关闭服务</span></span><br><span class="line">        ser.shutdownNow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过FutureTask来构建Thread对象来实现多线程</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> +<span class="string">&quot;线程执行完毕&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过callable实现多线程，一个线程对应一个FutureTask，要实现多线程需要创建多个FutureTask</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        FutureTask&lt;String&gt; task = <span class="keyword">new</span> FutureTask&lt;String&gt;(<span class="keyword">new</span> MyThread());</span><br><span class="line">        FutureTask&lt;String&gt; task1 = <span class="keyword">new</span> FutureTask&lt;String&gt;(<span class="keyword">new</span> MyThread());</span><br><span class="line">        FutureTask&lt;String&gt; task2 = <span class="keyword">new</span> FutureTask&lt;String&gt;(<span class="keyword">new</span> MyThread());</span><br><span class="line">        <span class="keyword">new</span> Thread(task,<span class="string">&quot;线程1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(task1,<span class="string">&quot;线程2&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(task2,<span class="string">&quot;线程3&quot;</span>).start();</span><br><span class="line">        System.out.println(task.get());</span><br><span class="line">        System.out.println(task1.get());</span><br><span class="line">        System.out.println(task2.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>​        在 JDK1.5之前，JAVA创建线程有两种方式：<code>Tread</code>类，<code>Runnable</code>接口。无论以怎样的形式实现多线程，都需要调用Thread类中的start方法去向操作系统请求io，cup等资源。因为线程<code>run()</code>方法没有返回值，如果需要获取执行结果，就必须通过共享变量或者使用线程通信的方式来达到效果，这样使用起来就比较麻烦。</p><p>​        在<code>JDK1.5</code>之后，提供了<code>Callbale</code>，<code>Future</code>，<code>FutrueTask</code>，<code>ExecutorService</code>等，通过他们可以实现在线程执行完毕之后直接得到返回结果。</p><p>​        <code>Callable</code>接口代表一段可以调用并返回结果的代码;<code>Future</code>接口表示异步任务，是还没有完成的任务给出的未来结果。所以说Callable用于产生结果，<code>Future</code>用于获取结果。</p><p>​        <code>Callable</code>接口使用泛型去定义它的返回类型。<code>Executors</code>类提供了一些有用的方法在线程池中执行<code>Callable</code>内的任务。由于<code>Callable</code>任务是并行的（并行就是整体看上去是并行的，其实在某个时间点只有一个线程在执行），我们必须等待它返回的结果。<code> java.util.concurrent.Future</code>对象为我们解决了这个问题。在线程池提交<code>Callable</code>任务后返回了一个<code>Future</code>对象，使用它可以知道<code>Callable</code>任务的状态和得到<code>Callable</code>返回的执行结果。<code>Future</code>提供了<code>get()</code>方法让我们可以等待<code>Callable</code>结束并获取它的执行结果。如果线程为结束调用<code>get()</code>方法，则会出现线程阻塞，知道<code>Callable</code>任务执行完毕，并返回结果。</p><p><code>Future</code>提供了三种功能：</p><p>　　1）判断任务是否完成；</p><p>　　2）能够中断任务；</p><p>　　3）能够获取任务执行结果。</p><p>​        <code>FutureTask</code>是<code>Future</code>接口的实现类，可以由执行者调度，这一点很关键。它对外提供的方法基本上就是<code>Future</code>和<code>Runnable</code>接口的组合：<code>get()</code>、<code>cancel</code>、<code>isDone()</code>、<code>isCancelled()</code>和<code>run()</code>，而<code>run()</code>方法通常都是由执行者调用，我们基本上不需要直接调用它。<code>FutureTask</code>类同时又实现了<code>Runnable</code>接口，所以可以直接提交给**<code>Thread</code>、<code>Executors</code>**执行，<code>FutureTask</code>可以解决线程阻塞的问题。<code>FutureTask</code>可以将<code>Callable</code>转换成<code>Runnable</code>，使用Thread来执行线程，也可以为<code>Runnable</code>任务提供返回值。</p><h2 id="线程的五种状态"><a href="#线程的五种状态" class="headerlink" title="线程的五种状态"></a>线程的五种状态</h2><ul><li>创建状态</li><li>就绪状态</li><li>阻塞状态</li><li>运行状态</li><li>死亡状态</li></ul><p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20210716202706.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20210716202706.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210716202656687"></p><h3 id="状态变化"><a href="#状态变化" class="headerlink" title="状态变化"></a>状态变化</h3><ol><li>当线程被创建之后没就进入了新生状态。</li><li>当线程调用start（）方法之后，线程就进入就绪状态，等待被调度执行。</li><li>进入运行状态后，线程开始真正执行代码。</li><li>当调用了sleep，wait方法或同步锁定时，线程进入阻塞状态，代码不会继续执行，直到阻塞事件解除，重新进入就绪状态。</li><li>线程中断或者结束，一旦进入死亡状态，就不能再次启动了。</li></ol><h2 id="线程方法"><a href="#线程方法" class="headerlink" title="线程方法"></a>线程方法</h2><h3 id="线程停止"><a href="#线程停止" class="headerlink" title="线程停止"></a>线程停止</h3><ul><li>不推荐使用stop，destroy方法，已经被废弃。</li><li>建议使用一个标志位，让线程自己停下来。</li><li>推荐让线程自己通下来（次数或死循环）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//设置标志位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (flag)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+i++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写停止方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flag = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadTest1 t1 = <span class="keyword">new</span> ThreadTest1();</span><br><span class="line">        <span class="keyword">new</span> Thread(t1).start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">50</span>)&#123;</span><br><span class="line">                t1.stop();</span><br><span class="line">                System.out.println(<span class="string">&quot;线程已停止&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程休眠"><a href="#线程休眠" class="headerlink" title="线程休眠"></a>线程休眠</h3><ul><li>sleep()来指定休眠的时间</li><li>sleep（）时间结束后，会进入就绪状态</li><li>sleep可以模拟网络延时和倒计时等</li><li>每个对象都有一个锁，sleep不会释放锁</li><li>线程不安全</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSleep</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket_nums = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//判断是否有票</span></span><br><span class="line">            <span class="keyword">if</span> (ticket_nums &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//模拟延时</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-&gt;拿到第&quot;</span> + ticket_nums-- + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个runnable对象</span></span><br><span class="line">        ThreadSleep ticket = <span class="keyword">new</span> ThreadSleep();</span><br><span class="line">        <span class="comment">//创建多个线程操作同一对象</span></span><br><span class="line">        <span class="keyword">new</span> Thread(ticket,<span class="string">&quot;小明&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(ticket,<span class="string">&quot;小红&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(ticket,<span class="string">&quot;黄牛&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程礼让"><a href="#线程礼让" class="headerlink" title="线程礼让"></a>线程礼让</h3><ul><li>yield（）礼让线程，当前正执行的现场暂停，但是不阻塞</li><li>将线程由运行状态转为就绪状态</li><li>CPU重新进行调度，但是不一定成功 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadYielde</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyYield myYield = <span class="keyword">new</span> MyYield();</span><br><span class="line">        <span class="keyword">new</span> Thread(myYield,<span class="string">&quot;1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(myYield,<span class="string">&quot;2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyYield</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;开始执行&quot;</span>);</span><br><span class="line">        Thread.yield();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;结束执行&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20210717212106.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20210717212106.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210717212055896">   <img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20210717212233.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20210717212233.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210717212232641">   <img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20210717212130.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20210717212130.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210717212128455"></p><h3 id="Join"><a href="#Join" class="headerlink" title="Join()"></a>Join()</h3><ul><li>合并线程，先执行此线程，其他线程阻塞</li><li>类似于插队</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span>  <span class="title">ThreadJoin</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;vip--&gt;&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadJoin());</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;main--&gt;&quot;</span>+i);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">20</span>)&#123;</span><br><span class="line">                thread.join();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="状态检测"><a href="#状态检测" class="headerlink" title="状态检测"></a>状态检测</h3><ul><li>getState（）方法，方便观察线程执行过程中处于什么状态</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadState</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(thread.getState());</span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(thread.getState());</span><br><span class="line">        <span class="keyword">while</span> (thread.getState() != Thread.State.TERMINATED)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            System.out.println(thread.getState());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20210717214246.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20210717214246.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210717214245216"></p><h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><ul><li><p>java中提供一个线程调度器来监控程序执行过程中的进入就绪状态的所有线程，线程调度器根据线程优先级决定应该调度哪个线程来执行</p></li><li><p>线程优先级用数字表示：1~10</p><ul><li>Thread.MIN__PROIRITY = 1;</li><li>Thread.MAX__PROIRITY = 10;</li><li>Thread.NORM__PROIRITY = 5;</li></ul></li><li><p>改变、获取优先级</p><ul><li>getPriority()</li><li>setPriority(int *)</li></ul></li><li><p>优先级的设定建议在调用start方法之前</p></li><li><p>优先级的高低只代表获取调度的概率高低，并不是优先级高就一定会先执行，全看CPU的调度</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPriority</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;-&gt;&quot;</span>+Thread.currentThread().getPriority());</span><br><span class="line"></span><br><span class="line">        MyPriority myPriority = <span class="keyword">new</span> MyPriority();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(myPriority,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        t1.setPriority(<span class="number">1</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(myPriority,<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        t2.setPriority(<span class="number">4</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(myPriority,<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        t3.setPriority(<span class="number">6</span>);</span><br><span class="line">        t3.start();</span><br><span class="line">        Thread t4 = <span class="keyword">new</span> Thread(myPriority,<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        t4.setPriority(<span class="number">8</span>);</span><br><span class="line">        t4.start();</span><br><span class="line">        Thread t5 = <span class="keyword">new</span> Thread(myPriority,<span class="string">&quot;5&quot;</span>);</span><br><span class="line">        t5.setPriority(<span class="number">10</span>);</span><br><span class="line">        t5.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPriority</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;-&gt;&quot;</span>+Thread.currentThread().getPriority());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20210718160524.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20210718160524.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210718160515885"> <img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20210718160636.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20210718160636.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210718160635060"></p><h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><ul><li><p>线程分为<strong>用户线程</strong>和<strong>守护线程</strong></p></li><li><p>用户线程必须执行完，守护线程不需要执行完</p></li><li><p>例子：后台日志记录，垃圾回收，监控内存等</p></li><li><p>Java默认线程为用户线程，通过setDaemon（true）方法设置为守护线程</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDaemon</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        God god = <span class="keyword">new</span> God();</span><br><span class="line">        You you = <span class="keyword">new</span> You();</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(god);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(you);</span><br><span class="line">        t1.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">You</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-------hello,world!-------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;你活着很开心&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;---------goodbye,world!--------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">God</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;上帝保佑你！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20210718161944.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20210718161944.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210718161943408"></p><p>按照正常执行的话，god线程不会结束，但是改为守护线程之后，用户线程执行完，守护线程被迫结束。</p><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>并发：同一个对象被多个线程<strong>同时操作</strong></p><p>处理多线程问题时，多个线程访问同一个对象，并且某些线程还想修改这个对象。这时候我们就需要线程同步。</p><p>线程同步其实就是一种<strong>等待机制</strong>，多个需要同时访问此对象的线程进入<strong>这个对象的等待池形成队列</strong>，等待前面线程使用完毕，下一个线程再使用。</p><ul><li>队列 + 锁，解决线程同步的安全性。</li></ul><p><strong>synchronized，排他锁独占资源。</strong></p><ul><li>使用锁可能会引起问题：<ul><li>一个线程持有锁会导致其他所有需要此锁的<strong>线程挂起</strong>;</li><li>在多线程竞争下,加锁﹐释放锁会导致比较多的上下文切换和调度延时,引起<strong>性能问题</strong>;</li><li>如果一个优先级高的线程等待一个优先级低的线程释放锁会导致<strong>优先级倒置</strong>﹐引起性能问题．</li></ul></li></ul><h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><h4 id="synchronized方法"><a href="#synchronized方法" class="headerlink" title="synchronized方法"></a>synchronized方法</h4><p>synchronized方法控制对象的访问，每个对象都有一把锁，每个对象都必须获得调用该方法的对象的锁才可以执行，否则会阻塞，方法一但执行就会独占该锁，直到方法执行结束才会释放锁，后面被阻塞的线程才能获得该锁，继续执行。</p><blockquote><p>如果将一个大方法申明为synchronized方法，会影响效率，例如：</p><p>​        一个方法中涉及到读和写，且两者不相关，那么读和写都会被阻塞，影响效率</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket_nums = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (flag)&#123;</span><br><span class="line">            buyTicket();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">buyTicket</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断是否有票</span></span><br><span class="line">        <span class="keyword">if</span> (ticket_nums &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            flag = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//模拟延时</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-&gt;拿到第&quot;</span> + ticket_nums-- + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个runnable对象</span></span><br><span class="line">        ThreadTicket ticket = <span class="keyword">new</span> ThreadTicket();</span><br><span class="line">        <span class="comment">//创建多个线程操作同一对象</span></span><br><span class="line">        <span class="keyword">new</span> Thread(ticket,<span class="string">&quot;小明&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(ticket,<span class="string">&quot;小红&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(ticket,<span class="string">&quot;黄牛&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="synchronized块"><a href="#synchronized块" class="headerlink" title="synchronized块"></a>synchronized块</h4><ul><li>同步块 synchronized(obj) {}</li><li>obj称为同步监视器<ul><li>obj可以是任何对象，但是推荐使用共享对象作为同步监视器</li><li>同步方法中无需指定同步监视器，同步方法的同步监视器就this，这个对象本身</li></ul></li><li>步骤<ul><li>第一个对象访问同步监视器，同步监视器被锁，执行代码</li><li>第二个对象访问同步监视器，但是同步监视器被锁，无法访问，被阻塞</li><li>第一个对象执行完毕，同步监视器锁被释放</li><li>第二个对象访问同步监视器，对其加锁并访问</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//银行取钱</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadBank</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Account account = <span class="keyword">new</span> Account(<span class="number">100</span>,<span class="string">&quot;积蓄&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Bank b1 = <span class="keyword">new</span> Bank(account,<span class="number">50</span>,<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        Bank b2 = <span class="keyword">new</span> Bank(account,<span class="number">100</span>,<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(b1).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(b2).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> nowMoney;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(<span class="keyword">int</span> money,String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nowMoney = money;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Account account;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> GetMoney;</span><br><span class="line">    <span class="keyword">private</span> String user_name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bank</span><span class="params">(Account account, <span class="keyword">int</span> getMoney,String name)</span> </span>&#123;</span><br><span class="line">        user_name = name;</span><br><span class="line">        <span class="keyword">this</span>.account = account;</span><br><span class="line">        GetMoney = getMoney;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (account)&#123;</span><br><span class="line">            <span class="keyword">if</span> (account.nowMoney - GetMoney &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;钱不够了&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            account.nowMoney = account.nowMoney - GetMoney;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;取了&quot;</span>+GetMoney);</span><br><span class="line">            System.out.println(account.name+<span class="string">&quot;剩余的钱：&quot;</span>+account.nowMoney);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ArrayList添加元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadArrayList</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果不进行同步处理，将会出现list中元素被覆盖的情况，使得list中元素缺少</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (list)&#123;</span><br><span class="line">                    list.add(Thread.currentThread().getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Java.Thread介绍&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="http://xucoud.github.io/categories/Java/"/>
    
    
    <category term="Thread" scheme="http://xucoud.github.io/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot(一)</title>
    <link href="http://xucoud.github.io/2021/06/06/Springboot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://xucoud.github.io/2021/06/06/Springboot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2021-06-06T11:48:59.000Z</published>
    <updated>2021-06-07T15:18:31.459Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>SpringBoot 的简单介绍</p><span id="more"></span><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ul><li>通过 <strong>IDEA</strong> 的 Spring Initializr 创建好 Springboot 项目之后，在 <code>src/resources</code> 路径下会自动生成一个<code>application.properties</code> 文件 ，该文件就是配置文件。</li><li>配置文件有<code>properties</code>和<code>yaml</code>两种格式，可以根据个人喜好选择</li><li>若<code>properties</code>与<code>yaml</code>同时存在，<code>properties</code>中的内容会覆盖<code>yaml</code>中的内容</li></ul><h3 id="yaml格式"><a href="#yaml格式" class="headerlink" title="yaml格式"></a>yaml格式</h3><ul><li>通过 <strong>缩进</strong> 来控制层级关系，左对齐的就是同一层级的（冒号与值之间要有空格）</li><li>书0写较为简洁，但是看起来没有<code>properties</code>文件明了（刚开始看会不太友好）</li></ul><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//更改访问的端口号</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure><h3 id="properties格式"><a href="#properties格式" class="headerlink" title="properties格式"></a>properties格式</h3><ul><li>通过<code>.</code>来控制层级关系</li><li>可以很清楚的看到各个配置，但是会重复写很多东西</li></ul><h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">server.port</span> = <span class="string">8080</span></span><br></pre></td></tr></table></figure><h3 id="配置文件中的全局变量"><a href="#配置文件中的全局变量" class="headerlink" title="配置文件中的全局变量"></a>配置文件中的全局变量</h3><h4 id="对象，属性"><a href="#对象，属性" class="headerlink" title="对象，属性"></a>对象，属性</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//第一种写法</span></span><br><span class="line"><span class="attr">person:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">张三</span></span><br><span class="line">  <span class="attr">age:</span> <span class="number">20</span></span><br><span class="line">  </span><br><span class="line"><span class="string">//第二种写法</span></span><br><span class="line"><span class="attr">person:</span> &#123;<span class="attr">name :</span> <span class="string">张三</span>, <span class="attr">age :</span> <span class="number">20</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//第一种写法</span></span><br><span class="line"><span class="attr">animals:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">dog</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cat</span></span><br><span class="line">  </span><br><span class="line"><span class="string">//第二种写法</span></span><br><span class="line"><span class="attr">animals:</span> [<span class="string">dog</span>, <span class="string">cat</span>]</span><br></pre></td></tr></table></figure><h4 id="配置文件中的占位符"><a href="#配置文件中的占位符" class="headerlink" title="配置文件中的占位符"></a>配置文件中的占位符</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$&#123;&#125;</span></span><br></pre></td></tr></table></figure><h5 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$&#123;random.value&#125;</span>     <span class="string">//给与一串随机值</span></span><br><span class="line"><span class="string">$&#123;random.int&#125;</span>       <span class="string">//给与一个随机整数</span></span><br><span class="line"><span class="string">$&#123;random.long&#125;</span>      <span class="string">//给与一个随机长整数</span></span><br><span class="line"><span class="string">$&#123;random.int(10)&#125;</span>   <span class="string">//给与一个0~10之间的数</span></span><br><span class="line"><span class="string">$&#123;random.int[1024,65536]&#125;</span>    <span class="string">//给与一个1024~65536之间的数</span></span><br></pre></td></tr></table></figure><h3 id="相关注释"><a href="#相关注释" class="headerlink" title="相关注释"></a>相关注释</h3><h4 id="注入配置文件中的值"><a href="#注入配置文件中的值" class="headerlink" title="注入配置文件中的值"></a>注入配置文件中的值</h4><p>配置文件值注入有两种方式，一个是Springboot的<code>@ConfigurationProperties</code>注解，另一个是spring原先的<code>@value</code>注解</p><table><thead><tr><th></th><th>@ConfigurationProperties</th><th>@Value</th></tr></thead><tbody><tr><td>功能</td><td>批量注入配置文件中的属性</td><td>一个个指定</td></tr><tr><td>松散绑定（松散语法）</td><td>支持</td><td>不支持</td></tr><tr><td>SpEL（Spring表达式语言）</td><td>不支持</td><td>支持</td></tr><tr><td>JSR303数据校验</td><td>支持</td><td>不支持</td></tr><tr><td>复杂类型封装</td><td>支持</td><td>不支持</td></tr></tbody></table><h5 id="松散绑定"><a href="#松散绑定" class="headerlink" title="松散绑定"></a>松散绑定</h5><p>Person中有<code>lastName</code>属性，在配置文件中可以写成<code>lastName</code>或<code>lastname</code>或<code>last-name</code>或<code>last_name</code>等等</p><h5 id="SpEL"><a href="#SpEL" class="headerlink" title="SpEL"></a>SpEL</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">##　properties配置文件</span><br><span class="line">person.age=#&#123;<span class="number">2019</span>-<span class="number">1986</span>+<span class="number">1</span>&#125;   <span class="comment">//#&#123;&#125;里的就是SpEL</span></span><br><span class="line"></span><br><span class="line"># Person类</span><br><span class="line">#--------------------使用<span class="meta">@ConfigurationProperties</span>注解，会抛出异常--------------------</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;person&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#--------------------使用<span class="meta">@value</span>注解 OK--------------------</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;person.age&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="JSR303数据校验"><a href="#JSR303数据校验" class="headerlink" title="JSR303数据校验"></a>JSR303数据校验</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># Person类 中的 age=<span class="number">34</span></span><br><span class="line">#--------------------使用<span class="meta">@ConfigurationProperties</span>注解可以正常输出，会抛出异常，但不会报错--------------------</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;person&quot;)</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Max(30)</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#--------------------使用<span class="meta">@value</span>注解则会报错--------------------</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Max</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;person.age&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="复杂类型封装"><a href="#复杂类型封装" class="headerlink" title="复杂类型封装"></a>复杂类型封装</h5><p><code>@value</code>注解无法注入map等对象的复杂类型，但<code>list、数组</code>可以</p><p><code>  @ConfigurationProperties</code>则都可以</p><h4 id="PropertySource"><a href="#PropertySource" class="headerlink" title="@PropertySource"></a>@PropertySource</h4><ul><li>该注解的作用是加载指定的配置文件，值可以是数组，也就是可以加载多个配置文件</li><li>Springboot默认加载的配置文件名是<code>application</code>，如果配置文件名不是这个是不会被容器加载的，使用该注解即可加载自定义配置文件</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PropertySource(&#123;&quot;classpath:person.properties&quot;&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//该注解只能加载properties文件</span></span><br></pre></td></tr></table></figure><h3 id="多配置文件"><a href="#多配置文件" class="headerlink" title="多配置文件"></a>多配置文件</h3><p>在一个Springboot项目的开发过程中，可能需要多个不同的环境来运行，就可以使用多个配置文件，用来对应不同的运行环境。</p><h4 id="多配置文件命名"><a href="#多配置文件命名" class="headerlink" title="多配置文件命名"></a>多配置文件命名</h4><ul><li>application-dev.properties/yaml</li><li>application-pro.properties/yaml</li><li>application-{profile}.properties/yml</li></ul><h4 id="激活相应的配置文件"><a href="#激活相应的配置文件" class="headerlink" title="激活相应的配置文件"></a>激活相应的配置文件</h4><p>在Springboot中，默认加载的配置文件是<code>application.properties/yaml</code>，我们可以在<code>application.properties/yaml</code>中指定要加载的配置文件，在加载指定配置文件的同时，<code>application.properties/yaml</code>中的配置也会生效，如有重复，则使用指定配置文件中的配置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//加载application-&#123;profile&#125;.properties</span><br><span class="line"></span><br><span class="line">//第一种，配置文件中指定</span><br><span class="line">spring.profiles.active = &#123;profile&#125;</span><br><span class="line"></span><br><span class="line">//第二种，项目打包后在命令行启动</span><br><span class="line">java -jar xxx.jar --spring.profiles.active=dev；</span><br><span class="line"></span><br><span class="line">//第三种，虚拟机参数</span><br><span class="line">-Dspring.profiles.active=dev</span><br></pre></td></tr></table></figure><h5 id="yaml支持多文档块的形式"><a href="#yaml支持多文档块的形式" class="headerlink" title="yaml支持多文档块的形式"></a>yaml支持多文档块的形式</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//不同文档块使用---分割</span><br><span class="line">server:</span><br><span class="line">  port: 8080</span><br><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">    active: pro</span><br><span class="line">---</span><br><span class="line">server:</span><br><span class="line">  port: 8081</span><br><span class="line">spring:</span><br><span class="line">  profiles: dev</span><br><span class="line">---</span><br><span class="line">server:</span><br><span class="line">  port: 8082</span><br><span class="line">spring:</span><br><span class="line">  profiles: pro</span><br></pre></td></tr></table></figure><h4 id="配置文件加载位置"><a href="#配置文件加载位置" class="headerlink" title="配置文件加载位置"></a>配置文件加载位置</h4><p>springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Springboot的默认配置文件：</p><ol><li> /src/main/resources</li><li> /src/main/resources/config</li><li> /</li><li> /config</li></ol><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>这里项目根路径下的配置文件maven编译时不会打包过去，需要修改pom</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;resources&gt;</span><br><span class="line">    &lt;resource&gt;</span><br><span class="line">        &lt;directory&gt;.&lt;/directory&gt;</span><br><span class="line">        &lt;filtering&gt;true&lt;/filtering&gt;</span><br><span class="line">        &lt;includes&gt;</span><br><span class="line">            &lt;include&gt;**/*.properties&lt;/include&gt;</span><br><span class="line">            &lt;include&gt;**/*.yaml&lt;/include&gt;</span><br><span class="line">        &lt;/includes&gt;</span><br><span class="line">    &lt;/resource&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure><h4 id="项目打包好后，指定加载配置文件位置"><a href="#项目打包好后，指定加载配置文件位置" class="headerlink" title="项目打包好后，指定加载配置文件位置"></a>项目打包好后，指定加载配置文件位置</h4><p>项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认加载的这些配置文件共同起作用形成互补配置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar xxx.jar --spring.config.location=/home/cloudlandboy/application.yaml</span><br></pre></td></tr></table></figure><h2 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h2><h3 id="整合Mybatis"><a href="#整合Mybatis" class="headerlink" title="整合Mybatis"></a>整合Mybatis</h3><p>引入依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.1.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//配置数据源</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="string">//用户名</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="string">//密码</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">1234</span></span><br><span class="line">    <span class="string">//数据库对应的url和端口号，数据库名，&amp;serverTimezone=Asia/Shanghai配置时区，否则可能报错</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/jdbc&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br></pre></td></tr></table></figure><h3 id="操作数据库"><a href="#操作数据库" class="headerlink" title="操作数据库"></a>操作数据库</h3><h4 id="通过注解操作"><a href="#通过注解操作" class="headerlink" title="通过注解操作"></a>通过注解操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定这是一个操作数据库的mapper</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DepartmentMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;select * from department where id=#&#123;id&#125;&quot;)</span>   <span class="comment">//对应sql语句，使用select方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Department <span class="title">getDeptById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Delete(&quot;delete from department where id=#&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteDeptById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Options(useGeneratedKeys = true,keyProperty = &quot;id&quot;)</span></span><br><span class="line">    <span class="meta">@Insert(&quot;insert into department(departmentName) values(#&#123;departmentName&#125;)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insertDept</span><span class="params">(Department department)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Update(&quot;update department set departmentName=#&#123;departmentName&#125; where id=#&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">updateDept</span><span class="params">(Department department)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="通过配置文件操作"><a href="#通过配置文件操作" class="headerlink" title="通过配置文件操作"></a>通过配置文件操作</h4><p>添加mybatis相关配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.mabatis.entity</span>   <span class="string">//根据具体的实体类位置修改</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mapper/*.xml</span>   <span class="string">//添加操作数据库的文件的路径</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">map-underscore-to-camel-case:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>编写sql语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//mapper.xml文件的公用头部</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;</span><br><span class="line"></span><br><span class="line">&lt;mapper&gt;</span><br><span class="line">//在该区间编写具体实现</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><h3 id="后端代码层"><a href="#后端代码层" class="headerlink" title="后端代码层"></a>后端代码层</h3><p><strong>根目录：com.xxx</strong></p><ul><li>启动类<code>BajinsApplication.java</code>推荐放在根目录com.xxx包下</li><li>数据实体类<code>Entity</code>：mybatis项目: com.xxx.entity</li><li>数据接口访问层<code>Dao</code>：mybatis项目： com.xxx.mapper</li><li>数据服务接口层<code>Service</code>：com.xxx.service</li><li>数据服务接口实现层<code>Service Implements</code>：com.xxx.service.impl</li><li>前端控制器层<code>Controller</code>：com.xxx.controller</li></ul><h3 id="静态资源层"><a href="#静态资源层" class="headerlink" title="静态资源层"></a>静态资源层</h3><p><strong>根目录：resources</strong></p><ul><li><p>项目配置文件：resources/application.yml</p></li><li><p>静态资源目录：resources/static/                   //用于存放html、css、js、图片等资源</p></li><li><p>视图模板目录：resources/templates/           //用于存放jsp、thymeleaf等模板文件</p></li><li><p>mybatis映射文件：resources/mappers/</p></li></ul><h3 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h3><p>具体的业务模块流程的控制，controller层主要调用Service层里面的接口控制具体的业务流程，控制的配置也要在配置文件中进行。</p><p><code>@Controller</code>：用于定义控制器类，在spring项目中由控制器负责将用户发来的URL请求转发到对应的服务接口                          （service层），通常与<code>@RequestMapping</code> 合用</p><p><code>@RequestMapping</code>：提供路由信息，负责URL到Controller中的具体函数的映射。</p><p><code>@ResponseBody</code>：表示该方法的返回结果直接写入HTTP response body中，一般在异步获取数据时使用，用于                                构建RESTful的api。在使用 <code>@RequestMapping</code> 后，返回值通常解析为跳转路径，加上                                 <code>@Responsebody</code> 后返回结果不会被解析为跳转路径，而是直接写入HTTP response body中。                                比如异步获取json数据，加上 <code>@Responsebody</code> 后，会直接返回json数据。该注解一般会配合                                 <code>@RequestMapping</code> 一起使用。</p><p><code>@RestController</code>：相当于<code>@Controller</code> 和 <code>@ResponseBody</code> 的合集 , 在类中就不需要再添加 <code>@ResponseBody</code>                                     这个注解就可将返回结果直接写入HTTP response body中，不会跳转到页面。</p><p><code>@Autowired</code>：自动导入依赖的bean</p><p><code>@PostMapping</code>：用post方法来请求页面，相当于<code>@RequestMapping(method = RequestMethod.POST)</code></p><p><code>@GetMapping</code>：用get方法来请求页面，相当于<code>@RequestMapping(method = RequestMethod.GET)</code></p><p><code>@PutMapping</code>：用put方法来请求页面，相当于<code>@RequestMapping(method = RequestMethod.PUT)</code></p><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>业务模块的逻辑应用设计，先设计接口，再创建要实现的类，然后在配置文件中进行配置其实现的关联，在service层调用接口进行业务逻辑应用的处理，service层主要调用Dao层的接口</p><p><code>@Service</code>：在<strong>接口实现类</strong>加上该注解，用于标注业务层组件，如果不加，则会报错</p><h3 id="Dao"><a href="#Dao" class="headerlink" title="Dao"></a>Dao</h3><p>DAO层要先创建Dao接口，接着在配置文件中定义该接口的实现类；接着就可以在模块中调用Dao的接口进行数据业务的处理，dao层接口的实现类要放在resources文件夹下，文件格式为xml，用于操作数据库，调用的参数来自Entity层。</p><p><code>@Repository</code>：在接口文件中使用，标注这是一个持久化操作对象</p><h3 id="Entity"><a href="#Entity" class="headerlink" title="Entity"></a>Entity</h3><p>Entity层是用来定义与数据库对象应的属性，提供get/set/toString方法，有参无参构造函数。</p><p>如果想省略get/set/toString方法，有参无参构造函数，可以添加 <code>@Data</code> 注解，以及该依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="日志记录"><a href="#日志记录" class="headerlink" title="日志记录"></a>日志记录</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>Springboot自带的日志框架<code>SLF4j</code>和<code>logback</code>，在使用多种日志框架时，Springboot会自动替换成<code>SLF4j</code>框架</p><h4 id="控制台输出"><a href="#控制台输出" class="headerlink" title="控制台输出"></a>控制台输出</h4><p>日志级别从低到高分为：</p><blockquote><p><code>TRACE</code> &lt; <code>DEBUG</code> &lt; <code>INFO</code> &lt; <code>WARN</code> &lt; <code>ERROR</code> &lt; <code>FATAL</code>。</p></blockquote><p>如果设置为 <code>WARN</code> ，则低于 <code>WARN</code> 的信息都不会输出。<br><code>Spring Boot</code>中默认配置<code>ERROR</code>、<code>WARN</code>和<code>INFO</code>级别的日志输出到控制台。</p><h3 id="修改日志文件的相关设置"><a href="#修改日志文件的相关设置" class="headerlink" title="修改日志文件的相关设置"></a>修改日志文件的相关设置</h3><p>Springboot对于日志是默认输出到控制台，而不会生成日志文件，不方便查看，所以我们需要对其进行修改，使其能够自动生成日志文件，并储存日志信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">logging:</span><br><span class="line">  //设置不同日志的日志级别</span><br><span class="line">  level:</span><br><span class="line">    root: info</span><br><span class="line">    com.log: debug</span><br><span class="line">  //设置日志文件的储存位置，及文件名</span><br><span class="line">  file:</span><br><span class="line">    name: log/***.log</span><br></pre></td></tr></table></figure><h4 id="对与存储路径和文件名的定义"><a href="#对与存储路径和文件名的定义" class="headerlink" title="对与存储路径和文件名的定义"></a>对与存储路径和文件名的定义</h4><ul><li><code>logging.file</code>，设置文件，可以是绝对路径，也可以是相对路径。如：<code>logging.file=my.log</code></li><li><code>logging.path</code>，设置目录，会在该目录下创建<code>spring.log</code>文件，并写入日志内容，如：<code>logging.path=/var/log</code><br>如果只配置 <code>logging.file</code>，会在项目的当前路径下生成一个 <code>xxx.log</code> 日志文件。<br>如果只配置 <code>logging.path</code>，在 <code>/var/log</code>文件夹生成一个日志文件为 <code>spring.log</code></li></ul><blockquote><p>注：二者不能同时使用，如若同时使用，则只有<code>logging.file</code>生效<br>默认情况下，日志文件的大小达到<code>10MB</code>时会切分一次，产生新的日志文件，默认级别为：<code>ERROR、WARN、INFO</code></p></blockquote><h4 id="级别控制"><a href="#级别控制" class="headerlink" title="级别控制"></a>级别控制</h4><p>所有支持的日志记录系统都可以在<code>Spring</code>环境中设置记录级别（例如在<code>application.properties</code>中）<br>格式为：<code>&#39;logging.level.* = LEVEL&#39;</code></p><blockquote><p>logging.level<code>：日志级别控制前缀，*为包名或Logger名</code>                                                                    </p><p>LEVEL<code>：选项</code>TRACE, DEBUG, INFO, WARN, ERROR, FATAL, OFF</p></blockquote><h3 id="日志的默认配置"><a href="#日志的默认配置" class="headerlink" title="日志的默认配置"></a>日志的默认配置</h3><p>SpringBoot中有日志默认的生成以及切分，在这里我们可以重写SpringBoot默认日志配置，自定义日志大小和名称等等，在resources文件夹下添加logback-spring.xml进行配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;!--包含Spring boot对logback日志的默认配置--&gt;</span><br><span class="line">    &lt;include resource=&quot;org/springframework/boot/logging/logback/defaults.xml&quot; /&gt;</span><br><span class="line">    &lt;property name=&quot;LOG_FILE&quot; value=&quot;$&#123;LOG_FILE:-$&#123;LOG_PATH:-$&#123;LOG_TEMP:-$&#123;java.io.tmpdir:-/tmp&#125;&#125;&#125;/spring.log&#125;&quot;/&gt;</span><br><span class="line">    &lt;include resource=&quot;org/springframework/boot/logging/logback/console-appender.xml&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--重写了Spring Boot框架 org/springframework/boot/logging/logback/file-appender.xml 配置--&gt;</span><br><span class="line">    &lt;appender name=&quot;TIME_FILE&quot;</span><br><span class="line">              class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;</span><br><span class="line">        &lt;encoder&gt;</span><br><span class="line">            &lt;pattern&gt;$&#123;FILE_LOG_PATTERN&#125;&lt;/pattern&gt;</span><br><span class="line">        &lt;/encoder&gt;</span><br><span class="line">        &lt;file&gt;$&#123;LOG_FILE&#125;&lt;/file&gt;</span><br><span class="line">        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;</span><br><span class="line">            &lt;fileNamePattern&gt;$&#123;LOG_FILE&#125;.%d&#123;yyyy-MM-dd&#125;.%i&lt;/fileNamePattern&gt;</span><br><span class="line">            &lt;!--保留历史日志一个月的时间--&gt;</span><br><span class="line">            &lt;maxHistory&gt;30&lt;/maxHistory&gt;</span><br><span class="line">            &lt;!--</span><br><span class="line">            Spring Boot默认情况下，日志文件10M时，会切分日志文件,这样设置日志文件会在100M时切分日志</span><br><span class="line">            --&gt;</span><br><span class="line">            &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt;</span><br><span class="line">                &lt;maxFileSize&gt;10MB&lt;/maxFileSize&gt;</span><br><span class="line">            &lt;/timeBasedFileNamingAndTriggeringPolicy&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/rollingPolicy&gt;</span><br><span class="line">    &lt;/appender&gt;</span><br><span class="line"></span><br><span class="line">    &lt;root level=&quot;INFO&quot;&gt;</span><br><span class="line">        &lt;appender-ref ref=&quot;CONSOLE&quot; /&gt;</span><br><span class="line">        &lt;appender-ref ref=&quot;TIME_FILE&quot; /&gt;</span><br><span class="line">    &lt;/root&gt;</span><br><span class="line"></span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line">        &lt;!--</span><br><span class="line">            1、继承Spring boot logback设置（可以在appliaction.yml或者application.properties设置logging.*属性）</span><br><span class="line">            2、重写了默认配置，设置日志文件大小在10MB时，按日期切分日志</span><br><span class="line">        --&gt;</span><br></pre></td></tr></table></figure><h3 id="日志的切面处理类"><a href="#日志的切面处理类" class="headerlink" title="日志的切面处理类"></a>日志的切面处理类</h3><p>在pom.xml文件中添加依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--AOP--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>书写具体实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在该页面中对日志进行封装处理</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAspect</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取日志信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义切面，申明log()是一个切面</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.xwj.blog.controller.*.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在切面之前执行</span></span><br><span class="line">    <span class="meta">@Before(&quot;log()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">        HttpServletRequest request = attributes.getRequest();</span><br><span class="line">        <span class="comment">//获取URL、IP</span></span><br><span class="line">        String url = request.getRequestURL().toString();</span><br><span class="line">        String ip = request.getRemoteAddr();</span><br><span class="line">        <span class="comment">//获取请求方法</span></span><br><span class="line">        String classMethod = joinPoint.getSignature().getDeclaringTypeName() + <span class="string">&quot;.&quot;</span> + joinPoint.getSignature().getName();</span><br><span class="line">        <span class="comment">//获取请求参数</span></span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">        RequestLog requestLog = <span class="keyword">new</span> RequestLog(url, ip, classMethod, args);</span><br><span class="line">        <span class="comment">//打印日志信息</span></span><br><span class="line">        logger.info(<span class="string">&quot;Request : &#123;&#125;&quot;</span>, requestLog);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在切面之后执行</span></span><br><span class="line">    <span class="meta">@After(&quot;log()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfter</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//        logger.info(&quot;--------doAfter--------&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回之后拦截</span></span><br><span class="line">    <span class="meta">@AfterReturning(returning = &quot;result&quot;,pointcut = &quot;log()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterRuturn</span><span class="params">(Object result)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;Result : &#123;&#125;&quot;</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//封装请求参数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestLog</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String url;</span><br><span class="line">        <span class="keyword">private</span> String ip;</span><br><span class="line">        <span class="keyword">private</span> String classMethod;</span><br><span class="line">        <span class="keyword">private</span> Object[] args;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">RequestLog</span><span class="params">(String url, String ip, String classMethod, Object[] args)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.url = url;</span><br><span class="line">            <span class="keyword">this</span>.ip = ip;</span><br><span class="line">            <span class="keyword">this</span>.classMethod = classMethod;</span><br><span class="line">            <span class="keyword">this</span>.args = args;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&#123;&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;url=&#x27;&quot;</span> + url + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                    <span class="string">&quot;, ip=&#x27;&quot;</span> + ip + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                    <span class="string">&quot;, classMethod=&#x27;&quot;</span> + classMethod + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                    <span class="string">&quot;, args=&quot;</span> + Arrays.toString(args) +</span><br><span class="line">                    <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><h4 id="异常类"><a href="#异常类" class="headerlink" title="异常类"></a>异常类</h4><ol><li>Java 内部的异常类 <code>Throwable</code> 包括了 <code>Exception</code> 和 <code>Error</code> 两大类，所有的异常类都是 <code>Object</code> 对象。</li><li><code>Error</code> 是不可捕捉的异常，比如 java 虚拟机运行错误，当内存资源错误，将会出现 <code>OutOfMemoryError</code>。此时 java 虚拟机会选择终止线程。</li><li><code>Excetpion</code> 异常是程序本身引起的，它又分为运行时异常 <code>RuntimeException</code>，和非运行时（编译时）<code>IOException</code> 等异常。</li><li>运行时异常 <code>RuntimeException</code> 例如：除数为零，将引发 <code>ArrayIndexOutOfBoundException</code> 异常。</li><li>非运行异常都是可查可捕捉的。Java 编译器会告诉程序他错了，错在哪里，正确的建议什么。我们可以通过 throws 配合 <code>try-catch</code> 来处理。</li></ol><h4 id="异常处理机制"><a href="#异常处理机制" class="headerlink" title="异常处理机制"></a>异常处理机制</h4><ul><li>抛出异常：当一个方法出现错误引发异常时，方法创建异常对象并交付运行时系统，异常对象中包含了异常类                                    型和异常出现时的程序状态等异常信息。运行时系统负责寻找处置异常的代码并执行。</li><li>捕获异常：当方法抛出异常之后，系统将会为其寻找合适的异常处理器运行时系统从发生异常的方法开                     始，依次回查调用栈中的方法，直至找到含有合适异常处理器的方法并执行，如果找不到合适                     的，则程序会终止。</li></ul><h4 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h4><p>通过<code>try</code>，<code>catch</code>，<code>finally</code>的语句来捕获异常，其中<code>finally</code>语句不是必须的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//可能出现异常的业务代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception1 e1)&#123;</span><br><span class="line">    <span class="comment">//异常处理1</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception2 e2)&#123;</span><br><span class="line">    <span class="comment">//异常处理2</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exceptionn en)&#123;</span><br><span class="line">    <span class="comment">//异常处理n...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//无论是否是否异常都会执行的地方</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Springboot中的异常处理"><a href="#Springboot中的异常处理" class="headerlink" title="Springboot中的异常处理"></a>Springboot中的异常处理</h4><p>通过  <code>@ControllerAdvice</code>  注解来处理异常</p><ol><li>在 Web 项目中通过 <code>@ControllerAdvice</code> <code>@RestControllerAdvice</code> 实现全局异常处理<br><code>@ControllerAdvice</code> 和 <code>@RestControllerAdvice</code> 的区别 相当于 <code>Controller</code> 和 <code>RestController</code> 的区别。</li><li>在 Web 项目中实现 404、500 等状态的页面单独渲染，可以自行定义</li><li>在 Spring Boot 项目中使用 Aop 切面编程实现全局异常处理</li></ol><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><p>因为返回的异常需要通过状态页面来反馈，所以需要web 和 thymeleaf 两个依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><h3 id="用于捕捉Controller中的异常拦截器"><a href="#用于捕捉Controller中的异常拦截器" class="headerlink" title="用于捕捉Controller中的异常拦截器"></a>用于捕捉Controller中的异常拦截器</h3><p>用于处理自定义异常，当代码出现问题的时候，跳转到自定义的错误页面，将该文件放在controller文件夹下，可再创建一个文件夹将其放入其中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表示拦截掉所有带有@Controller注解的控制器</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span>     </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ControllerExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    将异常记录到日志</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>: 处理错误信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span>: request：访问的异常URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span>: e：异常参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Return</span>: 返回错误信息页面</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span>    <span class="comment">//表明是异常处理方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">exceptionHander</span><span class="params">(HttpServletRequest request, Exception e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//记录异常信息，写入日志：请求的URL，异常信息</span></span><br><span class="line">        logger.error(<span class="string">&quot;Requst URL : &#123;&#125;，Exception : &#123;&#125;&quot;</span>, request.getRequestURL(),e);</span><br><span class="line"></span><br><span class="line"><span class="comment">//当标识了状态码的时候就不拦截，如404，500，系统会自动跳转到相应页面</span></span><br><span class="line">        <span class="keyword">if</span> (AnnotationUtils.findAnnotation(e.getClass(), ResponseStatus.class) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将记录的异常信息返回到error页面</span></span><br><span class="line">        ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        mv.addObject(<span class="string">&quot;url&quot;</span>,request.getRequestURL());</span><br><span class="line">        mv.addObject(<span class="string">&quot;exception&quot;</span>, e);</span><br><span class="line">        mv.setViewName(<span class="string">&quot;error/error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="错误对应的前端页面"><a href="#错误对应的前端页面" class="headerlink" title="错误对应的前端页面"></a>错误对应的前端页面</h4><p>这里可以根据个人想法来DIY，只要将其放在<code>resources/templates/error</code>文件夹下即可，通过thymeleaf对其进行渲染，可以配合项目进行个性化设计。</p><h2 id="Thymeleaf"><a href="#Thymeleaf" class="headerlink" title="Thymeleaf"></a>Thymeleaf</h2><h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><p>Springboot中自带的模板引擎，用于渲染前端页面，可以实现前后端同时开发，并且上手简单</p><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="使用模板"><a href="#使用模板" class="headerlink" title="使用模板"></a>使用模板</h3><p>直接将HTML文件放在 <code>resources/templates/</code>  下，Thymeleaf即可自动进行渲染</p><p>可以在Controller文件中进行数据处理，然后通过返回页面的方式，来访问该页面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;!-- 添加 xmlns:th=&quot;http://www.thymeleaf.org 可避免编辑器出现html验证错误，可使用th:语法 --&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><h4 id="变量表达式"><a href="#变量表达式" class="headerlink" title="变量表达式  ${}"></a>变量表达式  <code>$&#123;&#125;</code></h4><p>使用方法：直接使用<code>th:xx = &quot;$&#123;&#125;&quot;</code> 获取对象属性 。例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;userForm&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;id&quot;</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;user.id&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;user.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;user.password&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:text</span>=<span class="string">&quot;hello&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;user.username&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="选择变量表达式"><a href="#选择变量表达式" class="headerlink" title="选择变量表达式 *{}"></a>选择变量表达式 <code>*&#123;&#125;</code></h4><p>使用方法：首先通过<code>th:object</code> 获取对象，然后使用<code>th:xx = &quot;*&#123;&#125;&quot;</code>获取对象属性。</p><p>这种简写风格极为清爽，推荐大家在实际项目中使用。 例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;userForm&quot;</span> <span class="attr">th:object</span>=<span class="string">&quot;$&#123;user&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;id&quot;</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;*&#123;id&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;*&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;*&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="链接表达式"><a href="#链接表达式" class="headerlink" title="链接表达式 @{}"></a>链接表达式 <code>@&#123;&#125;</code></h4><p>在书写静态页面时，可能用不到，但是生成动态页面时，就需要将静态资源，使用链接表达式来让动态页面也能够访问到静态资源。</p><p>使用方法：通过链接表达式<code>@&#123;&#125;</code>直接拿到应用路径，然后拼接静态资源路径。例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/webjars/jquery/jquery.js&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/webjars/bootstrap/css/bootstrap.css&#125;&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="片段表达式"><a href="#片段表达式" class="headerlink" title="片段表达式 ~{}"></a>片段表达式 <code>~&#123;&#125;</code></h4><ul><li>片段表达式是Thymeleaf的特色之一，细粒度可以达到标签级别</li><li>在实际编写页面中，总会有重复的片段，此时便可以使用片段表达式，减少重复的代码的书写，使代码更简洁。</li></ul><p> 片段表达式拥有三种语法：</p><ul><li><code>~&#123; viewName &#125; 表示引入完整页面</code></li><li><code>~&#123; viewName ::selector&#125; 表示在指定页面寻找片段 其中selector可为片段名、jquery选择器等</code></li><li><code>~&#123; ::selector&#125; 表示在当前页寻找</code></li></ul><p>使用方法：首先通过<code>th:fragment</code>定制片段 ，然后通过<code>th:replace</code> 填写片段路径和片段名。例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- /views/common/head.html--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span> <span class="attr">th:fragment</span>=<span class="string">&quot;static&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/webjars/jquery/3.3.1/jquery.js&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- /views/your.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:replace</span>=<span class="string">&quot;~&#123;common/head::static&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在实际使用中，我们往往使用更简洁的表达，去掉表达式外壳直接填写片段名。例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- your.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:replace</span>=<span class="string">&quot;common/head::static&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>值得注意的是，使用替换路径<code>th:replace</code> 开头请勿添加斜杠，避免部署运行的时候出现路径报错。（因为默认拼接的路径为<code>spring.thymeleaf.prefix = classpath:/templates/</code>）</p><h4 id="消息表达式"><a href="#消息表达式" class="headerlink" title="消息表达式"></a>消息表达式</h4><p>即通常的国际化属性：<code>#&#123;msg&#125;</code>  用于获取国际化语言翻译值。例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">title</span> <span class="attr">th:text</span>=<span class="string">&quot;#&#123;user.title&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="其它表达式"><a href="#其它表达式" class="headerlink" title="其它表达式"></a>其它表达式</h4><p>在基础语法中，默认支持字符串连接、数学运算、布尔逻辑和三目运算等。例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;&#x27;I am &#x27;+(user.name!=null?user.name:&#x27;NoBody&#x27;)&#125;&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="静态资源映射"><a href="#静态资源映射" class="headerlink" title="静态资源映射"></a>静态资源映射</h3><p>我们自己添加的静态资源，都存放在resources文件夹下，HTML文件一般都放在<code>templates/</code>文件夹下，css,js以及一些图片都放在<code>static/</code>文件夹下。</p><p>在访问页面时，如果要更改网站图标，即可将想要的图标文件放在<code>resources</code>文件夹下命名为 <code>favicon.ico</code> 。</p><h3 id="迭代循环"><a href="#迭代循环" class="headerlink" title="迭代循环"></a>迭代循环</h3><p>想要遍历<code>List</code>集合很简单，配合<code>th:each</code> 即可快速完成迭代。例如遍历用户列表：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:each</span>=<span class="string">&quot;user:$&#123;userList&#125;&quot;</span>&gt;</span></span><br><span class="line">    账号：<span class="tag">&lt;<span class="name">input</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;user.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;user.password&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><p>条件判断通常用于动态页面的初始化，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;userList&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>的确存在..<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果想取反则使用unless 例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:unless</span>=<span class="string">&quot;$&#123;userList&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>不存在..<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="日期格式化"><a href="#日期格式化" class="headerlink" title="日期格式化"></a>日期格式化</h3><p>使用默认的日期格式(toString方法) 并不是我们预期的格式：<code>Mon Dec 03 23:16:50 CST 2018</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input <span class="built_in">type</span>=<span class="string">&quot;text&quot;</span> th:value=<span class="string">&quot;<span class="variable">$&#123;user.createTime&#125;</span>&quot;</span>/&gt;</span><br></pre></td></tr></table></figure><p>此时可以通过时间工具类<code>#dates</code>来对日期进行格式化：<code>2018-12-03 23:16:50</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input <span class="built_in">type</span>=<span class="string">&quot;text&quot;</span> th:value=<span class="string">&quot;<span class="variable">$&#123;#dates.format(user.createTime,&#x27;yyyy-MM-dd HH:mm:ss&#x27;)&#125;</span>&quot;</span>/&gt;</span><br></pre></td></tr></table></figure><h2 id="Swagger接口文档"><a href="#Swagger接口文档" class="headerlink" title="Swagger接口文档"></a>Swagger接口文档</h2><h3 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h3><p>swagger是一个功能非常强大的接口文档生成工具，我们只需遵守其规范添加一些说明，swagger即可在线自动帮我们生成接口文档。</p><h3 id="添加依赖-1"><a href="#添加依赖-1" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 添加swagger依赖 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.9.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- 添加Swagger-ui依赖 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.9.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="配置Swagger"><a href="#配置Swagger" class="headerlink" title="配置Swagger"></a>配置Swagger</h3><p>要想使用Swagger，要创建一个swagger的配置类SwaggerConfig，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@Configuration    // 标明是配置类</span><br><span class="line">@EnableSwagger2   //开启swagger功能</span><br><span class="line">@ConditionalOnProperty(prefix = &quot;mconfig&quot;, name = &quot;swagger-ui-open&quot;, havingValue = &quot;true&quot;)</span><br><span class="line">public class SwaggerConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public Docket api() &#123;</span><br><span class="line">        return new Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .select()</span><br><span class="line">                //该项目中任意包内的接口</span><br><span class="line">                //.apis(RequestHandlerSelectors.any())       </span><br><span class="line">                //只显标包内的接口文档</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(&quot;com.springboot.swagger&quot;))</span><br><span class="line">                .paths(PathSelectors.any()) //所有接口   </span><br><span class="line">                //通过url来筛选接口</span><br><span class="line">     //.paths(Predicates.or(PathSelectors.ant(&quot;/addUser&quot;),PathSelectors.ant(&quot;/getUser&quot;))) </span><br><span class="line">                .build()</span><br><span class="line">                .apiInfo(apiInfo());    //显示下方的自编信息</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private ApiInfo apiInfo() &#123;</span><br><span class="line">        return new ApiInfo(</span><br><span class="line">                &quot;Spring Boot 项目集成 Swagger 实例文档&quot;,</span><br><span class="line">                &quot;描述&quot;,</span><br><span class="line">                &quot;API V1.0&quot;,</span><br><span class="line">                &quot;Terms of service&quot;,</span><br><span class="line">                new Contact(&quot;名字&quot;, &quot;链接地址&quot;, &quot;邮箱&quot;),</span><br><span class="line">                &quot;Apache&quot;, &quot;http://www.apache.org/&quot;, Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置文件中加入配置"><a href="#配置文件中加入配置" class="headerlink" title="配置文件中加入配置"></a>配置文件中加入配置</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//用来控制Swagger文档的开启与关闭</span></span><br><span class="line"><span class="attr">mconfig:</span></span><br><span class="line">  <span class="attr">swagger-ui-open :</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="访问SwaggerApi文档"><a href="#访问SwaggerApi文档" class="headerlink" title="访问SwaggerApi文档"></a>访问SwaggerApi文档</h3><p>运行该项目，通过访问<code>http://localhost:8080/swagger-ui.html</code>即可看到接口文档</p><p><img src="C:\Users\28165\Pictures\Screenshots\QQ截图20200826182330.png" class="lazyload" data-srcset="C:\Users\28165\Pictures\Screenshots\QQ截图20200826182330.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><h3 id="定义接口信息"><a href="#定义接口信息" class="headerlink" title="定义接口信息"></a>定义接口信息</h3><p>不同的controller文件，需要定义为不同的接口组，可以使用<code>@Api(tags = &quot;***&quot;)</code>来划分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Api(tags = &quot;用户信息管理&quot;,description = &quot;提供用户的相关基础信息&quot;)</span> <span class="comment">//tags是该组的名字</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ApiOperation(&quot;获取用户信息&quot;)</span>     <span class="comment">//定义接口的名字</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/getUser&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">GetUserById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;更新用户信息&quot;)</span></span><br><span class="line">    <span class="meta">@PutMapping(&quot;/updateUser&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">UpdateUser</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;删除用户&quot;)</span></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/deleteUser&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">DeleteUserById</span><span class="params">(<span class="meta">@PathVariable</span> <span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;增加用户&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/addUser&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">AddUser</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/text&quot;)</span></span><br><span class="line"><span class="meta">@Api(tags = &quot;测试相关接口&quot;,description = &quot;测试&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ApiOperation(&quot;测试测试0&quot;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/get&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetText</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ceshi&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同controller文件的不同组名</p><p><img src="C:\Users\28165\Pictures\Screenshots\QQ截图20200826183045.png" class="lazyload" data-srcset="C:\Users\28165\Pictures\Screenshots\QQ截图20200826183045.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>接口的路径及相关信息</p><p><img src="C:\Users\28165\Pictures\Screenshots\QQ截图20200826184657.png" class="lazyload" data-srcset="C:\Users\28165\Pictures\Screenshots\QQ截图20200826184657.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>点击相关接口，就可以对其进行简单的调试。</p><h4 id="ApiImplicitParams和-ApiImplicitParam-常用配置项"><a href="#ApiImplicitParams和-ApiImplicitParam-常用配置项" class="headerlink" title="@ApiImplicitParams和@ApiImplicitParam 常用配置项"></a>@ApiImplicitParams和@ApiImplicitParam 常用配置项</h4><p>对于非实体类参数，可以使用<code>@ApiImplicitParams</code>和<code>@ApiImplicitParam</code>来声明请求参数。<br><code>@ApiImplicitParams</code>用在方法头上，<code>@ApiImplicitParam</code>定义在<code>@ApiImplicitParams</code>里面，一个<code>@ApiImplicitParam</code>对应一个参数。</p><ul><li><code>name</code>：用来定义参数的名字，也就是字段的名字,可以与接口的入参名对应。如果不对应，也会生成，所以可以用来定义额外参数！</li><li><code>value</code>：用来描述参数</li><li><code>required</code>：用来标注参数是否必填</li><li><code>paramType</code>：有path,query,body,form,header等方式，但对于对于非实体类参数的时候，常用的只有path,query,header；body和form是不常用的。body不适用于多个零散参数的情况，只适用于json对象等情况。</li></ul><h3 id="定义实体类信息"><a href="#定义实体类信息" class="headerlink" title="定义实体类信息"></a>定义实体类信息</h3><p>项目中的实体类，也可以在接口文档中显示，通过<code>@ApiModel(&quot;***&quot;)</code> 来定义实体类的名称，通过<code>@ApiModelProperty(&quot;***&quot;)</code> 来定义实体类中的属性的名称</p><h4 id="ApiModelProperty一些常用的配置"><a href="#ApiModelProperty一些常用的配置" class="headerlink" title="@ApiModelProperty一些常用的配置"></a>@ApiModelProperty一些常用的配置</h4><p><code>value</code>：字段说明</p><p><code>example</code>：设置请求示例（Example Value）的默认值，如果不配置，当字段为string的时候，此时请求示例中默                                    认值为””.name：用新的字段名来替代旧的字段名。</p><p><code>allowableValues</code>：限制值得范围，例如<code>&#123;1,2,3&#125;</code>代表只能取这三个值；<code>[1,5]</code>代表取1到5的值；<code>(1,5)</code>代表1                                    到5的值，不包括1和5；还可以使用infinity或-infinity来无限值，比如<code>[1, infinity]</code>代表                                    最小值为1，最大值无穷大。</p><p><code>required</code>：标记字段是否必填，默认是false,</p><p><code>hidden</code>：用来隐藏字段，默认是false，如果要隐藏需要使用true，因为字段默认都会显示，就算没有</p><p>​                <code>@ApiModelProperty</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiModel(&quot;用户实体&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;用户Id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;用户名&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;是否被删除&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> is_delete;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行项目后，实体类的接口会显示在接口下方（即Models）</p><p><img src="C:\Users\28165\Pictures\Screenshots\QQ截图20200826185313.png" class="lazyload" data-srcset="C:\Users\28165\Pictures\Screenshots\QQ截图20200826185313.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>在Models中即可看到拥有的属性</p><p><img src="C:\Users\28165\Pictures\Screenshots\QQ截图20200826185506.png" class="lazyload" data-srcset="C:\Users\28165\Pictures\Screenshots\QQ截图20200826185506.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://gumutianqi1.gitbooks.io/specification-doc/content/tools-doc/spring-boot-swagger2-guide.html">Swagger 使用手册</a></p><p><a href="https://swagger.io/">Swagger官网</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;SpringBoot 的简单介绍&lt;/p&gt;</summary>
    
    
    
    <category term="SpringBoot" scheme="http://xucoud.github.io/categories/SpringBoot/"/>
    
    
    <category term="SpringBoot" scheme="http://xucoud.github.io/tags/SpringBoot/"/>
    
  </entry>
  
</feed>
