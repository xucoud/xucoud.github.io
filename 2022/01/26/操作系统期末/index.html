<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="/img/logo_miccall.png"/>
	<link rel="shortcut icon" href="/img/logo_miccall.png">
	
			    <title>
    Xu's Blog
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    <meta name="keywords" content="miccall" />
    
    	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	 
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('/img/bg.jpg') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

			    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<meta name="generator" content="Hexo 5.4.1"><link rel="alternate" href="/atom.xml" title="Xu's Blog" type="application/atom+xml">
</head>
    
		
<!-- Layouts -->



<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_coy.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">MICCALL</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/Go/">Go</a></li><li><a class="category-link" href="/categories/Go/GC/">GC</a></li><li><a class="category-link" href="/categories/Go/GMP/">GMP</a></li><li><a class="category-link" href="/categories/Go/ORM/">ORM</a></li><li><a class="category-link" href="/categories/Go/Web/">Web</a></li><li><a class="category-link" href="/categories/Go/module/">module</a></li><li><a class="category-link" href="/categories/Go/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/">内存分配</a></li><li><a class="category-link" href="/categories/Go/%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8/">内存逃逸</a></li><li><a class="category-link" href="/categories/Java/">Java</a></li><li><a class="category-link" href="/categories/Redis/">Redis</a></li><li><a class="category-link" href="/categories/Restful/">Restful</a></li><li><a class="category-link" href="/categories/Spring/">Spring</a></li><li><a class="category-link" href="/categories/SpringBoot/">SpringBoot</a></li><li><a class="category-link" href="/categories/k8s/">k8s</a></li><li><a class="category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></li><li><a class="category-link" href="/categories/%E5%89%8D%E7%AB%AF/js/">js</a></li><li><a class="category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li><li><a class="category-link" href="/categories/%E6%9C%9F%E6%9C%AB/">期末</a></li><li><a class="category-link" href="/categories/%E6%9C%9F%E6%9C%AB/JAVA/">JAVA</a></li><li><a class="category-link" href="/categories/%E6%9C%9F%E6%9C%AB/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></li><li><a class="category-link" href="/categories/%E6%9C%9F%E6%9C%AB/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/">算法设计与分析</a></li><li><a class="category-link" href="/categories/%E6%9C%9F%E6%9C%AB/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></li><li><a class="category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a>
	                    </ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/about/" title="简历">
		                简历
		            </a>
		        </li>
		        
		        <li>
		            <a href="/group/" title="团队">
		                团队
		            </a>
		        </li>
		        
		        <li>
		            <a href="/gallery/" title="图库">
		                图库
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="标签">
		                标签
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
                    
                    <li>
                        <a title="github" href="https://github.com/miccall" target="_blank" rel="noopener">
                            <i class="icon fa fa-github"></i>
                        </a>
                    </li>
                    
                    <li>
                        <a title="500px" href="http://500px.com" target="_blank" rel="noopener">
                            <i class="icon fa fa-500px"></i>
                        </a>
                    </li>
                    
			</ul>
</nav>

        <div id="main" >
            <div class ="post_page_title_img" style="height: 25rem;background-image: url();background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;" >
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2 >操作系统期末</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
                <span id="more"></span>

<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="操作系统的分类"><a href="#操作系统的分类" class="headerlink" title="操作系统的分类"></a>操作系统的分类</h3><ul>
<li><p>批量操作系统</p>
</li>
<li><p>分时操作系统</p>
</li>
<li><p>实时操作系统</p>
</li>
<li><p>个人计算机操作系统</p>
</li>
<li><p>网络操作系统</p>
</li>
<li><p>分布式操作系统</p>
</li>
</ul>
<h3 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h3><p>并发共享，虚拟同步</p>
<h3 id="多道程序设计技术"><a href="#多道程序设计技术" class="headerlink" title="多道程序设计技术"></a>多道程序设计技术</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p><strong>多道程序设计技术</strong>是在计算机内存中同时存放几道相互独立的程序，它们在管理程序的控制下相互穿插地运行。</p>
<h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><ul>
<li>多道——计算机主存中存放几道相互独立的程序</li>
<li>宏观上并行——都处于运行状态，但都未运行完</li>
<li>微观上串行——各作业交替使用CPU</li>
</ul>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li><p><strong>资源利用率高</strong>：CPU和内存利用率较高；</p>
</li>
<li><p><strong>作业吞吐量大</strong>：单位时间内完成的工作总量大；</p>
</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li><strong>用户交互性差</strong>：整个作业完成后或中间出错时，才与用户交互，不利于调试和修改；</li>
<li><strong>作业平均周转时间长</strong>：短作业的周转时间显著增长；</li>
</ul>
<h3 id="分时技术"><a href="#分时技术" class="headerlink" title="分时技术"></a>分时技术</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>​        把处理机的响应时间分成若于个大小相等（或不相等）的时间单位，称为时间片（如100毫秒），每个终端用户获得CPU，就等于获得一个时间片，该用户程序开始运行，当时间片到（用完），用户程序暂停运行，等待下一次运行。</p>
<h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><p>​        它一般采用 <strong>时间片轮转</strong> 的办法，使一台计算机同时为多个终端用户服务，对每个用户都能保证足够快的响应时间，并提供交互会话功能。</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li><p>同时性：众多联机用户可以同时使用同一台计算机</p>
</li>
<li><p>独占性：各终端用户感觉到自己独占了计算机</p>
</li>
<li><p>及时性：用户的要求能够及时得到响应</p>
</li>
<li><p>交互性：用户与计算机之间可进行会话</p>
</li>
</ul>
<h3 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h3><h4 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h4><p>​        <strong>实时操作系统</strong>是又一种类型的操作系统，对外部的请求，实时操作系统能够在规定的时间内处理完毕。主要用于过程控制、事务处理等有实时要求的领域，其<strong>主要特征</strong>是<code>实时性</code>和<code>可靠性</code>。</p>
<p><strong>实时：</strong>指计算机对于用户请求能足够快地进行处理，并做出反映。要求毫秒、微秒级。</p>
<h4 id="应用领域"><a href="#应用领域" class="headerlink" title="应用领域"></a>应用领域</h4><p><strong>实时控制</strong>：    工业过程控制、防空系统等</p>
<p><strong>实时信息处理</strong>：情报检索和查询、飞机订票系统、银行信用卡系统。</p>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul>
<li>系统对外部的信号必须能及时响应，(在规定的时间内（deadlin）)；</li>
<li>要求高可靠性和安全性，效率则放在第二位；</li>
<li>系统整体性强；</li>
<li>不要求很强的“会话”能力。</li>
</ul>
<h3 id="分时，批处理系统的异同"><a href="#分时，批处理系统的异同" class="headerlink" title="分时，批处理系统的异同"></a>分时，批处理系统的异同</h3><ol>
<li><p>用户体验上：<strong>批处理系统</strong>用户交互性差，只有作业完成或出错时才与用户交互，用户也不能控制作业的运行；而<strong>分时系统</strong>可以让用户的要求得到及时的响应</p>
</li>
<li><p>侧重层面上：<strong>批处理系统</strong>侧重于多个程序与操作系统的关系；<strong>分时系统</strong>侧重于多个用户与操作系统的关系</p>
</li>
<li><p>进程调度方式不同：<strong>批处理系统</strong>属于非抢占式的进程调度，只有一个程序因I/O请求阻塞时，才会执行下一道程序；<strong>分时系统</strong>属于抢占式的进程调度，一个程序只能在分配给他的时间片中才可以执行，时间片用完了，不管是否执行完，都要进行切换。</p>
</li>
<li><p>目的不同：<strong>批处理系统</strong>的目的是为了解决人机矛盾及CPU和I/O设备之间速度不匹配矛盾，提高系统有效性（包括资源利用率和吞吐量），并不提供人际交互能力；<strong>分时系统</strong>是实现人机交互的系统</p>
</li>
<li><p>相同：都是在微观上串行，宏观上并行</p>
</li>
</ol>
<h2 id="组织结构"><a href="#组织结构" class="headerlink" title="组织结构"></a>组织结构</h2><h3 id="操作系统的接口"><a href="#操作系统的接口" class="headerlink" title="操作系统的接口"></a>操作系统的接口</h3><ol>
<li>命令接口：（作业一级）提供一组控制命令供用户去组织和控制自己的作业</li>
<li>系统调用：（程序一级）通过一组广义指令（或称系统调用）供用户程序和其他系统程序调用</li>
</ol>
<h3 id="处理机的状态"><a href="#处理机的状态" class="headerlink" title="处理机的状态"></a>处理机的状态</h3><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ol>
<li>核态：CPU执行操作系统程序时所处的状态。在此状态下允许CPU使用全部资源和全部指令，其中包括一组特权指令（如涉及外设的I/O、改变处理机状态、修改存储保护的指令），实现对系统资源的分配与管理，为用户提供使用外部设备的服务。</li>
<li>管态：管态比核态的权限低，在此状态下允许使用一些用户态下不能使用的资源，但不能使用修改CPU状态的指令。无核态时，管态执行核态的全部功能。</li>
<li>用户态：用户程序执行时CPU所处的状态。在此状态下禁止使用特权指令，不能直接使用系统资源与改变CPU状态，并且只能访问用户程序所在的存储空间。</li>
</ol>
<h4 id="CPU状态转变"><a href="#CPU状态转变" class="headerlink" title="CPU状态转变"></a>CPU状态转变</h4><ol>
<li><p>目态–管态  ：其转换的唯一途径是通过中断</p>
</li>
<li><p>管态–目态  ：可用设置PSW(修改程序状态字)可实现</p>
</li>
</ol>
<h3 id="特权指令集"><a href="#特权指令集" class="headerlink" title="特权指令集"></a>特权指令集</h3><ol>
<li>在核态下操作系统可以使用所有指令，包括一组特权指令：<ul>
<li>允许和禁止中断；</li>
<li>在进程之间切换处理机；</li>
<li>存取用于内存保护的寄存器；</li>
<li>执行输入和输出操作；</li>
<li>停止一个中央处理机的工作。</li>
</ul>
</li>
<li>在下列情况下，由用户态转向核态：<ul>
<li>用户程序要求操作系统的服务，系统调用；</li>
<li>发生一次中断；</li>
<li>在用户程序中产生了一个错误的状态；</li>
<li>在用户程序中企图执行一条特权指令；</li>
</ul>
</li>
<li>从核态转回用户态用一条指令实现，这条指令也是特权指令。一般情况下是<strong>中断返回指令</strong>。</li>
</ol>
<h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><h4 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h4><ol>
<li>中断：是指某个事件（例如，电源掉电、浮点运算溢出、外部设备传输完成或出错等）发生时，系统中止现运行程序的执行，引出处理事件程序对相应事件进行处理，处理完毕后返回断点继续执行。</li>
<li>中断源：引起中断的事件称中断源，如打印完成中断，其中断源是打印机。</li>
<li>断点：发生中断时正在运行的程序被暂时停止，程序的暂停点称为断点。例如，某程序正在执行0200地址的指令被中断，那么，0200地址就是断点， 在中断返回时就执行0200的下一条指令。</li>
<li>中断响应：是处理机发现有中断请求时，中止现运行程序的执行并自动引出中断处理程序的过程。</li>
<li>中断处理程序：对中断事件进行处理的程序叫中断处理程序。如时钟中断处理、打印机完成中断处理、打印机缺纸中断处理等等。它是操作系统中与硬件最接近的一部分，是操作系统与硬件的接口。</li>
</ol>
<h4 id="引入中断的目的"><a href="#引入中断的目的" class="headerlink" title="引入中断的目的"></a>引入中断的目的</h4><ol>
<li>解决主机与外设的并行工作问题</li>
<li>提高可靠性</li>
<li>实现多机联系</li>
<li>实现实时控制</li>
</ol>
<h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><ol>
<li><p>中断随机的</p>
<ol start="2">
<li>中断是可恢复的</li>
<li>中断是自动处理的</li>
</ol>
</li>
</ol>
<h4 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h4><ol>
<li>输入输出中断：它是当外部设备或通道操作正常结束或发生错误时所发生的中断。例如：打印机打印完成、缺纸，读磁盘时相应驱动器中没有磁盘等。</li>
<li>外中断：对某个中央处理机而言，它的外部非通道式装置所引起的中断称为外部中断。例如，时钟中断、操作员控制台中断，多处理机系统中CPU到CPU之间的通信中断等。</li>
<li>硬件故障中断：当机器发生故障时的中断叫硬件故障中断。例如，电源故障、内存单元奇偶校验错。</li>
<li>程序性中断：在程序执行的过程中，发现了程序性质的错误或出现了某些特定状态而产生的中断。如浮点溢出、用户态下使用了特权指令、内存越界、跟踪等。</li>
<li>访管中断：对操作系统提出某种请（需）求时所发生的中断。例如，创建进程，I/O传输、打开文件、关闭文件、文件的读、写等系统调用。</li>
</ol>
<blockquote>
<p>以上五种中断也归纳成两类<br>其一是来自处理机外部的事件，称为<strong>外部中断</strong>，如I/O中断、外中断。<br>另一类是来自处理机的中断，称为<strong>内部中断</strong>，如硬件故障中断、程序性中断、访管中断。这类中断有时称俘获（也有称陷入、陷阱、自陷、捕俘等，它的英文名称为 trap，来自早期的UNIX系统）。</p>
</blockquote>
<h4 id="中断机制"><a href="#中断机制" class="headerlink" title="中断机制"></a>中断机制</h4><ol>
<li>保护现场</li>
<li>中断响应</li>
<li>中断处理</li>
<li>恢复现场</li>
</ol>
<p><strong>现场</strong>：是被中断断点时刻处理机的各种信息，包括：</p>
<ol>
<li><p>程序状态字；</p>
</li>
<li><p>各寄存器的值；</p>
</li>
<li><p>打开文件的状态</p>
</li>
</ol>
<p><strong>保护现场：</strong>在进入中断时将现场信息保存到指定的位置，一般情况是保留到系统栈中。</p>
<p><strong>恢复现场：</strong>在中断处理完成后，返回断点之前将保留在栈中的断点的现场信息恢复，使被中断的程序能继续正确地执行。</p>
<h4 id="中断响应"><a href="#中断响应" class="headerlink" title="中断响应"></a>中断响应</h4><p><strong>中断响应：</strong>是处理机发现有中断请求时，中止现运行程序的执行，并自动引出中断处理程序的过程。中断响应的实质是交换指令执行地址和处理机的状态，以达到如下目的：</p>
<ol>
<li>保留程序断点及有关信息；</li>
<li>自动转入相应的中断处理程序执行。</li>
</ol>
<p><strong>中断响应过程:</strong></p>
<ol>
<li><p>发现中断源(识别中断原因)</p>
</li>
<li><p>保存现场,将中断向量推入系统堆栈</p>
</li>
<li><p>引出中断处理程序</p>
</li>
</ol>
<p><strong>中断响应具体做法:</strong> </p>
<ol>
<li>CPU在执行每条指令后扫描中断寄存器，查看有无中断请求。</li>
<li>如果没有，则运行下一条指令；</li>
<li>如果有中断请求，则通过交换中断向量引出（进入）中断处理程序</li>
</ol>
<h4 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h4><p>​        中断处理和自陷处理的过程是类似的，当硬件完成了中断进入后，转到中断处理程序，进入软件中断处理过程。这个过程主要有如下三项工作：</p>
<ol>
<li><p>保护现场和传递参数；</p>
</li>
<li><p>执行相应的中断（或自陷）处理程序；</p>
</li>
<li><p>恢复和退出。</p>
</li>
</ol>
<blockquote>
<p>在中断进入时由硬件保护了被中断程序的PC和PS，在中断处理中由软件保护各寄存器的值和其它状态信息。</p>
</blockquote>
<h4 id="分类-2"><a href="#分类-2" class="headerlink" title="分类"></a>分类</h4><ul>
<li><p><strong>硬件故障中断的处理</strong></p>
</li>
<li><p><strong>程序性中断事件的处理</strong></p>
</li>
<li><p><strong>外部中断事件的处理</strong></p>
</li>
<li><p><strong>外部设备中断的处理</strong></p>
</li>
<li><p><strong>自愿访管中断的处理</strong></p>
</li>
</ul>
<h3 id="程序状态字"><a href="#程序状态字" class="headerlink" title="程序状态字"></a>程序状态字</h3><p>在计算机系统中有一个寄存器（有的系统有几个寄存器）用来存放程序状态字，称为PS。</p>
<p>其中包括：</p>
<ol>
<li>指令计数器（PC Program counter,instruction counter)</li>
<li>程序现应执行哪条指令，当前指令执行的情况</li>
<li>机器处于何种状态（核态、用户态）</li>
<li>程序执行时应屏蔽哪些中断（处理机运行级）</li>
<li>寻址方式、编址、保护键</li>
<li>响应中断的内容</li>
</ol>
<h2 id="用户界面"><a href="#用户界面" class="headerlink" title="用户界面"></a>用户界面</h2><h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3><p><strong>作业：</strong>要求计算机系统按指定的步骤对原始数据进行处理，并得到计算结果的加工工作。</p>
<blockquote>
<p>在多道环境下，一个作业是一个单位，是一个用户的计算任务区别于其它用户的计算任务的一个计算单位。</p>
</blockquote>
<p><strong>作业步：</strong>对作业的加工工作中的一个步骤称为一个作业步。</p>
<p>在操作系统中，把编好源程序后上机调试的工作分成四个步骤，称为四个作业步：</p>
<ol>
<li>编辑（修改）</li>
<li>编译</li>
<li>连接</li>
<li>运行</li>
</ol>
<p><strong>作业步之间的关系：</strong></p>
<ul>
<li>每个作业步运行的结果产生下一作业步运行所需要的文件。</li>
<li>一个作业步能否正确执行，取决于前一作业步是否成功完成。</li>
</ul>
<h3 id="作业的状态"><a href="#作业的状态" class="headerlink" title="作业的状态"></a>作业的状态</h3><ol>
<li>进入状态：作业的信息从输入设备上预输入到输入井，此时称为作业处于进入状态。</li>
<li>后备状态：当作业的全部信息都已输入，且由操作系统将其存放在输入井中，此时称作业处于后备状态。系统将所有处于后备状态的作业组成后备作业队列，等待作业调度程序的调度。</li>
<li>运行状态：一个后备作业被作业调度程序选中，分配了必要的资源，调入内存运行，称作业处于运行状态。④</li>
<li>完成状态：当作业正常运行完毕或因发生错误非正常终止时，作业进入这完成状态。</li>
</ol>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p><strong>系统调用：</strong>就是用户在程序中调用操作系统所提供的一些子功能。是操作系统和用户的第二个接口。它是管理程序提供的服务界面，或更确切地说是操作系统中支持程序设计语言正常工作的支撑系统所提供的界面。</p>
<p>这是一种特殊的过程调用，这种调用通常是由特殊的机器指令实现的。除了提供对操作系统子程序的调用外，这个指令还将系统转入特权方式。因此系统调用程序被看成是一个低级的过程，只能由汇编语言直接访问。</p>
<p>系统调用是操作系统提供给编程人员的唯一接口。编程人员利用系统调用，动态请求和释放系统资源，调用系统中已有的系统功能来完成与计算机硬件部分相关的工作以及控制程序的执行速度等。</p>
<h4 id="系统调用与一般过程调用的区别"><a href="#系统调用与一般过程调用的区别" class="headerlink" title="系统调用与一般过程调用的区别"></a>系统调用与一般过程调用的区别</h4><ol>
<li>运行在不同的系统状态： 一般的过程调用，其调用程序和被调用程序都运行在相同的状态：核心态或用户态；而系统调用与一般调用的最大区别就在于：调用程序运行在用户态，而被调用程序则运行在核心态。</li>
<li>状态的转换：一般的过程调用不涉及系统状态的转换，但系统调用通常都是通过软中断机制先由用户态转换为核心态。</li>
<li>返回问题：一般的过程调用在被调用过程执行完后，将返回到调用过程继续执行。但系统调用结束后，系统将根据优先级进行调度。</li>
<li>嵌套调用：像一般过程一样，系统调用也允许嵌套调用，但每个系统对嵌套调用的深度都有一定的限制。</li>
</ol>
<h4 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h4><p><strong>系统调用</strong>是通过访管指令实现的。</p>
<p>​        在程序中，如果希望请求操作系统的服务（例如，打开一个文件，显示某个目录的内容等），就要执行一条访管指令（trap、int），系统处理这个中断，即为用户提供相应的服务（或者称响应用户的请求）。</p>
<blockquote>
<p>在汇编程序中是显式地使用访管中断命令，trap、INT。在高级语言中（C语言）是隐式使用访管指令。</p>
</blockquote>
<h2 id="并发处理"><a href="#并发处理" class="headerlink" title="并发处理"></a>并发处理</h2><h3 id="顺序执行"><a href="#顺序执行" class="headerlink" title="顺序执行"></a>顺序执行</h3><h4 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h4><p>一个程序由若干个程序段组成，而这些程序段的执行必须是顺序的，这种程序执行的方式就称为程序的顺序执行。</p>
<ol>
<li>数据：用来表示人们思维对象的抽象概念的物理表现；</li>
<li>信息：经过解释和处理以满足人们特定需要的数据；</li>
<li>操作：数据处理的规则；</li>
<li>计算：对某一有限数据的集合所施行的、目的在于解决某一问题的一组有限的操作的集合。</li>
</ol>
<h4 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h4><ol>
<li>顺序性：处理机严格按照程序所规定的顺序执行，即每个操作必须在下一个操作开始之前结束；</li>
<li>封闭性：程序一旦开始执行，其计算结果不受外界的影响，当程序的初始条件给定之后，其后的状态只能由程序本身确定，即只有本程序才能改变它；</li>
<li>可再现性：程序执行的结果与初始条件有关，而与执行时间无关。即只要程序的初始条件相同，它的执行结果是相同的，不论它在什么时间执行，也不管计算机的运行速度。</li>
</ol>
<h3 id="并发执行"><a href="#并发执行" class="headerlink" title="并发执行"></a>并发执行</h3><h4 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a>概念</h4><p>若干个程序段同时在系统中运行，这些程序的执行在时间上是重迭的，一个程序段的执行尚未结束，另一个程序段的执行已经开始，即使这种重迭是很小的，也称这几个程序段是并发执行的。</p>
<h4 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h4><ul>
<li>失去了程序的封闭性和结果的可再现性<ul>
<li>如果程序执行的结果是一个与时间无关的函数，即具有封闭性。</li>
<li>若一个程序的执行可改变另一个程序的变量，象二个并发程序完成誊抄的例子，程序执行的结果不仅依赖于程序的初始条件，还依赖于程序执行时的相对速度，在这种情况下就失去了程序的封闭性。</li>
</ul>
</li>
<li>程序与计算不再一一对应<ul>
<li>在程序顺序执行时，一个程序总是对应一个具体的计算，但在程序的并发执行时，可能有多用户共享使用同一个程序，但处理（计算）的对象却是不同的，例如，在多用户环境下，可能同时有多个用户调用C语言的编译程序，每一个调用被称之为一个计算，这就是典型的一个程序对应多个计算的情况。</li>
</ul>
</li>
<li>程序执行的间断性<ul>
<li>程序在并发执行时，由于它们共享资源或为完成同一项任务而相互合作，致使在并发程序之间形成了相互制约的关系。这种相互制约将导致并发程序具有“执行—暂停执行—执行”这种间断性的活动规律。</li>
</ul>
</li>
<li>资源共享<ul>
<li>程序的并发执行与资源共享之间互为条件：一方面，资源共享是以程序并发执行为条件的；另一方面，资源共享的有效管理必将影响程序的并发执行程度。</li>
</ul>
</li>
</ul>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><h4 id="概念-6"><a href="#概念-6" class="headerlink" title="概念"></a>概念</h4><p>即是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。</p>
<h4 id="特征-1"><a href="#特征-1" class="headerlink" title="特征"></a>特征</h4><ul>
<li>并发性<ul>
<li>任何进程都可以同其他进程一起向前推进</li>
</ul>
</li>
<li>动态性<ul>
<li>进程对应程序的执行</li>
<li>进程是动态产生，动态消亡的</li>
<li>进程在其生命周期内，在三种基本状态之间转换</li>
</ul>
</li>
<li>独立性<ul>
<li>进程是CPU调度的一个独立单位</li>
</ul>
</li>
<li>交互性<ul>
<li>指进程在执行过程中可能与其它进程产生直接或间接的关系</li>
</ul>
</li>
<li>异步<ul>
<li>每个进程都与其相对独立的不可预知的速度向前推进</li>
</ul>
</li>
<li>结构性<ul>
<li>进程的组成：程序+数据+PCB</li>
</ul>
</li>
</ul>
<h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4><p><strong>进程在系统中的活动规律是：</strong><br>      执行——&gt;暂停——&gt;执行</p>
<p><strong>进程的三种基本状态：</strong></p>
<ul>
<li>运行状态<ul>
<li>当进程由调度/分派程序分派后，得到CPU控制权，它的程序正在运行，该进程所处的状态为运行状态。（在单CPU系统中，总只有一个进程处于此状态）</li>
</ul>
</li>
<li>就绪状态<ul>
<li>存在于处理机调度队列中的那些进程，它们已经准备就绪，一旦得到CPU，就立即可以运行，这些进程所取的状态为就绪状态。（有多个进程处于此状态）</li>
</ul>
</li>
<li>等待状态（又称阻塞、挂起、睡眠）<ul>
<li>若一个进程正在等待某个事件的发生（如等待I/O的完成），而暂停执行，这时，即使给它CPU时间，它也无法执行，则称该进程处于等待状态。</li>
</ul>
</li>
</ul>
<p><strong>其他状态：</strong></p>
<ol>
<li>终止状态</li>
<li>挂起状态<ul>
<li>引入挂起状态可能是基于下述需要：调节负载，对换，父进程，操作系统，终端用户</li>
</ul>
</li>
<li>创建( 新new)状态<ul>
<li>OS 已完成为创建一进程所必要的工作<ul>
<li>已构造了进程标识符</li>
<li>已创建了管理进程所需的表格</li>
</ul>
</li>
<li>但还没有允许执行该进程 (尚未同意)<ul>
<li>因为资源有限</li>
</ul>
</li>
</ul>
</li>
<li>终止（退出exit)状态<ul>
<li>中止后进程移入该状态</li>
<li>它不再有执行资格</li>
<li>表格和其它信息暂时由辅助程序保留<br>例子: 为处理用户帐单而累计资源使用情况的财务程序</li>
</ul>
</li>
<li>当数据不再需要后，进程(和它的表格)被删除</li>
</ol>
<p><strong>状态变迁：</strong></p>
<p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220104225724.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220104225724.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220104225715424"></p>
<p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220104225732.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220104225732.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220104225731547"></p>
<h3 id="进程的三种基本状态"><a href="#进程的三种基本状态" class="headerlink" title="进程的三种基本状态"></a>进程的三种基本状态</h3><p>(1) 就绪(Ready)状态</p>
<p>(2) 执行(Running)状态</p>
<p>(3) 阻塞(Block)状态。</p>
<p>进程的五种基本状态和转换<br><img src="https://img-blog.csdnimg.cn/20210705162019277.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk2OTE0Mg==,size_16,color_FFFFFF,t_70#pic_center" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/20210705162019277.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk2OTE0Mg==,size_16,color_FFFFFF,t_70#pic_center" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述" style="zoom:67%;" /></p>
<p>具有创建、终止和挂起状态的进程状态图<br><img src="https://img-blog.csdnimg.cn/20210705162032117.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk2OTE0Mg==,size_16,color_FFFFFF,t_70#pic_center" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/20210705162032117.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTk2OTE0Mg==,size_16,color_FFFFFF,t_70#pic_center" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="zoom:67%;" /></p>
<h4 id="进程和程序的区别"><a href="#进程和程序的区别" class="headerlink" title="进程和程序的区别"></a>进程和程序的区别</h4><p><strong>进程实体的组成</strong></p>
<ol>
<li><p>程序：表示该进程所要进行的操作；</p>
</li>
<li><p>数据集合：程序加工的对象和场所、它包括操作的数据和程序自己的变量单元。</p>
</li>
<li><p>进程控制块PCB：用于刻画一个进程在各个不同时期所处的状态的数据块。</p>
</li>
</ol>
<blockquote>
<p>进程＝程序＋数据＋PCB</p>
</blockquote>
<h4 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h4><p><strong>进程控制块</strong> PCB (Process Control Block)</p>
<ul>
<li>存放进程的管理和控制信息的数据结构称为进程控制块。它是进程管理和控制的最重要的数据结构，在创建时，建立PCB，并伴随进程运行的全过程，直到进程撤消而撤消。PCB就象我们的户口。</li>
</ul>
<p>作用：用以标识一个进程的存在。是标识进程的唯一实体。</p>
<img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220104230115.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220104230115.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220104230105691" style="zoom:67%;" />

<p><strong>作用：</strong></p>
<ol>
<li>PCB是进程组成中最关键部分。</li>
<li>每个进程有惟一的进程控制块；</li>
<li>操作系统根据PCB对进程实施管理和控制</li>
<li>进程的动态、并发等特征是利用PCB表现出来的；</li>
<li>PCB是进程存在的惟一标志</li>
</ol>
<h4 id="原语"><a href="#原语" class="headerlink" title="原语"></a>原语</h4><ol>
<li>进程创建：fork</li>
<li>进程撤消：exit</li>
<li>进程阻塞：sleep</li>
<li>进程唤醒：wakeup</li>
</ol>
<h4 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h4><p>​        在操作系统中，当某一进程正在访问某临界区时，就不允许其它进程进入，否则就会发生无法估计的错误。我们把进程之间的这种相互制约的关系称为<strong>互斥</strong>。    </p>
<p><strong>引入互斥的目的：</strong>使并发程序正确执行，不发生与时间有关的错误。</p>
<p><strong>临界资源：</strong>一次仅允许一个进程使用的资源称为临界资源。</p>
<p><strong>临界区：</strong>每个进程中访问临界资源的那段程序段称为临界区（临界段）。</p>
<p><strong>公共变量：</strong>允许多个进程访问的变量。</p>
<p><strong>进入临界区的准则：</strong></p>
<ol>
<li>每次至多有一个进程处于临界区；</li>
<li>当有若干个进程欲进入临界区时，应在有限的时间内使其进入；</li>
<li>进程在临界区内仅逗留有限的时间。</li>
</ol>
<h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><p><strong>同步</strong>就是并发进程在一些关键点上可能需要相互等待与互通消息，这样的相互制约关系称为进程同步。</p>
<p><strong>同步机制：</strong>实现同步的机制。常用的有信号灯机制和管程机制。</p>
<p><strong>同步规则：</strong>同步的各进程之间应遵循的规则。</p>
<ol>
<li>空闲让进；</li>
<li>忙则等待；</li>
<li>有限等待；</li>
<li>让权等待。</li>
</ol>
<p><strong>实现：</strong></p>
<ol>
<li><strong>诸进程合作完成某工作的逻辑顺序</strong>。如考证问题；</li>
<li><strong>对系统资源的共享</strong>。如两个进程共享一个缓冲区完成誊抄问题。</li>
</ol>
<h4 id="互斥与同步的区别："><a href="#互斥与同步的区别：" class="headerlink" title="互斥与同步的区别："></a>互斥与同步的区别：</h4><p><strong>互斥：</strong>仅是让两个进程不能同时访问某资源；<br><strong>同步：</strong>互斥且同步执行的各进程前后顺序有限制。</p>
<h4 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h4><ol>
<li><p>低级通信：只能传递状态和整数值（控制信息），包括进程互斥和同步所采用的信号量和管程机制。</p>
<ul>
<li><p>优点的速度快。</p>
</li>
<li><p>缺点是：</p>
<ul>
<li><p>传送信息量小：效率低，每次通信传递的信息量固定，若传递较多信息则需要进行多次通信。</p>
</li>
<li><p>编程复杂：用户直接实现通信的细节，编程复杂，易出错。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>高级通信：能够传送任意数量的数据，包括三类：</p>
<ul>
<li>直接通信：消息缓冲机制</li>
<li>间接通信：采用信箱为中介实现通信</li>
<li>管道通信</li>
</ul>
</li>
</ol>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h4 id="概念-7"><a href="#概念-7" class="headerlink" title="概念"></a>概念</h4><p>线程是比进程更小的活动单位，它是进程中的一个执行路径。一个进程可以有多个线程。</p>
<p><strong>线程的描述：</strong></p>
<ol>
<li>进程中的一条执行路径；</li>
<li>它有自己私用的堆栈和处理机执行环境（尤其是处理器寄存器）；</li>
<li>它与父进程共享分配给父进程的主存；</li>
<li>它是单个进程所创建的许多个同时存在的线程中的一个。</li>
</ol>
<h4 id="分类-3"><a href="#分类-3" class="headerlink" title="分类"></a>分类</h4><ol>
<li>用户级线程<ul>
<li>用户级线程仅存在于用户空间中。对于这种线程的创建、 撤消、线程之间的同步与通信等功能，都无须利用系统调用来实现。对于用户级线程的切换，通常是发生在一个应用进程的诸多线程之间，这时，也同样无须内核的支持。由于切换的规则远比进程调度和切换的规则简单，因而使线程的切换速度特别快。可见，这种线程是与内核无关的。</li>
<li>特点：<ul>
<li>内核不了解用户线程的存在；</li>
<li>用户线程切换不需要内核特权；</li>
<li>调度由应用软件内部进行，通常采用非抢先式和更简单的规则，也无需用户态/核心态切换，所以速度特别快。</li>
</ul>
</li>
</ul>
</li>
<li>内核支持线程 <ul>
<li>这里所谓的内核支持线程，也都同样是在内核的支持下运行的，即无论是用户进程中的线程，还是系统进程中的线程，他们的创建、撤消和切换等，也是依靠内核实现的。此外，在内核空间还为每一个内核支持线程设置了一个线程控制块， 内核是根据该控制块而感知某线程的存在的，并对其加以控制。 </li>
<li>特点：<ul>
<li>内核可以将同一进程中的多个线程调度到多个处理器上;</li>
<li>一个线程发起系统调用而阻塞，不会影响其它线程的运行，内核可以调度同一个进程中的另一个线程。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="资源分配与调度"><a href="#资源分配与调度" class="headerlink" title="资源分配与调度"></a>资源分配与调度</h2><h3 id="概念-8"><a href="#概念-8" class="headerlink" title="概念"></a>概念</h3><p><strong>资源：</strong>执行一个用户程序所需要的全部硬件设备、软件设施和数据。包括：</p>
<ul>
<li><p>硬件资源：CPU、内存、各种I/O设备、存储设备、时钟等；</p>
</li>
<li><p>软件资源：系统程序、服务性程序、用户程序、语言处理程序等。</p>
</li>
</ul>
<h3 id="资源分配的方法"><a href="#资源分配的方法" class="headerlink" title="资源分配的方法"></a>资源分配的方法</h3><ol>
<li>静态分配：在调用某作业时根据用户的需求分配资源，并在作业完毕后回收所有资源的方式；</li>
<li>动态分配：在某一进程运行过程中根据运行情况动态地分配、使用和释放其所需地资源地方式。</li>
</ol>
<h3 id="资源管理的目的"><a href="#资源管理的目的" class="headerlink" title="资源管理的目的"></a>资源管理的目的</h3><ol>
<li>保证资源的高利用率；</li>
<li>在“合理”时间内使所有顾客有获得所需资源的机会；</li>
<li>对不可共享的资源实施互斥使用；</li>
<li>防止由资源分配不当而引起的死锁。</li>
</ol>
<h3 id="资源管理数据结构"><a href="#资源管理数据结构" class="headerlink" title="资源管理数据结构"></a>资源管理数据结构</h3><p>描述资源的管理和控制信息的<strong>数据结构</strong>称为<strong>资源分配的机构</strong> 。包括：资源描述器和 资源信息块</p>
<h4 id="资源描述器（rd）"><a href="#资源描述器（rd）" class="headerlink" title="资源描述器（rd）"></a><strong>资源描述器（rd）</strong></h4><p>描述各类资源的最小分配单位的数据结构</p>
<p>资源描述器中存放的信息取决于资源的特性与对该资源的管理方式。最简单的资源描述器可以用一个二进制位来实现，它表示该资源是可用的，还是已分配的。</p>
<p>对于各类资源来说，若它具有若干个（n个）资源分配单元，则描述该类资源的数据结构就是由n个描述器组织而成。</p>
<h4 id="资源信息块（rib）"><a href="#资源信息块（rib）" class="headerlink" title="资源信息块（rib）"></a><strong>资源信息块（rib）</strong></h4><p>用来说明资源、请求者以及实施分配所需信息。以实现对资源的有效分配。</p>
<p>对于每一类资源，存在两个队列：</p>
<ol>
<li><p>可利用资源队列</p>
</li>
<li><p>该类资源的等待队列</p>
</li>
</ol>
<p>在资源信息块中，分别由两个指针指向这两个队列。</p>
<p>另外还有一类为该类资源的分配程序入口地址。</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h4 id="概念-9"><a href="#概念-9" class="headerlink" title="概念"></a>概念</h4><ol>
<li><p>死锁就是两个或两个以上的进程等候着一个永远不会发生的事件时所处的一种系统状态。</p>
</li>
<li><p>两个或两个以上并发进程，如果每个进程持有某种资源，而又等待着别的进程释放它或它们现在保持着的资源，否则就不能向前推进。此时，每个进程都占用了一定的资源，但又都不能向前推进。这种现象称为死锁。</p>
</li>
</ol>
<h4 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h4><ol>
<li><p>竞争资源</p>
<ul>
<li><p>在这两个进程并发执行时，当PA进程占有R1、PB进程占用R2时；</p>
</li>
<li><p>PA要求R2，由于PB已占有R2而得不到，PA进程只有等待；</p>
</li>
<li><p>PB申请R1，由于PA已占有R1，而得不到，PB进程只有等待；</p>
</li>
<li><p>从而出现了死等的情况。</p>
</li>
</ul>
</li>
<li><p>PV操作不当</p>
</li>
<li><p>资源分配不当</p>
<ul>
<li>资源总数小于进程所要求的总数。则有可能死锁</li>
</ul>
</li>
</ol>
<ol start="4">
<li>临时性资源分配不当<ul>
<li>若P1等待P3的信件S3来到后再向进程P2发信件S1；</li>
<li>若P2等待P1的信件S1来到后再向进程P3发信件S2；</li>
<li>若P3等待P2的信件S2来到后再向进程P2发信件S3；</li>
</ul>
</li>
</ol>
<h4 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h4><ol>
<li>互斥条件</li>
<li>不可剥夺条件</li>
<li>部分分配</li>
<li>环路条件</li>
</ol>
<h4 id="破坏死锁的策略"><a href="#破坏死锁的策略" class="headerlink" title="破坏死锁的策略"></a>破坏死锁的策略</h4><ol>
<li>死锁预防：预先设置一些条件限制去破坏四个必要条件之一 ，从而预防死锁。<ul>
<li>缺点：系统资源利用率、吞吐率降低。</li>
</ul>
</li>
<li>死锁避免：不预先采取条件限制，只是在 动态分配前提下，防止进入不安全状态，从而避免死锁。<ul>
<li>适当提高资源利用率，吞吐率。</li>
</ul>
</li>
<li>死锁检测：允许死锁发生，再去检测发生死锁的进程和资源，然后去消除死锁；</li>
<li>死锁解除：取消或挂起相应发生死锁的进程，回收该进程资源，再分配给阻塞进程。<ul>
<li>发生死锁进程取消；</li>
<li>发生死锁进程部分取消；</li>
<li>重启动。</li>
</ul>
</li>
</ol>
<h4 id="死锁的预防"><a href="#死锁的预防" class="headerlink" title="死锁的预防"></a>死锁的预防</h4><ol>
<li><p>预先静态分配法(破坏部分分配条件)</p>
<ul>
<li>策略：作业调度时，仅当系统满足作业运行时所需的全部资源时，才把该作业调入内存运行。在作业运行前一次性将其所需的全部资源分配给它，于是在作业运行过程中不再会提出新的资源请求。</li>
<li>缺点：<ul>
<li>降低了对资源的利用率，降低进程的并发程度；</li>
<li>有可能无法预先知道所需资源；</li>
<li>延长了作业的等待时间    </li>
</ul>
</li>
</ul>
</li>
<li><p>有序资源使用法: (破坏循环等待条件)</p>
<ul>
<li>策略：把系统中的全部资源分别分给一个特定的序号，并且要求每个进程均应严格地按照序号递增的次序请求资源。       </li>
<li>优点：基于动态分配方法，资源利用率较前法    </li>
<li>缺点：                        <ul>
<li>限制进程对资源的请求；</li>
<li>资源的排序占用系统开销；         </li>
<li>资源序号尽可能反映多数作业的实际使用资源的顺序，但总有不合适的作业而造成资源浪费。</li>
</ul>
</li>
</ul>
</li>
<li><p>“可剥夺”资源使用法: (破坏“不可剥夺”条件)</p>
<ul>
<li>策略：在允许进程动态申请资源前提下规定，一个进程在申请新的资源不能立即得到满足而变为等待状态之前，必须释放已占有的全部资源，若需要再重新申请； </li>
<li>缺点：                        <ul>
<li>一个资源在使用一段时间后被释放，可能会造成前阶段工作的失效；</li>
<li>可能会导致某进程重复多次申请和释放资源，从而延长了进程周转时间,并增加了系统开销,降低了系统吞吐量；</li>
<li>只适用主存和处理器的分配,而不能对所有资源都适用。</li>
</ul>
</li>
</ul>
</li>
<li><p>破坏“互斥”条件:</p>
<ul>
<li>就是在系统里取消互斥。若资源不被一个进程独占使用，那么死锁是肯定不会发生的。但一般来说在所列的四个条件中，“互斥”条件是无法破坏的。因此，在死锁预防里主要是破坏其他几个必要条件，而不去涉及破坏“互斥”条件。</li>
</ul>
<blockquote>
<p>注意：互斥条件不能被破坏，否则会造成结果的不可再现性。</p>
</blockquote>
</li>
</ol>
<h2 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h2><h3 id="两级调度"><a href="#两级调度" class="headerlink" title="两级调度"></a>两级调度</h3><ol>
<li>宏观上：作业调度—使该作业对应的进程（进入就绪态），具有使用CPU的权利。<ul>
<li>任务：将外存上的作业有选择地调入内存，建立作业对应的进程，使其投入运行。</li>
</ul>
</li>
<li>微观上：进程调度—从各就绪进程中选中一个，使其占有CPU开始执行。<ul>
<li>任务：在进入内存的所有进程中，确定哪个进程何时占有CPU ，使用多长时间。</li>
</ul>
</li>
</ol>
<h3 id="三级调度"><a href="#三级调度" class="headerlink" title="三级调度"></a>三级调度</h3><p>在某些多道程序系统中，处理机的调度分为三级：</p>
<ol>
<li>高级调度（作业调度、宏观调度）<ol>
<li>按一定原则对外存输入井上的作业进行调度，并建立进程PCB。它决定允许哪些作业竞争系统资源。由于这种调度决定哪些作业可以进入系统，所以也称收容调度。作业一旦被系统收容，就便成进程或进程组。 </li>
</ol>
</li>
<li>中级调度（交换调度）<ol>
<li>它决定允许哪些进程竞争处理机。中级调度通过使进程临时挂起和激活的方法对系统负载波动作出反映，以便获得平稳的系统操作和实现较好的系统综合性能目标，中级调度的作用使作为作业进入系统和将中央处理机分配给这些作业二者之间的一个缓冲。</li>
</ol>
</li>
<li>低级调度（进程调度）<ol>
<li>它决定了存在就绪进程时，哪一个就绪进程将分配到中央处理机，并且把中央处理机实际分配给这个进程（即低级调度是将处理机分配给进程）。低级调度是由每秒可操作许多次的处理机调度程序执行，处理机调度程序应常驻内存。</li>
</ol>
</li>
</ol>
<h3 id="JCB"><a href="#JCB" class="headerlink" title="JCB"></a>JCB</h3><p>为了管理和调度作业，系统为每个作业设置了一个**作业控制块(JCB)**，它记录该作业的有关信息</p>
<p>JCB是作业在系统中存在的标志。</p>
<p>当作业进入系统时，为该作业建立一个JCB；当作业运行结束退出系统时，则它的JCB也一起被撤消。</p>
<img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220104235510.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220104235510.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220104235459845" style="zoom:67%;" />

<h3 id="作业调度"><a href="#作业调度" class="headerlink" title="作业调度"></a>作业调度</h3><p><strong>作业调度的主要任务:</strong> 完成作业从后备状态到执行状态和从执行状态到完成状态的转变。</p>
<h4 id="作业调度功能："><a href="#作业调度功能：" class="headerlink" title="作业调度功能："></a><strong>作业调度功能：</strong></h4><ol>
<li>确定数据结构（建立JCB，Job Control Block）；</li>
<li>确定调度算法，按该算法，从后备作业中选择一个或几个作业进入系统内存；</li>
<li>为被选中的作业创建进程，并且为其申请系统资源；</li>
<li>作业结束后作善后处理工作。</li>
</ol>
<h4 id="作业调度目标："><a href="#作业调度目标：" class="headerlink" title="作业调度目标："></a><strong>作业调度目标：</strong></h4><ol>
<li>对所有作业应该是公平合理</li>
<li>应使设备有高的利用率</li>
<li>每天执行尽可能多的作业</li>
<li>有快的响应时间</li>
</ol>
<h4 id="调度性能的衡量："><a href="#调度性能的衡量：" class="headerlink" title="调度性能的衡量："></a><strong>调度性能的衡量：</strong></h4><ul>
<li>通常采用平均周转时间和带权平均周转时间</li>
<li>作业的周转时间：<ul>
<li>ti = tci-tsi</li>
<li>ti:作业周转时间</li>
<li>tci：作业完成时间</li>
<li>tsi:  作业提交时间</li>
</ul>
</li>
</ul>
<img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220104235655.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220104235655.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220104235647813" style="zoom: 50%;" />

<h4 id="作业调度算法"><a href="#作业调度算法" class="headerlink" title="作业调度算法"></a><strong>作业调度算法</strong></h4><ol>
<li>先来先服务调度算法（FCFS）<ul>
<li>先来先服务算法是按作业来到的先后次序进行调度的，换句话说，调度程序每次选择的作业是等待时间最久的，而不管作业的运行时间的长短。</li>
<li>优点: 实现简单;     缺点:效率较低</li>
<li>在一些实际的系统和一般应用程序中采用这种算法的较多。</li>
</ul>
</li>
<li>短作业优先调度算法（SJF）<ul>
<li>短作业优先调度算法考虑作业的运行时间，每次总是选择一个运行时间最小的作业调入内存（系统）。</li>
<li>优点:易实现,效率较高；</li>
<li>缺点:只照顾短作业,而未考虑长作业。</li>
<li><strong>该调度算法有最短的作业平均周转时间。</strong></li>
</ul>
</li>
<li>响应比高者优先调度算法（HRRN）<ul>
<li>这样算法从理论上讲是比较完备的，既照顾了短作业，又兼顾到了长作业；</li>
<li>但作业调度程序要统计作业的等待时间，使用用户的估计的运行时间，并要作浮点运算（这是系统程序最忌讳的）浪费大量的计算时间，这是系统程序所不允许的。</li>
</ul>
</li>
<li>优先数调度算法<ul>
<li>优先数调度算法是终合考虑各方面的因素（作业等待时间、运行时间、缓急程度，系统资源使用等），给每个作业设置一个优先数，调度程序总是选择一个优先数最大（或者最小）的作业调入（系统）内存。这种算法实现的困难在于如何终合考虑，这些因素之间的关系怎样处理。</li>
<li>确定优先数的考虑因素：<br>1、作业要求运行的急切程度；<br>2、作业运行时间的长短；<br>3、对资源要求的多寡。</li>
</ul>
</li>
<li>均衡调度算法<ul>
<li>按作业本身的特性分类，作业调度程序轮流从这些不同类的作业中挑选作业运行。</li>
<li>作业的分类方法之一：<br>（1）“短”作业：其特点是计算时间小于一定值，且无特殊的外设要求；<br>（2）“要用到磁带的作业”：要使用“一条或几条私用磁带<br>（3）“长”作业：作业所需的计算时间很长。</li>
<li>一般，系统总是从每一类中挑选一个作业出来，使其投入运行，以保持机器中的各部件均处于忙碌状态</li>
<li>分类方法之二：（按其输入输出的繁忙程度）<br>1）A类：输入输出繁忙的作业：<br>2）B类：输入输出与CPU均衡的作业；<br>3）C类：CPU繁忙的作业：</li>
<li>处理方法：系统总是力图保持运行作业中的A类与C类作业的数目相当，以使系统资源得到较均衡的使用。</li>
<li>均衡调度算法的缺陷<ul>
<li>均衡调度算法就是一种更为理想化的调度算法，如何实现就更困难，并且算法本身的开销有时会远选大于先来先服务和小作业优先调度算法的不足，这也是这种算法很难被采用的最根本的原因。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="进程调度准则"><a href="#进程调度准则" class="headerlink" title="进程调度准则"></a>进程调度准则</h4><ol>
<li>CPU使用率——需要使CPU尽可能忙。其负荷应达到40%~90%；</li>
<li>吞吐量——使其单位时间内完成的进程数量尽可能多</li>
<li>周转时间——尽可能短（用于批处理系统）；</li>
<li>响应时间——尽可能短（用于交互式系统）；</li>
<li>等待时间——尽可能短（用于交互式系统）；</li>
</ol>
<h4 id="调度方式"><a href="#调度方式" class="headerlink" title="调度方式"></a>调度方式</h4><p><strong>调度方式：</strong>当一个进程正在处理机上执行时，若有某个更为“重要而紧迫”的进程需要进行处理时，亦即，若有优先级更高的进程进入就绪队列中时，如何分配处理机。</p>
<p><strong>进程调度方式的分类：</strong><br> 1、非剥夺方式</p>
<ul>
<li>分派程序一旦把处理机分配给某进程后便让它一直运行下去，直到进程完成或发生某事件而阻塞时，才把处理机分配给另一个进程。</li>
<li>优点：简单，系统开销小；</li>
<li>缺点：可能会使得紧急任务不能立即投入运行，以致延误时机。</li>
</ul>
<p> 2、剥夺方式</p>
<ul>
<li>当一个进程正在运行时，系统可以基于某种原则，剥夺已分配给它的处理机，将之分配给其它进程。</li>
<li>剥夺原则有：<ul>
<li>优先权原则：优先权较高的进程可剥夺优先权低的进程而运行；</li>
<li>短进程优先原则：短进程到达后可以剥夺长进程的运行；</li>
<li>时间片原则：一个时间片用完后重新调度。</li>
</ul>
</li>
<li>除了以上两种调度方式外，Shaw还提出一个选择可抢占策略，该策略是两种极端的抢占和不可抢占策略之间的折衷方案，该方案下，每个进程不仅被指派一个优先数，而且还有一对标志（ U、V ）<ul>
<li>U=1表示该进程可以抢占另一进程；</li>
<li>U=0表示该进程不可抢占另一进程；</li>
<li>V=1表示该进程可以被另一进程抢占；</li>
<li>V=0表示该进程不可被另一进程抢占。</li>
</ul>
</li>
</ul>
<h4 id="分配方式"><a href="#分配方式" class="headerlink" title="分配方式"></a>分配方式</h4><ol>
<li><p>静态优先数法：在进程创建时指定优先数，在进程运行时优先数不变</p>
<ul>
<li>确定进程优先数：<ul>
<li>系统确定：（运行时间、使用资源，进程的类型）</li>
<li>用户确定：（紧迫程度，计费与进程优先数有关）</li>
<li>系统与用户结合（用户可以为本用户的进程设置优先数，但不是作调度用，系统还要根据系统情况把用户设置的进程优先数作为确定进程优先数的一个参数）</li>
</ul>
</li>
</ul>
</li>
<li><p>动态进程优先数</p>
<ul>
<li>系统在运行的过程中，根据系统的设计目标，不断地调整进程的优先数，这种方法的优点是能比较客观地反映进程的实际情况和保证达到系统设计目标。如：<ul>
<li>在就绪队列中，等待时间延长则优先级提高，从而使优先级较低的进程在等待足够的时间后，其优先级提高到可被调度执行；</li>
<li>进程每执行一个时间片，就降低其优先级，从而一个进程持续执行时，其优先级降低到出让CPU。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="主存管理"><a href="#主存管理" class="headerlink" title="主存管理"></a>主存管理</h2><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ol>
<li>映射逻辑地址到物理主存地址：将程序地址空间中使用的逻辑地址变换成主存中的地址。</li>
<li>在多用户之间分配物理主存：按照一定的算法把某一空闲的主存区分配给作业或进程。</li>
<li>对操作系统以及各用户的信息提供保护措施：保证用户程序(或进程映象)在各自的存储区域内操作，互不干扰。</li>
<li>扩充逻辑主存区：提供虚拟存储技术，使用户程序的大小和结构不受主存容量和结构的限制，即使在用户程序比实际主存容量还要大的情况下，程序也能正确运行。</li>
</ol>
<h3 id="虚存条件"><a href="#虚存条件" class="headerlink" title="虚存条件"></a>虚存条件</h3><ol>
<li>需要有相当容量的辅存；</li>
<li>要有一定容量的主存；</li>
<li>地址变换机构。引进虚存后必须在地址变换上花费开销，所以，在设计虚拟存储器时，应力求地址变换能快速进行。</li>
</ol>
<h3 id="动态地址映射"><a href="#动态地址映射" class="headerlink" title="动态地址映射"></a>动态地址映射</h3><p>动态运行时的装入程序，在把装入模块装入内存时，并不立即把装入模块中的相对地址转换为绝对地址，而是把这种地址转换，推迟到程序真正要执行时才进行。因此， 装入内存后的所有地址都仍是相对地址。 </p>
<p>系统中设置了重定位寄存器。</p>
<p><strong>动态地址映射技术能满足以下目标：</strong></p>
<ol>
<li>具有给一个用户程序任意分配内存区的能力；</li>
<li>可实现虚拟存储；</li>
<li>具有重新分配的能力；</li>
<li>对于一个用户程序，可以分配到多个不同的存储区。</li>
</ol>
<p><strong>优点：</strong></p>
<ol>
<li><p>OS可以将一个程序分散存放于不连续的内存空间，装入后程序可以移动；</p>
</li>
<li><p>较容易实现几个进程对同一程序副本的共享使用</p>
</li>
<li><p>能够支持程序执行中产生的地址引用，如指针变量（而不仅是生成可执行文件时的地址引用）；</p>
</li>
<li><p>能提供虚存功能</p>
</li>
</ol>
<p><strong>缺点：</strong>需要硬件支持（通常是CPU），OS实现较复杂。它是虚拟存储的基础。</p>
<h3 id="碎片"><a href="#碎片" class="headerlink" title="碎片"></a>碎片</h3><p><strong>碎片：</strong>在已分配区之间存在着的一些没有被充分利用的空闲区。</p>
<p><strong>碎片的危害：</strong>在按区分配方法中，根据申请按区分配主存，会把主存越分越零碎。在整个系统运行一段时间后，甚至会出现这样的局面：分布在主存各处的破碎空闲区占据了相当数量的空间，当一个作业申请一定数量的主存时，虽然此时空闲区的总和大于新作业所要的主存容量，但却没有单个的空闲区大到足够装下这个作业。</p>
<p><strong>紧凑（拼接技术）：</strong>移动存储器中某些已分配区中的信息，使本来分散的空闲区连成一个大的空闲区。</p>
<p><strong>拼接时机的选择：</strong></p>
<ol>
<li>某个分区回收时立即进行；<ul>
<li>缺点：拼接频率过高，系统开销加大。</li>
</ul>
</li>
<li>当找不到足够大的空白区，而空白区的存储容量总和却可以满足作业需要时进行。<ul>
<li>优点：拼接频率较小，系统开销较小；</li>
<li>缺点：空白区管理较复杂。</li>
</ul>
</li>
</ol>
<p><strong>拼接技术的缺点：</strong></p>
<ol>
<li>消耗系统资源；</li>
<li>拼接时必须停止所有其他的工作；</li>
<li>拼接需要重新定义已存入主存的作业。</li>
</ol>
<h3 id="基本的放置策略"><a href="#基本的放置策略" class="headerlink" title="基本的放置策略"></a>基本的放置策略</h3><h4 id="空闲区表的组织方法"><a href="#空闲区表的组织方法" class="headerlink" title="空闲区表的组织方法"></a>空闲区表的组织方法</h4><ol>
<li><p>按空闲区大小的升序（降序）组织；</p>
</li>
<li><p>按空闲区首址升序（降序）组织。</p>
</li>
</ol>
<h4 id="放置策略"><a href="#放置策略" class="headerlink" title="放置策略"></a>放置策略</h4><ol>
<li>最佳适应算法<ul>
<li>最佳适应算法是将申请者放入与其大小最接近的空闲区中。切割后的空闲区最小，若系统中有与申请区大小相等的空闲区，这种算法肯定能将这种空闲区分配给申请者。</li>
<li>最佳适应算法的空闲区表按空闲区大小升序方法组织。分配时，按申请的大小逐个与空闲区大小进行比较，找到一个满足要求的空闲区，就说明它是最适合的（即最佳的）。</li>
<li>优点：<br>（1）如果存储空间中具有正好是所要求大小的空白区，则它必然被选中；<br>（2）如果不存在这样的空白区，也只是对比要求稍大的空白区进行划分，而绝不会去划分更大的空白区。从而，在遇到有大的存储要求时，就比较容易得到满足。</li>
<li>缺点：<br>（1）产生的空白区太小，不能使用；<br>（2）回收分区时，将其插入到空白链中合适位置较费时。</li>
</ul>
</li>
<li>首次适应算法<ul>
<li>首次适应算法的表是按空闲区首址升序的（即空闲区表是按空闲区首址从小到大）方法组织的。     </li>
<li>分配时从表首开始，以请求内存区的大小逐个与空闲区进行比较，找到第一个满足要求的空闲后，若空闲区大小与请求区的大小相等，则将该空闲区分配给请求者，并撤消该空闲区所在表目；若大于请求区，就将该空闲区的一部分分配给请求者，然后，修改空闲区的大小和首址。</li>
<li><strong>首次适应算法的实质</strong>是尽可能地利用低地址部分的空闲区，而尽量地保证高地址部分的大空闲区，使其不被切削成小的区，其目的是保证在有大的作业的到来有足够大的空闲区来满足请求者。</li>
<li>回收时，首先考察释放区是否与系统中的某个空闲区相邻，若相邻则合并成一个空闲区，否则，将释放区作为一个空闲区按首址升序的规则插入到空闲区表适当的位置。</li>
<li>优点：<br>① 算法简单，查找速度快；<br>② 高址部分空白区被划分的机会少，故大作业较易得到满足。</li>
<li>缺点：<br>① 易造成很多“内存碎片”；<br>② 查找较大的空白区通常在链的尾端才能发现，故查找速度降低。</li>
</ul>
</li>
<li>最坏适应算法<ul>
<li>为了克服最佳适应算法把空闲区切割得大小的缺点，人们提出了一种最坏适应算法，即每次分配时，总是将最大的空闲区切去一部分分配给请求者，其依据是当一个很大的空闲区被切割了一部分后可能仍是一个较大的空闲区。避免了空闲区越分越小的问题。</li>
<li>最坏适应算法的空闲区表是按空闲区大小降序的方法组织的（从大到小的顺序）。分配时总是取表中的第一个表目，若不能满足申请者的要求，则表示系统中无满足要求的空闲区，分配失败；否则，将从该空闲区中分配给申请者，然后修改空闲区的大小，并将它插入到空闲区表的适当位置。</li>
<li>优点：<ul>
<li>使剩下的空闲区不至于太小，有可能仍能分配，对中小作业有利；</li>
</ul>
</li>
<li>缺点：<ul>
<li>会导致大作业的请求往往不能得到满足</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="请调策略"><a href="#请调策略" class="headerlink" title="请调策略"></a>请调策略</h3><ul>
<li>预调<ul>
<li>系统根据作业（进程）运行的情况，预测哪些页将要运行，在其运行之前先行调入内存，这样在程序运行的过程中就不会出现缺页中断。这样方法从表面上看起来很好，但系统无法预计系统中作业的运行情况，难以实现。</li>
</ul>
</li>
<li>请调<ul>
<li>进程在执行的过程中，发现要执行的程序或处理的数据不在内存，向系统提出调入相应程序的请求，系统响应用户的请求。</li>
</ul>
</li>
</ul>
<h3 id="置换策略"><a href="#置换策略" class="headerlink" title="置换策略"></a>置换策略</h3><h4 id="OPT（最佳算法）"><a href="#OPT（最佳算法）" class="headerlink" title="OPT（最佳算法）"></a>OPT（最佳算法）</h4><ul>
<li>缺页中断率f’ = f/a， 则最佳算法是f’最小的调度算法</li>
<li>当要调入一新页而必须淘汰一旧页时，所淘汰的页是以后不再使用的，或者是以后相当长的时间内不会使用的。这种算法是不可能的。</li>
<li>存在问题：由于无法预知哪个页面是未来最长时间内不被访问的，所以该算法只是一种理论上的算法.</li>
</ul>
<h4 id="FIFO（先进先出算法）"><a href="#FIFO（先进先出算法）" class="headerlink" title="FIFO（先进先出算法）"></a>FIFO（先进先出算法）</h4><ul>
<li>先进入内存的页，先退出内存。</li>
<li>实质上是淘汰在内存驻留时间最长的页。</li>
<li>其理由是：最早调入内存的页，不再被使用的可能性比近期调入内存的大。</li>
<li>这种算法简单，实现容易。</li>
</ul>
<h4 id="LRU（最久未使用淘汰算法）"><a href="#LRU（最久未使用淘汰算法）" class="headerlink" title="LRU（最久未使用淘汰算法）"></a>LRU（最久未使用淘汰算法）</h4><ul>
<li>这种算法的实质：当需要淘汰一页时，选择最长时间未使用的页。</li>
<li>依据的理论是如果某页被访问，它可能马上还要被访问；相反，如果某页长时间未被访问，它可能最近也不可能被访问。</li>
<li>缺点：<ul>
<li>在每次访问页面时都要修改有关信息，且需做连续修改，此工作由软件完成，代价太高；由硬件完成，大大增加成本。</li>
<li>故此,真正的LRU算法用得最少，得到推广的仅是一种LRU近似算法（也被称为Clock置换算法，后续会讲到）。</li>
</ul>
</li>
</ul>
<h4 id="LFU（最不经常使用淘汰算法）"><a href="#LFU（最不经常使用淘汰算法）" class="headerlink" title="LFU（最不经常使用淘汰算法）"></a>LFU（最不经常使用淘汰算法）</h4><ul>
<li>实质：把最近应用次数最少的页淘汰掉；</li>
<li>实现：为每一页设置一个计数器，初值为0。对每一页访问一次后，就将它相应计数器加1。过一定时间t后，将所有计数器一律清除。发生缺页中断时，选择计数器值最小的一页淘汰，同时将所有计数器清0。</li>
<li>优点：容易实现</li>
<li>缺点：代价较高</li>
</ul>
<h4 id="简单的Clock置换算法"><a href="#简单的Clock置换算法" class="headerlink" title="简单的Clock置换算法"></a>简单的Clock置换算法</h4><ul>
<li>这种算法，只要在存储分块表（或页表）中设一个“引用位”，当存储分块表中的某一页被访问时，该位由硬件自动置1，并由页面管理软件周期性把所有引用位置0。这样，在一个时间周期T内，某些被访问过的页面其引用位为1，而未被访问过的页面其引用位为0。</li>
<li>根据引用位的状态来判别各页面最近的使用情况。当需要置换一页面时，选择其引用位为0的页，如下图所示的算法。</li>
<li>缺点：<ul>
<li>使所有块的引用位重置0的周期T大小难以确定。若太大：可能使所有块的引用位均为1，不知谁是最近以来没访问过的。若太小：可能引用位为0的块相当多，也不利于选择。</li>
<li>若缺页刚好发生在系统对所有引用位重置0之后，则几乎所有块的引用位为0，同样不利于选择。</li>
</ul>
</li>
</ul>
<h3 id="分页，分段的区别"><a href="#分页，分段的区别" class="headerlink" title="分页，分段的区别"></a>分页，分段的区别</h3><ol>
<li>页是信息的物理单位，段是信息的逻辑单位；</li>
<li>页的大小是由系统固定的，段的长度因段而异，由用户决定；</li>
<li>分页的作业地址空间是一维的，分段的作业地址空间是二维的。</li>
</ol>
<h4 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h4><p>页表是页式存储管理的数据结构，它包括用户程序空间的页面与内存块的对应关系、页面的存储保护和存取控制方面的信息。</p>
<blockquote>
<p>页号    内存块号     存取控制    状态   其它<br>在实际的系统中，为了节省存储空间，在页表中可以省去页号这个表目。</p>
</blockquote>
<ul>
<li><p>页表的构成：</p>
<ul>
<li>由高速缓存组成：地址转换速度快，但成本高；</li>
<li>在主存固定区域开辟一些单元来存放。</li>
</ul>
</li>
<li><p>页表的使用：</p>
<ul>
<li>在主存分配时，建立页表；</li>
<li>在用户程序执行时，访问页表。</li>
</ul>
</li>
<li><p>页面尺寸的选择：</p>
<ul>
<li>若页面尺寸选得过大，以致和一般作业大小不相上下，则实际上就蜕化为按区分配法；</li>
<li>若页面尺寸太小，页表本身较大，浪费资源太多。</li>
</ul>
</li>
<li><p>虚地址以十进制数给出</p>
<ul>
<li>页号＝虚地址/页大小</li>
<li>位移量＝虚地址 mod 页大小</li>
<li>根据题意产生页表；</li>
<li>以页号查页表，得到对应页装入内存的块号</li>
<li>内存地址＝块号×页大小＋位移量</li>
</ul>
</li>
</ul>
<h2 id="输入-输出管理"><a href="#输入-输出管理" class="headerlink" title="输入/输出管理"></a>输入/输出管理</h2><h3 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h3><ul>
<li>状态跟踪<ul>
<li>设备控制块是存放设备管理和控制信息的数据结构。</li>
<li>系统要掌握设备的状态。</li>
</ul>
</li>
<li>设备存取<ul>
<li>实现对设备的存取操作。</li>
</ul>
</li>
<li>设备分配<ul>
<li>在多用户的环境下，负责设备的分配和回收。</li>
</ul>
</li>
<li>设备控制<ul>
<li>设备控制包括设备的驱动、完成和故障中断处理。</li>
</ul>
</li>
</ul>
<h3 id="分类-4"><a href="#分类-4" class="headerlink" title="分类"></a>分类</h3><ul>
<li>按传输速率分     <ul>
<li>低速设备：几～几十字节/秒          键盘</li>
<li>中速设备：几百～几千字节/秒      行式/激光打印机</li>
<li>高速设备：上万～上百万字节/秒   磁盘驱动器</li>
</ul>
</li>
<li>信息组织和处理方式<ul>
<li>块设备：信息按字符块组织和处理（面向块的设备：存储设备）</li>
<li>字符设备：信息按字符组织和处理（面向字符的设备：I/O设备）</li>
</ul>
</li>
<li>按从属关系分类<ul>
<li>系统设备：OS生成时已配置的各种标准设备</li>
<li>用户设备：用户自己提供，由系统管理，非标准</li>
</ul>
</li>
<li>按交互对象分类<ul>
<li>人机交互设备：视频显示器、键盘、鼠标、打印机</li>
<li>与计算机或其他电子设备交互的设备：磁盘、磁带、传感器、控制器</li>
<li>计算机间的通信设备：网卡、调制解调器</li>
</ul>
</li>
<li>按资源分配方式<ul>
<li>独占设备：在一段时间内只能有一个进程使用的设备，一般为低速I/O设备。（如打印机，磁带等）</li>
<li>共享设备：在一段时间内可有多个进程共同使用的设备，多个进程以交叉的方式来使用设备，其资源利用率高。（如硬盘）</li>
<li>虚拟设备：用软件技术把慢速独占设备变成共享设备。一般是通过借用大容量共享设备的一部分空间来充当缓冲而实现的。把这部分空间称为“虚拟设备”。 （Spooling 技术）</li>
</ul>
</li>
</ul>
<h3 id="设备独立性"><a href="#设备独立性" class="headerlink" title="设备独立性"></a>设备独立性</h3><h4 id="概念-10"><a href="#概念-10" class="headerlink" title="概念"></a>概念</h4><ul>
<li>设备独立性是指用户在编程序时所使用的设备与实际设备无关。</li>
<li>两类设备独立性：<ul>
<li>一个程序应独立于分配给它的某类设备的具体设备。即在用户程序中只指明I/O使用的设备类型即可。如在系统中配备了两台打印机，用户要打印时只要告诉系统要将信息送到打印机即可。</li>
<li>程序要尽可能地与它使用的设备类型无关。即在用户程序中只要指出要输入或输出信息，至于信息I/O使用的设备不需用户指明。</li>
</ul>
</li>
</ul>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><ul>
<li>逻辑设备和实际设备的联系通常是由操作系统命令语言（作业控制语言、键盘命令或用户程序中的语言级）中提供的信息实现的。</li>
<li>采用高级语言级则通过软通道实现。</li>
<li>计算机系统中配置有各种不同类型的独占设备，每一类独占设备又可以有好多台。为了对这些设备进行管理，计算机系统对每一台设备都要进行登记，且为每一台设备确定一个编号，以便区分和识别．这个确定的编号称为设备的绝对号。</li>
<li>在多道程序设计系统中，因为用户无法知道哪台设备正在被其他用户占用，哪台设备当前是空闲的，所以用户中请分配设备时不能使用设备的绝对号。</li>
<li>当用户要使用独占设备时，只需向系统说明所要使用的设备类型，至于实际应该使用哪一台，由系统根据该类设备的分配情况来决定。有时用户可能要求同时使用几台同类型设备，为了避免使用时的混乱，用户可以把自己要求使用的若干台同类设备给出编号。由用户对自己需要使用的若干台同类设备给出的编号称为设备的相对号。</li>
<li>用户总是用“设备类相对号”来提出使用设备的要求。系统在为用户分配具体设备时就建立“绝对号”与“设备类相对号”的对应关系。根据这个对应关系，系统就能知道对用户要求使用的设备实际上应启动哪台设备。 </li>
</ul>
<h3 id="缓冲技术"><a href="#缓冲技术" class="headerlink" title="缓冲技术"></a>缓冲技术</h3><h4 id="概念-11"><a href="#概念-11" class="headerlink" title="概念"></a>概念</h4><p>是用来在两种不同速度的设备之间传输信息时平滑传输过程的常用手段。</p>
<p>引入缓冲的原因：</p>
<ul>
<li>CPU与各种外部设备的速度上的差异很大，设备与设备之间的速度的差异也很大。</li>
<li>系统有时会产生大量的数据需要I/O，有时又会很长时间没有I/O。造成I/O负荷的不均匀。</li>
</ul>
<h4 id="目的-1"><a href="#目的-1" class="headerlink" title="目的"></a>目的</h4><ul>
<li>缓和CPU与I/O设备间速度不匹配的矛盾</li>
<li>提高它们之间的并行性</li>
<li>减少对CPU的中断次数，放宽CPU对中 断响应时间的要求</li>
</ul>
<h4 id="分类-5"><a href="#分类-5" class="headerlink" title="分类"></a>分类</h4><ul>
<li><p>缓冲区设置</p>
<ul>
<li><p>硬缓冲：在设备中设置缓冲区，由硬件实现；</p>
</li>
<li><p>软缓冲：在内存中开辟一个空间，用作缓冲区。</p>
</li>
</ul>
</li>
<li><p>缓冲区管理</p>
<ul>
<li>单缓冲</li>
<li>双缓冲</li>
<li>环形缓冲</li>
<li>缓冲池：多个缓冲区连接起来统一管理，常采用多缓冲管理</li>
</ul>
</li>
</ul>
<h4 id="静态分配和动态分配"><a href="#静态分配和动态分配" class="headerlink" title="静态分配和动态分配"></a><strong>静态分配和动态分配</strong></h4><p>静态分配<br>当一个作业（或进程）运行时，根据作业要求的设备，系统如果能满足，则将其要求的设备全部分配给它，然后开始运行，运行完成释放其占用的所有设备。<br>这种分配方式的优点是系统绝不会出现死锁，缺点是设备利用率太低。</p>
<p>动态分配<br>这种分配方法是在作业（或进程）运行的过程中，需要使用设备时，就向系统申请，系统根据某种分配原则进行分配。<br>这种方法的优点是设备的利用率高，缺点是系统有出现死锁的可能。</p>
<h3 id="Spooling"><a href="#Spooling" class="headerlink" title="Spooling"></a>Spooling</h3><h4 id="概念-12"><a href="#概念-12" class="headerlink" title="概念"></a>概念</h4><ul>
<li>利用CPU与通道可以并行工作的特点，原来在脱机系统中的预输入和缓输出工作全部由主机系统承担。</li>
<li>在操作系统设计了两个程序来代替两台卫星机的工作，这两个程序分别为“预输入程序”和“缓输出程序”在系统运行时形成进程工作。</li>
<li>同时在共享设备（磁盘）上开辟出两个称为“井”的特殊的区域来存放输入的信息和执行结果。</li>
</ul>
<h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><ol>
<li>硬件部分<ul>
<li>这部分包含了在磁盘或磁鼓上设立的两区域：输入井和输出井，以及在主存中开辟出的两个缓冲区：输入缓冲区和输出缓冲区。 </li>
<li>输入井：用来存放来自于输入设备的信息。</li>
<li>输出井：用来保存即将送到输出设备上的结果。</li>
<li>输入缓冲区：暂时保存外设准备送入输入井的信息。</li>
<li>输出缓冲区：暂时保存从输出井送出的结果。</li>
</ul>
</li>
<li>软件部分<ul>
<li>在这部分中，包含了预输入进程，缓输出进程，输入井管理进程，输出井管理进程。</li>
<li>预输入进程：将用户要求的输入数据输入到输入设备上，再经通道和输入缓冲区送入输入井。</li>
<li>缓输出进程：将用户的输出结果在设备空闲时从输出井中，经输出缓冲区送至输入设备。</li>
<li>输入井管理进程：将输入井中的数据读入内存。</li>
<li>输出井管理进程：将内存中的结果送至输出井中。</li>
</ul>
</li>
</ol>
<h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220105152017.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220105152017.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220105151931423" style="zoom: 50%;" />

<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><p>可使一个作业的I/O与其它作业的计算重叠起来进行</p>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li> 占用大量的内存空间</li>
<li>占用大量磁盘空间作为输入井和输出井</li>
<li>增加了系统的复杂性</li>
</ul>
<h3 id="CPU和外设数据的交换方式"><a href="#CPU和外设数据的交换方式" class="headerlink" title="CPU和外设数据的交换方式"></a>CPU和外设数据的交换方式</h3><h4 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h4><ol>
<li>在计算机中，端口又被称为接口。其主要功能是：<ul>
<li>按照计算机主机与设备的约定格式和过程接收或发送数据和信号。</li>
</ul>
</li>
<li>分类：<ul>
<li>从数据传输方式分类：并行接口/串行接口</li>
<li>从传送的同步方式来看：有异步和同步之分。</li>
</ul>
</li>
</ol>
<h4 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h4><ol>
<li>如果一个或多个设备使用一组共同的线，这张连接称为总线（bus）。</li>
<li>总线是一组线和一组严格定义的可以描述在线上传输信息的协议。在总线上可以连接多个设备，它们通过总线交换数据。</li>
<li>根据其传递信息类型分类：<ul>
<li>地址总线</li>
<li>数据总线</li>
<li>控制总线</li>
</ul>
</li>
</ol>
<h4 id="设备控制器"><a href="#设备控制器" class="headerlink" title="设备控制器"></a>设备控制器</h4><ol>
<li><p>设备控制器的主要功能是：控制一个或多个I/O设备，以实现I/O设备和计算机之间的数据交换。</p>
</li>
<li><p>它是CPU和I/O设备之间的接口，它接收从CPU发出的命令，并控制I/O设备工作。</p>
</li>
<li><p>它是一个可编址的设备，当它只控制一个设备时，它有唯一的一个设备地址；若它连接多个设备时，则应含有多个设备地址，使每一个设备地址对应一个设备。</p>
</li>
<li><p>设备控制器可分为两类：</p>
<ul>
<li>一类是控制字符设备的控制器</li>
<li>另一类是用于控制块设备的控制器。</li>
</ul>
</li>
<li><p>设备控制器的基本功能：</p>
<ul>
<li>接收和识别命令：接收从CPU发来的命令，并识别这些命令。 </li>
<li>数据交换：实现CPU与设备控制器之间、设备控制器与设备之间的数据交换。 </li>
<li>标识和报告设备的状态：控制器应记录下设备的状态供CPU了解。此状态值从设备对应的状态寄存器中读取。</li>
<li>地址识别：识别其所控制的每个设备的地址。 </li>
<li>数据缓冲：在控制器中设置缓冲以缓和I/O设备和CPU、内存之间的速度矛盾。 </li>
<li>差错控制：设备控制器还兼管对由I/O设备传来的数据进行差错检测。 </li>
</ul>
</li>
</ol>
<h3 id="I-O通道"><a href="#I-O通道" class="headerlink" title="I/O通道"></a>I/O通道</h3><h4 id="分类-6"><a href="#分类-6" class="headerlink" title="分类"></a>分类</h4><ol>
<li><p>字节多路通道</p>
<ul>
<li>字节多路通道以字节为单位传输信息，它可以分时地执行多个通道程序。当一个通道程序控制某台设备传送一个字节后，通道硬件就控制转去执行另一个通道程序，控制另一台设备传送信息</li>
<li>主要连接以字节为单位的低速I/O设备。如打印机，终端。   以字节为单位交叉传输，当一台传送一个字节后，立即转去为另一台传送字节</li>
</ul>
</li>
<li><p>选择通道</p>
<ul>
<li>选择通道是以成组方式工作的，即每次传送一批数据，故传送速度很高。选择通道在一段时间内只能执行一个通道程序，只允许一台设备进行数据传输</li>
<li>当这台设备数据传输完成后，再选择与通道连接的另一台设备，执行它的相应的通道程序</li>
<li>主要连接磁盘，磁带等高速I/O设备</li>
</ul>
</li>
<li><p>成组多路通道</p>
<ul>
<li>它结合了选择通道传送速度高和字节多路通道能进行分时并行操作的优点。它先为一台设备执行一条通道指令，然后自动转接，为另一台设备执行一条通道指令</li>
<li>主要连接高速设备</li>
</ul>
</li>
</ol>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>为了使CPU从I/O事务中解脱出来，同时为了提高CPU与设备，设备与设备之间的并行工作能力</p>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h3 id="概念-13"><a href="#概念-13" class="headerlink" title="概念"></a>概念</h3><ol>
<li>文件系统是操作系统中负责管理和存取文件信息的软件机构，它是由管理文件所需的数据结构和相应的管理软件以及访问文件的一组操作组成。</li>
<li>从系统的角度看：文件系统是一个负责文件存储空间管理的机构。</li>
<li>从用户的角度看：文件系统是用户在计算机上存储信息、和使用信息的接口。</li>
</ol>
<h3 id="功能-2"><a href="#功能-2" class="headerlink" title="功能"></a>功能</h3><ol>
<li>提供用户对文件操作的命令；</li>
<li>提供用户共享文件的机制；</li>
<li>管理文件的存储介质；</li>
<li>提供文件的存取控制的机制，保障文件及文件系统的安全性；</li>
<li>提供文件及文件系统的备份和恢复功能；</li>
<li>提供对文件的加密和解密功能。</li>
</ol>
<h3 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h3><h4 id="概念-14"><a href="#概念-14" class="headerlink" title="概念"></a>概念</h4><ol>
<li>文件目录也被称为文件说明或文件控制块（File Control Block，FCB）即文件名址录。它是一张记录所有文件名及其存放地址、文件的说明和控制信息的表格。</li>
<li>一般情况下，每个文件占用一个表目，即每个文件有一个文件的目录项。</li>
</ol>
<h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><ol>
<li>文件名</li>
<li>文件的大小，单位：字节</li>
<li>文件在物理存储介质中的位置。<ul>
<li>取决于文件的物理结构 。对于连续文件：文件起始块号（即文件的第一个物理块块号）；对于串联文件：指向第一个物理块的指针；对于索引文件：索引表。</li>
</ul>
</li>
<li>存取控制信息<ul>
<li>文件主和其它用户对该文件的访问权限。</li>
</ul>
</li>
<li>管理信息<ul>
<li>包含文件创建的日期和时间，最近修改该文件的日期和时间等。</li>
</ul>
</li>
<li>文件的类型</li>
</ol>
<h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><ul>
<li>实现“按名存取”。 </li>
<li>提高对目录的检索速度。 </li>
<li>文件共享。 </li>
<li>允许文件重名。 </li>
</ul>
<h3 id="文件逻辑结构"><a href="#文件逻辑结构" class="headerlink" title="文件逻辑结构"></a>文件逻辑结构</h3><ol>
<li>无结构文件－－流式文件<ul>
<li>无结构的流式文件是相关的有序字符的集合。文件的长度为所含字符数。</li>
<li>UNIX、DOS、WINDOWS系统中的普通文件都是流式文件。</li>
</ul>
</li>
<li>结构文件－－记录式文件<ul>
<li>结构文件是记录的集合。 每个记录由彼此相关的域构成。记录可按顺序编号。</li>
<li>如果文件中所有记录的长度都相同，则这种文件为定长记录文件。</li>
<li>定长记录文件的长度 = 记录个数x记录长度。</li>
<li>变长记录文件的长度为各记录长度之和。</li>
</ul>
</li>
</ol>
<h3 id="文件物理结构"><a href="#文件物理结构" class="headerlink" title="文件物理结构"></a>文件物理结构</h3><h4 id="连续文件"><a href="#连续文件" class="headerlink" title="连续文件"></a>连续文件</h4><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220105154033.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220105154033.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220105154028523" style="zoom:50%;" />

<h4 id="串联文件"><a href="#串联文件" class="headerlink" title="串联文件"></a>串联文件</h4><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220105154107.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220105154107.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220105154103983" style="zoom:50%;" />

<ol>
<li><p>一个串联文件结构是按顺序由串联的块组成的，即文件的信息按存储介质的物理特性存于若干块中。每个物理块的最末一个字(或第一个字)作为链接字，它指出后继块的物理地址。链首指针存放在该文件目录中。文件的结尾块的指针为“∧”。</p>
</li>
<li><p>这种文件结构不要求连续存放。</p>
</li>
<li><p>对于记录式文件一块中可包含一个逻辑记录或多个逻辑记录，也可以若干物理块包含一个逻辑记录。</p>
</li>
<li><p>优点：</p>
<ol>
<li>存储空间利用率高；</li>
<li>文件创建时用户不必指出文件的大小；</li>
<li>文件动态扩充和修改容易。</li>
<li>顺序存取效率高。</li>
</ol>
</li>
<li><p>缺点：<br>1.随机存取效率太低，如果访问文件的最后内容，实际上是要访问整个文件。<br>2.指针域需额外占用空间；<br>3.指针与数据同时存放，破坏了物理块的完整性。</p>
</li>
</ol>
<h4 id="随机文件"><a href="#随机文件" class="headerlink" title="随机文件"></a>随机文件</h4><h5 id="直接地址结构"><a href="#直接地址结构" class="headerlink" title="直接地址结构"></a>直接地址结构</h5><ol>
<li>定义：<pre><code> 直接通过某一给定的记录地址，直接对记录存取。
</code></pre>
</li>
<li>优点：<pre><code> 存储效率高，不需要进行任何查找；
</code></pre>
</li>
<li>缺点：<pre><code> 知道记录所在地址较困难。
</code></pre>
</li>
</ol>
<h5 id="索引文件结构"><a href="#索引文件结构" class="headerlink" title="索引文件结构"></a>索引文件结构</h5><ol>
<li>这种文件结构的数据结构是文件的索引表，每个文件有一个索引表，表中每个表目包括：逻辑块号，物理块号。</li>
<li>索引表位置：文件目录中，文件的开头等。</li>
<li>索引表大小:固定大小，非固定大小。</li>
<li>索引文件占两个区：<ul>
<li>索引区：存放索引表；</li>
<li>数据区：用于存放数据文件本身。</li>
</ul>
</li>
<li>访问索引文件<ul>
<li>查文件索引，由逻辑块号查得物理块号；</li>
<li>访问该物理块获得所需信息。</li>
</ul>
</li>
<li>优点：<ul>
<li>可直接读写记录；</li>
<li>便于文件的增删。</li>
</ul>
</li>
<li>缺点：<ul>
<li>增加了索引表的空间开销及查找时间。</li>
</ul>
</li>
</ol>
<h5 id="计算寻址结构"><a href="#计算寻址结构" class="headerlink" title="计算寻址结构"></a>计算寻址结构</h5><ol>
<li>直接地址</li>
<li>一次间接地址</li>
<li>多次间接地址</li>
</ol>
<h4 id="散列文件文件（HASH文件）"><a href="#散列文件文件（HASH文件）" class="headerlink" title="散列文件文件（HASH文件）"></a>散列文件文件（HASH文件）</h4><ol>
<li><p>HASH法是一种杂凑法，亦称散列法。</p>
</li>
<li><p>它是一种构造和查找符号表的常用技术，其基本思想是利用一个简单宜于实现的变换函数（HASH函数），把每个符号名唯一的变换成表中的表目位置.即：a=H(k)</p>
</li>
<li><p>其中，H为HASH函数，k为关键字（符号名），a为k在符号表中相应的表目位置，a又称HASH值，对于任一符号名，通过HASH变换直接得到a,比线性查找法大大加快了平均检索速度.</p>
</li>
<li><p>散列算法的基本思想：关键字   计算   记录地址；</p>
</li>
<li><p>需解决的问题：</p>
<ul>
<li>寻一HASH函数实现转换；</li>
<li>确定解决冲突的方法。</li>
</ul>
</li>
<li><p>常用的散列算法有：</p>
<ul>
<li>截段法：截取关键字的一部分作为地址；</li>
<li>特征性抽取法：抽取关键码字段的某些位并联结起来作为地址；</li>
<li>除余法：把关键字除以某一数而取其余数作为地址；</li>
<li>折叠法：把关键字数码串分段，然后叠加起来作为地址；</li>
<li>平方取中法：把关键字平方后取其结果的中间部分作为地址。</li>
</ul>
</li>
</ol>
<h4 id="文件物理结构的比较"><a href="#文件物理结构的比较" class="headerlink" title="文件物理结构的比较"></a>文件物理结构的比较</h4><ol>
<li><p>连续文件的优点是不需要额外的空间开销，只要在文件目录中指出文件的大小和首块的块号即可，对顺序的访问效率很高。适应于顺序存取。缺点是动态地增长和缩小系统开销很大；文件创建时要求用户提供文件的大小；存储空间浪费较大。</p>
</li>
<li><p>串联文件克服了连续文件的不足之处，但文件的随机访问系统开销较大。适应于顺序访问的文件。DOS系统中改造了串联文件的结构，使其克服了串联文件的不足，但增加了系统的危险性。</p>
</li>
<li><p>索引文件既适应于顺序存访问，也适应于随机访问，是一种比较 好的文件物理结构，但要有用于索引表的空间开销和文件索引的时间开销。UNIX系统是使用索引结构成功的例子。</p>
</li>
</ol>
<h3 id="文件存储空间的管理"><a href="#文件存储空间的管理" class="headerlink" title="文件存储空间的管理"></a>文件存储空间的管理</h3><p>策略：</p>
<ul>
<li>空闲文件项</li>
<li>空闲文件目录，</li>
<li>空闲块链，</li>
<li>位示图</li>
</ul>
<h3 id="文件共享与文件保护"><a href="#文件共享与文件保护" class="headerlink" title="文件共享与文件保护"></a>文件共享与文件保护</h3><ol>
<li>文件共享：是指某一个或某一部分文件可以让事先规定的某些用户共同使用。</li>
<li>为了实现文件共享，系统还必须提供文件保护的能力，即提供保证文件安全性的措施。</li>
<li>为了保证文件的安全性，一个文件保护系统应具有四个方面的内容：<ul>
<li>被保护的目标；</li>
<li>被允许的文件存取类型；</li>
<li>标识能独立地存取某一文件的用户；</li>
<li>实现文件保护的过程，即存取权限的验证。</li>
</ul>
</li>
</ol>
<h4 id="文件共享的五种方式"><a href="#文件共享的五种方式" class="headerlink" title="文件共享的五种方式"></a>文件共享的五种方式</h4><ol>
<li>绕道法</li>
<li>采用“链接技术”实现文件共享</li>
<li>基本文件目录</li>
<li>利用符号链实现文件共享 </li>
<li>基于索引节点的共享方式 </li>
</ol>
<h4 id="文件保护的六种方式"><a href="#文件保护的六种方式" class="headerlink" title="文件保护的六种方式"></a>文件保护的六种方式</h4><ol>
<li>访问控制矩阵</li>
<li>存取控制表</li>
<li>用户权限表</li>
<li>隐藏文件目录</li>
<li>口令</li>
<li>密码</li>
</ol>
<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p>为方便用户使用文件，文件系统提供对文件的各种操作，形式分别为：</p>
<ol>
<li><p>系统调用或命令</p>
</li>
<li><p>提供设置和修改用户文件的存取权限的服务</p>
</li>
<li><p>提供建立、修改、改变、删除目录的服务</p>
</li>
<li><p>提供文件共享，设置访问路径的服务</p>
</li>
<li><p>提供创建、打开、读、写、关闭、撤消文件等服务</p>
</li>
<li><p>文件系统维护</p>
</li>
<li><p>文件系统的转储和恢复</p>
</li>
</ol>
<blockquote>
<p>最基本的操作是：打开、关闭、读、写文件等</p>
</blockquote>
<h4 id="建立文件"><a href="#建立文件" class="headerlink" title="建立文件"></a>建立文件</h4><ol>
<li><p>实质：</p>
<ul>
<li>建立文件的FCB，并建立必要的存储空间，分配空FCB，根据提供的参数及需要填写有关内容，返回一个文件描述</li>
</ul>
</li>
<li><p>目的：建立系统与文件的联系</p>
</li>
<li><p>过程:</p>
<ul>
<li>检查参数合法性</li>
<li>检查同一目录下有无重名文件</li>
<li>在文件目录结构中的适当位置建立一个文件控制块FCB。</li>
<li>将参数填入FCB。</li>
<li>分配文件所存放的外存空间（也可lazy分配即在写数据时分配），建立索引表，填入FCB中。 </li>
</ul>
</li>
</ol>
<h4 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h4><ol>
<li>任何一个文件使用前都要先打开，即把FCB送到内存，以建立用户和文件的联系，使今后频繁的查目录操作在内存中完成。如fd=open(文件路径名, 打开方式)</li>
<li>打开文件操作的主要执行步骤如下：<ul>
<li>根据文件路径名查目录，找到FCB主部；</li>
<li>根据打开方式、共享说明和用户身份检查访问合法性；</li>
<li>根据文件号查系统打开文件表，看文件是否已被打开；若是→共享计数加1,  否则→将外存中的FCB主部等信息填入系统打开文件表空表项，共享计数置为1；</li>
<li>在用户打开文件表中取一空表项，填写打开方式等，并指向系统打开文件表对应表项</li>
<li>返回信息：fd：文件描述符，是一个非负整数，用于以后读写文件</li>
</ul>
</li>
</ol>
<h4 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h4><ol>
<li>用户要求读文件信息时就调用本操作，系统允许用户对已经调用过“打开”操作的文件进行渎。</li>
<li>调用“读”操作时，用户应提供如下参数：用户名、文件名、主存地址、存取方式、记录号或记录键、长度。</li>
<li>文件系统完成“读”操作的主要工作是：<ul>
<li>核对该用户是否已“打开”指定的文件，</li>
<li>核对存取方式是否合理；</li>
<li>若采用的是顺序存取方式，则从当前位置读一块或几块信息到指定的主存地址中，且把后继信息存放位置作为新的当前位置i</li>
<li>若采用的是随机存取方式，则按给定的记录号或记录控查索引表，得到记录存放地址后读出该记录。</li>
</ul>
</li>
</ol>
<h4 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h4><ol>
<li>用户要求保存文件信息时就调用本操作，系统允许用户对已经调用过“建立”操作的文件执行写。</li>
<li>调用“写”操作时用户提供的参数与“读”操作的参数相同。</li>
<li>文件系统完成“写”操作的主要工作是：<ul>
<li>核对用户文件是否已“建立”，若否，则请用户先调用“建立”操作；</li>
<li>寻找空闲的存储空间，按已确定的存储结构把主存中的文件信息写到所找出的存储块中；</li>
<li>对采用索引结构的文件须登记索引项。</li>
</ul>
</li>
</ol>
<h4 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h4><ol>
<li>经过“打开”或“建立”的文件，用户在读写完毕后，需要调用“关闭”操作归还文件的使用权。</li>
<li>用户只能关闭自己打开或建立的文件。</li>
<li>调用“关闭”操作时应给出参数：用户名、文件名。</li>
<li>文件系统执行“关闭”操作的主要工作如下：<ul>
<li>检查是否是文件打开者或建立者请求关闭。若否，则拒绝关闭。</li>
<li>谈到主存储器中的文件目录或索引表是否被修改过，若是，则把它们重新保存到存储介质上。</li>
<li>清除文件已“打开”。</li>
</ul>
</li>
</ol>
<h4 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h4><ol>
<li>用户调用“删除”操作可请求文件系统删除一个保存在磁盘或磁带上的文件。</li>
<li>调用该操作时提供的参数为：用户名、文件名、存储设备类型。</li>
<li>文件系统执行“删除”操作的主要工作是：<ul>
<li>在指定的设备上让用户装上含有该文件的存储介质；</li>
<li>检查文件是否已关闭，若否，则请先调用“关闭”操作；</li>
<li>在文件目录中删除该文件的目录项；</li>
<li>收回该文件占用的存储空间。</li>
</ul>
</li>
</ol>
<h4 id="文件的使用"><a href="#文件的使用" class="headerlink" title="文件的使用"></a>文件的使用</h4><ol>
<li>为了保证文件系统对文件的正确管理，用户使用文件时应遵循一定的步骤。为避免一个共享文件(多个用户都可使用的文件)被几个用户同时使用而造成的混乱，规定使用文件前先调用“打开”。一个文件打开后，在它被关闭之前不允许非打开者使用。</li>
<li>一个文件被“打开”或“建立”后，允许打开者或建立者多次调用“读”操作或“写”操作来使用该文件。文件使用结束后必须调用“关闭”操作来归还文件的使用权。一个被关闭后的文件不能再使用。若要再使用，则必须再次调用“打开”操作。</li>
<li>用户的文件交系统管理后，为保证文件的安全可靠，用户使用文件的操作步骤应遵循如下步骤：<br>（一）读文件：“打开”文件；“读”文件(可多次调用)；“关闭”文件<br>（二）写文件：“建立”文件；“写”文件(可多次调用)；“关闭”文件<br>（三）删除文件：关闭文件；删除文件</li>
<li>有的系统为了方便用户，还提供了一种隐式使用文件的方法，用户可以不必调用“打开”、“建立”和“关闭”文件的操作，而是直接调用“读”文件或“写”文件的操作。但是对文件系统来说，要先检查用户请求读或写的文件是否已经打开或建立，若否，则文件系统仍需先做好“打开”或“建立”的工作。如果用户使用了一个A文件后又要使用B文件，则文件系统先关闭A文件，再打开或建立B文件，然后对B文件执行读或写操作。 </li>
</ol>
<h3 id="文件转存备份方式"><a href="#文件转存备份方式" class="headerlink" title="文件转存备份方式"></a>文件转存备份方式</h3><ol>
<li>全量转储：把文件存储器中的所有文件定期复制到磁带上</li>
<li>增量转储：定期把所有修改过的文件和新文件转储到磁带上</li>
</ol>
<h3 id="位示图"><a href="#位示图" class="headerlink" title="位示图"></a>位示图</h3><ol>
<li>位示图是外存空间的存储映射图。</li>
<li>位示图是系统在内存中划分出的若干字节的集合，用来指示磁盘存储情况。位示图中的每一位（bit）对应外存空间的一个物理块。<ul>
<li>若该位为“1”，表示对应块被占用；</li>
<li>若该位为“0”，表示对应物理块空闲。</li>
</ul>
</li>
<li>位示图的大小由其对应的文件存储设备的容量决定，当一个盘组的分块确定后，根据划分的总块数决定位示图由多少字节组成。</li>
</ol>
<p>在实际应用时，应根据磁盘的结构确定位示图的构造，以及每个柱面上的块数和每个磁道上的扇区数，列出相应的换算公式。确定空闲块地址的通用公式为：</p>
<ul>
<li><p>块号 = 字号x字长 ＋ 位号</p>
</li>
<li><p>柱面号 = [块号/柱面上的块数]</p>
</li>
<li><p>磁头号 = [(块号mod柱面上的块数)／磁道上的扇区数]</p>
</li>
<li><p>扇区号＝(块号mod柱面上的块数) mod磁道上的扇区数</p>
</li>
</ul>
<p>归还一块时，寻找位示图中位置的通用公式为：</p>
<ul>
<li>块号＝柱面号×柱面上块数＋磁头号×磁道上扇区数＋扇区号</li>
<li>字号＝[块号/字长]</li>
<li>位号＝块号mod字长</li>
</ul>
<h2 id="计算题"><a href="#计算题" class="headerlink" title="计算题"></a>计算题</h2><h3 id="位示图-1"><a href="#位示图-1" class="headerlink" title="位示图"></a>位示图</h3><p>例4：磁盘有80个柱面，20个磁道/柱面，6块/磁道，1KB/块。位示图共有20张，60字/张。给出申请或归还公式。<br>假设：<br>       磁盘                    位示图：<br>  柱面号i：(0～79)          张x： （0～20）<br>  磁头号j：(0～19)          字y： （0～59）<br>  块号k： (0～5)            位z： （0～15）<br>申请一块：已知x，y，z，转换为i，j，k<br>归还一块：已知i，j，k ，转换为x，y，z</p>
<p>解：60字/张，16位/字⇒60×16＝960位/字<br>20个磁道，6块/磁道，故20×6＝120块/柱面<br>分配：一张位示图 960/120＝8个柱面<br>设w为某一张位示图的第w位。则w＝16×y＋z<br>则柱面号：i＝8×x＋w/120=(960×x＋16×y＋z）/120<br>磁头号：j＝（w％120）/6<br>块号：k＝（ w％120）％6<br>归还：已知i，j，k；求x，y，z<br>x ＝ i/8<br>y = ( i%8<em>120+6</em>j+k ) / 16<br>z = ( i%8<em>120+6</em>j+k ) % 16</p>
<h3 id="页式地址变换"><a href="#页式地址变换" class="headerlink" title="页式地址变换"></a>页式地址变换</h3><p>在请求分页系统中，某用户的编程空间为16个页面，每页1K，分配的内存空间为8K。假定某时刻该用户的页表如下图所示，试问：</p>
<img src="https://img-blog.csdnimg.cn/20191219155804660.png" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/20191219155804660.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述" style="zoom: 80%;" />

<p>（1）逻辑地址084B（H）对应的物理地址是多少？（用十六进制表示）<br>（2）逻辑地址5000（十进制）对应的物理地址是多少？（用十进制表示）<br>（3）当该用户进程欲访问24A0H单元时，会出现什么现象？</p>
<p>084BH = 0000 1000 0100 1011<br>0000 10 00 0100 1011<br>0001 00 00 0100 1011 0x104B</p>
<p>5000 = 0001 0011 1000 1000<br>0001 00 11 1000 1000<br>0011 00 11 1000 1000 13192</p>
<p>24A0 = 0010 0100 1010 0000<br>0010 01 00 1010 0000<br>页号为9，页表中不存在，发生缺页中断</p>
<p><img src="https://img-blog.csdnimg.cn/20191219155831316.png" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/20191219155831316.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述"></p>
<p>(3)答： 24A0（H）的页号为9，而其页面当前不在内存，所以会发一个缺页中断，请求系统调页。</p>

            </div>

            <!-- Post Comments -->
            
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'http-miccall-tech'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://xucoud.github.io/2022/01/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://xucoud.github.io/2022/01/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//http-miccall-tech.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a target="_blank" rel="noopener" href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
                <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
