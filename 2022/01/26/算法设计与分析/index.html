<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="/img/logo_miccall.png"/>
	<link rel="shortcut icon" href="/img/logo_miccall.png">
	
			    <title>
    Xu's Blog
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    <meta name="keywords" content="miccall" />
    
    	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	 
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('/img/bg.jpg') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

			    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<meta name="generator" content="Hexo 5.4.1"><link rel="alternate" href="/atom.xml" title="Xu's Blog" type="application/atom+xml">
</head>
    
		
<!-- Layouts -->



<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_coy.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">MICCALL</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/Go/">Go</a></li><li><a class="category-link" href="/categories/Go/GC/">GC</a></li><li><a class="category-link" href="/categories/Go/GMP/">GMP</a></li><li><a class="category-link" href="/categories/Go/ORM/">ORM</a></li><li><a class="category-link" href="/categories/Go/Web/">Web</a></li><li><a class="category-link" href="/categories/Go/module/">module</a></li><li><a class="category-link" href="/categories/Go/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/">内存分配</a></li><li><a class="category-link" href="/categories/Go/%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8/">内存逃逸</a></li><li><a class="category-link" href="/categories/Java/">Java</a></li><li><a class="category-link" href="/categories/Redis/">Redis</a></li><li><a class="category-link" href="/categories/Restful/">Restful</a></li><li><a class="category-link" href="/categories/Spring/">Spring</a></li><li><a class="category-link" href="/categories/SpringBoot/">SpringBoot</a></li><li><a class="category-link" href="/categories/k8s/">k8s</a></li><li><a class="category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></li><li><a class="category-link" href="/categories/%E5%89%8D%E7%AB%AF/js/">js</a></li><li><a class="category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li><li><a class="category-link" href="/categories/%E6%9C%9F%E6%9C%AB/">期末</a></li><li><a class="category-link" href="/categories/%E6%9C%9F%E6%9C%AB/JAVA/">JAVA</a></li><li><a class="category-link" href="/categories/%E6%9C%9F%E6%9C%AB/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></li><li><a class="category-link" href="/categories/%E6%9C%9F%E6%9C%AB/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/">算法设计与分析</a></li><li><a class="category-link" href="/categories/%E6%9C%9F%E6%9C%AB/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></li><li><a class="category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a>
	                    </ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/about/" title="简历">
		                简历
		            </a>
		        </li>
		        
		        <li>
		            <a href="/group/" title="团队">
		                团队
		            </a>
		        </li>
		        
		        <li>
		            <a href="/gallery/" title="图库">
		                图库
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="标签">
		                标签
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
                    
                    <li>
                        <a title="github" href="https://github.com/miccall" target="_blank" rel="noopener">
                            <i class="icon fa fa-github"></i>
                        </a>
                    </li>
                    
                    <li>
                        <a title="500px" href="http://500px.com" target="_blank" rel="noopener">
                            <i class="icon fa fa-500px"></i>
                        </a>
                    </li>
                    
			</ul>
</nav>

        <div id="main" >
            <div class ="post_page_title_img" style="height: 25rem;background-image: url();background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;" >
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2 >算法设计与分析</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
                <span id="more"></span>

<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><h2 id="递归与分治"><a href="#递归与分治" class="headerlink" title="递归与分治"></a>递归与分治</h2><h3 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h3><p>递归：直接或间接的调用自身的函数</p>
<p>分治：将一个规模为n的问题分解为k个规模较小的子问题，这些子问题互相独立且与原问题相同，递归的求解这些子问题，然后将各个子问题的解合并到原问题的解。</p>
<h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><ol>
<li>分解：分解原问题为结构相同的子问题。</li>
<li>解决：分解到某个容易求解的边界之后，进行递归求解。</li>
<li>合并：将子问题的解合并成原问题的解。</li>
</ol>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：结构清晰、可读性强</p>
<p>缺点：运行时效率较低，耗费较多的时间、空间资源</p>
<h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ol>
<li>规模如果很小，则很容易解决。//一般问题都能满足</li>
<li>大问题可以分为若干规模小的相同问题。//前提   </li>
<li>利用子问题的解，可以合并成该问题的解。//关键    </li>
<li>分解出的各个子问题相互独立，子问题不再包含公共子问题。 //效率高低</li>
</ol>
<h3 id="众数问题"><a href="#众数问题" class="headerlink" title="众数问题"></a>众数问题</h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>给定含有n个元素的多重集合s,每个元素在S中出现的次数称为该元素的重数。多重集S中重数最大的元素称为众数。例如， S-(1, 2, 2, 2, 3, 3, 5).多重集S的众数是2,其重数为3,对于给定的由n个自然数组成的多重集s,计算S的众数及其重数。如果出现多个众数，请输出最小的那个。</p>
<h4 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h4><p>输入数据的第1行是多重集S中元素个数n (n&lt;1 300000) ;接下来的n行中，每行有一个最多含有5位数字的自然数。输出数据的第1行给出众数，第2行是重数。<br>样例为：</p>
<blockquote>
<p>Sample input<br>6<br>1<br>2<br>2<br>2<br>3<br>5</p>
</blockquote>
<blockquote>
<p>Sample output<br>2<br>3</p>
</blockquote>
<h4 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h4><p>取中位数的个数为重数，中位数为众数，确定左界、右界。</p>
<p>在往左界递归取中位数为众数，个数为重数，比较</p>
<p>往右界递归取中位数为众数，个数为重数，比较</p>
<p>如果中位数的个数大于左界个数，那左边一定没有该组数据的众数；反之，右边一样。</p>
<p>该程序要求数据有序（从小到大），本程序未写排序算法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdlib.h&quot;</span></span></span><br><span class="line">define N <span class="number">100</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Split</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n,<span class="keyword">int</span> &amp;l,<span class="keyword">int</span> &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//以中间数字为界，确定左右界</span></span><br><span class="line">	<span class="keyword">int</span> mid = n/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span>(l = <span class="number">0</span>;l &lt;= mid;++l)<span class="comment">//找左界</span></span><br><span class="line">		<span class="keyword">if</span>(a[l] == a[mid])</span><br><span class="line">			<span class="keyword">break</span>;<span class="comment">//此时l为左界</span></span><br><span class="line">	<span class="keyword">for</span>(r = mid + <span class="number">1</span>;r &lt; n;++r)<span class="comment">//找右界</span></span><br><span class="line">		<span class="keyword">if</span>(a[r] !=a[mid])</span><br><span class="line">			<span class="keyword">break</span>;<span class="comment">//此时r为右界</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getMaxNum</span><span class="params">(<span class="keyword">int</span> &amp;num,<span class="keyword">int</span> &amp;maxnum,<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//求众数和重数</span></span><br><span class="line">	<span class="keyword">int</span> l,r,s;</span><br><span class="line">	<span class="keyword">int</span> mid = n/<span class="number">2</span>;</span><br><span class="line">	Split(a,n,l,r);</span><br><span class="line">	s = r - l;</span><br><span class="line">	<span class="keyword">if</span>(s &gt; maxnum)</span><br><span class="line">	&#123;<span class="comment">//如果中间数字的个数大于现在的重数，则更新</span></span><br><span class="line">		num = a[mid];</span><br><span class="line">		maxnum = s;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(s == maxnum)<span class="comment">//如果出现多个众数，输出最小的那个</span></span><br><span class="line">	    <span class="keyword">if</span>(num &gt; a[mid])</span><br><span class="line">		&#123;</span><br><span class="line">			num = a[mid];</span><br><span class="line">		    maxnum = s;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">if</span>(l+<span class="number">1</span> &gt; maxnum)</span><br><span class="line">	<span class="comment">//如果左边的个数&gt;maxnum,则搜索左边</span></span><br><span class="line">		getMaxNum(num,maxnum,a,l+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(n - r &gt; maxnum)</span><br><span class="line">	<span class="comment">//如果右边的个数&gt;maxnum,则搜索右边</span></span><br><span class="line">		getMaxNum(num,maxnum,a+r,n-r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,n,a[N];</span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">0</span>;<span class="comment">//num为众数</span></span><br><span class="line">	<span class="keyword">int</span> maxnum = <span class="number">0</span>;<span class="comment">//maxnum为重数</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);<span class="comment">//输入数据个数</span></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">	    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);<span class="comment">//输入数据</span></span><br><span class="line">	    <span class="comment">//sort(a[i]);//将数据排序</span></span><br><span class="line">	getMaxNum(num,maxnum,a,n);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n%d&quot;</span>,num,maxnum);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="集合划分"><a href="#集合划分" class="headerlink" title="集合划分"></a>集合划分</h3><h4 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h4><p>n个元素的集合{1,2,?, n }可以划分为若干个非空子集。例如，当n=4 时，集合{1，2，3，4}可以划分为15 个不同的非空子集如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;1&#125;，&#123;2&#125;，&#123;3&#125;，&#123;4&#125;&#125;，</span><br><span class="line">&#123;&#123;1，2&#125;，&#123;3&#125;，&#123;4&#125;&#125;，</span><br><span class="line">&#123;&#123;1，3&#125;，&#123;2&#125;，&#123;4&#125;&#125;，</span><br><span class="line">&#123;&#123;1，4&#125;，&#123;2&#125;，&#123;3&#125;&#125;，</span><br><span class="line">&#123;&#123;2，3&#125;，&#123;1&#125;，&#123;4&#125;&#125;，</span><br><span class="line">&#123;&#123;2，4&#125;，&#123;1&#125;，&#123;3&#125;&#125;，</span><br><span class="line">&#123;&#123;3，4&#125;，&#123;1&#125;，&#123;2&#125;&#125;，</span><br><span class="line">&#123;&#123;1，2&#125;，&#123;3，4&#125;&#125;，</span><br><span class="line">&#123;&#123;1，3&#125;，&#123;2，4&#125;&#125;，</span><br><span class="line">&#123;&#123;1，4&#125;，&#123;2，3&#125;&#125;，</span><br><span class="line">&#123;&#123;1，2，3&#125;，&#123;4&#125;&#125;，</span><br><span class="line">&#123;&#123;1，2，4&#125;，&#123;3&#125;&#125;，</span><br><span class="line">&#123;&#123;1，3，4&#125;，&#123;2&#125;&#125;，</span><br><span class="line">&#123;&#123;2，3，4&#125;，&#123;1&#125;&#125;，</span><br><span class="line">&#123;&#123;1，2，3，4&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>给定正整数n，计算出n个元素的集合{1,2,?, n }可以划分为多少个不同的非空子集。 </p>
<h4 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h4><p>定义F(n,m)=此题的解<br>当m=1时，F(n,m)=1;<br>当n=m时，F(n,m)=1;</p>
<p>假设原集合有m个元素，后输入了n-m个元素，此时将输入的元素和原集合的1个元素合并成一个子集，则此时集合依旧有m个元素，或者将原集合的n-m+1个元素合并成一个子集，此时集合也是m个元素，则这两种合并方法，合并出来的集合的不同种类之和，则是我们需要想要得出的答案。<br>（上面一段话用了逆向的思维方式）<br>这两种方法所得到的表达式则为：<br>F(n-1,m-1)和F(n,m-1)*m<br>答案就等于： F(n-1,m-1)+F(n,m-1)*m<br>这样，则可以用递归的方法求出答案(在得出任一个递归的返回值之前，调用次数为2^n次)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">F</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(m==<span class="number">1</span>||m==n)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">F</span>(n<span class="number">-1</span>,m<span class="number">-1</span>)+m*<span class="built_in">F</span>(n<span class="number">-1</span>,m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,m;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">if</span>(m==<span class="number">1</span>||m==n)</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;1&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	<span class="keyword">if</span>(m==<span class="number">0</span>||n==<span class="number">0</span>||n&lt;m)</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;ÊäÈë´íÎó£¡&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	cout&lt;&lt;<span class="built_in">F</span>(n<span class="number">-1</span>,m<span class="number">-1</span>)+m*<span class="built_in">F</span>(n<span class="number">-1</span>,m)&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="设计思想-1"><a href="#设计思想-1" class="headerlink" title="设计思想"></a>设计思想</h3><p>将待求解的问题分解成若干的子问题，先去求解子问题，再结合这些子问题的解得到原问题的解。动态规划中的子问题往往不是相互独立的。</p>
<h3 id="解题步骤-1"><a href="#解题步骤-1" class="headerlink" title="解题步骤"></a>解题步骤</h3><ol>
<li>找出最优解的性质，并刻画其结构特征</li>
<li>递归的定义最优值</li>
<li>以自底向上的方式设计最优值</li>
<li>根据计算最优值时得到的信息，构造最优解</li>
</ol>
<h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p>
<ol>
<li>能够得到全局最优解；</li>
<li>可以得到一族最优解；</li>
<li>由于动态规划方法反映了动态过程演变的联系和特征，在计算时可以利用实际知识和经验提高求解效率。</li>
</ol>
<p>缺点：</p>
<ol>
<li>没有统一的标准模型；</li>
<li>数值方法求解时存在维数灾。（需要额外的内存空间，并且一维问题可能需要二维空间）</li>
</ol>
<h3 id="特征-1"><a href="#特征-1" class="headerlink" title="特征"></a>特征</h3><ol>
<li>最优子结构</li>
<li>重叠子问题</li>
</ol>
<h3 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0 1背包问题"></a>0 1背包问题</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p><strong>有n个物品，它们有各自的体积和价值，现有给定容量的背包，如何让背包里装入的物品具有最大的价值总和？</strong></p>
<p>为方便讲解和理解，下面讲述的例子均先用具体的数字代入，即：eg：number＝4，capacity＝8<br><img src="https://img-blog.csdnimg.cn/20190810164615141.png" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/20190810164615141.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述"></p>
<h4 id="总体思路"><a href="#总体思路" class="headerlink" title="总体思路"></a>总体思路</h4><p>根据动态规划解题步骤（问题抽象化、建立模型、寻找约束条件、判断是否满足最优性原理、找大问题与小问题的递推关系式、填表、寻找解组成）找出01背包问题的最优解以及解组成，然后编写代码实现。</p>
<h4 id="动态规划的原理"><a href="#动态规划的原理" class="headerlink" title="动态规划的原理"></a>动态规划的原理</h4><p>动态规划与分治法类似，都是把大问题拆分成小问题，通过寻找大问题与小问题的递推关系，解决一个个小问题，最终达到解决原问题的效果。但不同的是，分治法在子问题和子子问题等上被重复计算了很多次，而动态规划则具有记忆性，<strong>通过填写表把所有已经解决的子问题答案纪录下来，在新问题里需要用到的子问题可以直接提取，避免了重复计算，从而节约了时间，所以在问题满足最优性原理之后，用动态规划解决问题的核心就在于填表，表填写完毕，最优解也就找到。</strong></p>
<p>最优性原理是动态规划的基础，最优性原理是指“多阶段决策过程的最优决策序列具有这样的性质：<strong>不论初始状态和初始决策如何，对于前面决策所造成的某一状态而言，其后各阶段的决策序列必须构成最优策略”。</strong></p>
<h4 id="背包问题的解决过程"><a href="#背包问题的解决过程" class="headerlink" title="背包问题的解决过程"></a>背包问题的解决过程</h4><p>在解决问题之前，为描述方便，首先定义一些变量：<strong>Vi表示第 i 个物品的价值，Wi表示第 i 个物品的体积，定义V(i,j)：当前背包容量 j，前 i 个物品最佳组合对应的价值</strong>，同时背包问题抽象化（X1，X2，…，Xn，其中 Xi 取0或1，表示第 i 个物品选或不选）。</p>
<p><em>1、建立模型，即求max(V1X1+V2X2+…+VnXn)；</em></p>
<p><em>2、寻找约束条件，W1X1+W2X2+…+WnXn&lt;capacity；</em></p>
<p><em>3、寻找递推关系式，面对当前商品有两种可能性：</em></p>
<ul>
<li><strong>包的容量比该商品体积小，装不下，此时的价值与前i-1个的价值是一样的，即V(i,j)=V(i-1,j)；</strong></li>
<li><strong>还有足够的容量可以装该商品，但装了也不一定达到当前最优价值，所以在装与不装之间选择最优的一个，即V(i,j)=max｛V(i-1,j)，V(i-1,j-w(i))+v(i)｝。</strong></li>
</ul>
<hr>
<p>其中V(i-1,j)表示不装，V(i-1,j-w(i))+v(i) 表示装了第i个商品，背包容量减少w(i)，但价值增加了v(i)；</p>
<p>由此可以得出递推关系式：</p>
<ul>
<li>j&lt;w(i) V(i,j)=V(i-1,j)</li>
<li>j&gt;=w(i) V(i,j)=max｛V(i-1,j)，V(i-1,j-w(i))+v(i)｝</li>
</ul>
<hr>
<p>这里需要解释一下，为什么能装的情况下，需要这样求解（这才是本问题的关键所在！）：</p>
<p>可以这么理解，<strong>如果要到达V(i,j)这一个状态有几种方式</strong>？</p>
<p><strong>肯定是两种，第一种是第i件商品没有装进去，第二种是第i件商品装进去了</strong>。没有装进去很好理解，就是V(i-1,j)；装进去了怎么理解呢？如果装进去第i件商品，那么装入之前是什么状态，肯定是V(i-1,j-w(i))。由于最优性原理（上文讲到），V(i-1,j-w(i))就是前面决策造成的一种状态，后面的决策就要构成最优策略。两种情况进行比较，得出最优。</p>
<p>4、填表，首先初始化边界条件，V(0,j)=V(i,0)=0；</p>
<p><img src="https://img-blog.csdnimg.cn/20190810165633366.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NzY3NDU1,size_16,color_FFFFFF,t_70" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/20190810165633366.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NzY3NDU1,size_16,color_FFFFFF,t_70" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述"></p>
<p>然后一行一行的填表：</p>
<ul>
<li>如，i=1，j=1，w(1)=2，v(1)=3，有j&lt;w(1)，故V(1,1)=V(1-1,1)=0；</li>
<li>又如i=1，j=2，w(1)=2，v(1)=3，有j=w(1),故V(1,2)=max｛<br>V(1-1,2)，V(1-1,2-w(1))+v(1) ｝=max｛0，0+3｝=3；</li>
<li>如此下去，填到最后一个，i=4，j=8，w(4)=5，v(4)=6，有j&gt;w(4)，故V(4,8)=max｛<br>V(4-1,8)，V(4-1,8-w(4))+v(4) ｝=max｛9，4+6｝=10……</li>
</ul>
<hr>
<p>所以填完表如下图：</p>
<p><img src="https://img-blog.csdnimg.cn/20190810165740701.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NzY3NDU1,size_16,color_FFFFFF,t_70" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/20190810165740701.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NzY3NDU1,size_16,color_FFFFFF,t_70" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述"></p>
<p>5、表格填完，最优解即是V(number,capacity)=V(4,8)=10。</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>为了和之前的动态规划图可以进行对比，尽管只有4个商品，但是我们创建的数组元素由5个。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> w[<span class="number">5</span>] = &#123; <span class="number">0</span> , <span class="number">2</span> , <span class="number">3</span> , <span class="number">4</span> , <span class="number">5</span> &#125;;			<span class="comment">//商品的体积2、3、4、5</span></span><br><span class="line">	<span class="keyword">int</span> v[<span class="number">5</span>] = &#123; <span class="number">0</span> , <span class="number">3</span> , <span class="number">4</span> , <span class="number">5</span> , <span class="number">6</span> &#125;;			<span class="comment">//商品的价值3、4、5、6</span></span><br><span class="line">	<span class="keyword">int</span> bagV = <span class="number">8</span>;					        <span class="comment">//背包大小</span></span><br><span class="line">	<span class="keyword">int</span> dp[<span class="number">5</span>][<span class="number">9</span>] = &#123; &#123; <span class="number">0</span> &#125; &#125;;			        <span class="comment">//动态规划表</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= bagV; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (j &lt; w[i])</span><br><span class="line">				dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - w[i]] + v[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//动态规划表的输出</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">			cout &lt;&lt; dp[i][j] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="矩阵连乘问题"><a href="#矩阵连乘问题" class="headerlink" title="矩阵连乘问题"></a>矩阵连乘问题</h3><p>输入：n个矩阵A1,A2,…,An，其中Ai的维数为pi-1×pi<br>Ai 和Ai+1是可乘的</p>
<p>输出：连乘积A1A2A3…An</p>
<p>优化目标：最小计算代价（最优的计算次序）</p>
<p>矩阵乘法的代价：乘法次数<br>若A 是p ×q 矩阵，B 是q ×r 矩阵，则A ×B 的代价是pqr<br>因为矩阵乘法满足结合律，因此矩阵连乘可以由不同的计算次序，这种计算次序可以用加括号来表示。<br>1<br>2<br>3<br>三个矩阵A1: 10×100, A2: 100×5，A3: 5×50<br>(A1A2)A3<br>代价：10×100×5＋10×5×50＝7500<br>A1(A2A3)<br>代价：100×5×50＋10×100×50＝75000</p>
<p>可见不同的计算次序会导致不同的计算代价，我们要做的就是让这个代价最小。</p>
<p>我们自然可以用穷举法计算每次不同的结合次序带来的不同代价，然后取最小值，但是这样我们得到的复杂度将达到<img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220110233227.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220110233227.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220110233219445" style="zoom: 50%;" /></p>
<h4 id="分析最优解结构"><a href="#分析最优解结构" class="headerlink" title="分析最优解结构"></a>分析最优解结构</h4><p>将矩阵连乘积AiAi+1…Aj，记为A[i:j]</p>
<p>设AiAi+1…Aj的最优计算次序在矩阵Ak和Ak+1之间将矩阵链断开得到：(Ai… Ak) (Ak+1 …Aj)</p>
<p>总的计算量就是：A[i:k]的计算量＋A[k+1: j]的计算量+A[i:k]和A[k+1:j]相乘的计算量</p>
<p>建立的递归关系就是</p>
<p>计算A[i:j]所需的最小乘法次数为m（i，j）</p>
<img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220110233204.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220110233204.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220110233201035" style="zoom:67%;" />

<p>其中Ai是Pi-1 x Pi的矩阵</p>
<p>接下来我们借助填表过程理解递归的过程，现在给出下列矩阵：</p>
<img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220110233151.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220110233151.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220110233147786" style="zoom:67%;" />


<p>填表过程是按对角线填写的，只利用到了二维数组的右上角一部分。</p>
<p>根据地推公式，我们可以知道，在i=j时m=0，所以先构造出最长的对角线部分的数据，如下图：</p>
<img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220110233133.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220110233133.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220110233130168" style="zoom:67%;" />


<p>现在我们继续构造，<br>m（1,2）=min{m[1][1]+m[2][2]+p0p1p2}={0+0+303515}=15750</p>
<p>m(2,3) = min(m[2][2]+m[3][3]+p1p2p3=0+0+35155）=2625</p>
<p>同理，后面不再一一列举；</p>
<p>再多说一点，有时我们会遇到有多个划分，我们取最小值就可以了，</p>
<p>例如：m（1,4）=min{m[1][2]+m[3][4]+p0p2p4 或者是 m[1][1]+m[2][4]+p0p1p4或者是m[1][3]+m[4][4]+p0p3p4}，其中的值已经在前面求出来了，这也是动态规划要记录所有值的原因。</p>
<p>结果图如下：读者可以自行计算验证。</p>
<img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220110233114.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220110233114.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220110233110648" style="zoom:67%;" />


<p>那么，我们最后如何得知是哪个地方要加括号呢？<br>根据最后的公式。</p>
<p>例如，假设最后的m[1:6]=m[1,1]+m[2][6]+p0p2p6（笔者构造的，跟上面的例子没关系），那么我们就知道是（A1(A2A3A4A5A6)）,再看m[2:6],根据公式找退出括号位置，一直推到最后即可。</p>
<p>我们不难发现，加括号的位置其实就是k 的对应序号的矩阵，在写算法时我们就可以用另外的数组记录下对应位置的k值。在最后输出时把这个数组按逻辑输出。</p>
<p>最终这个算法的复杂度</p>
<img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220110233056.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220110233056.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220110233043532" style="zoom:50%;" />

<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> A[N];<span class="comment">//矩阵规模</span></span><br><span class="line"><span class="keyword">int</span> m[N][N];<span class="comment">//最优解</span></span><br><span class="line"><span class="keyword">int</span> s[N][N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MatrixChain</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> r, i, j, k;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= n; i++)<span class="comment">//初始化对角线</span></span><br><span class="line">	&#123;</span><br><span class="line">		m[i][i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (r = <span class="number">2</span>; r &lt;= n; r++)<span class="comment">//r个矩阵连乘</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n - r + <span class="number">1</span>; i++)<span class="comment">//r个矩阵的r-1个空隙中依次测试最优点</span></span><br><span class="line">		&#123;</span><br><span class="line">			j = i + r - <span class="number">1</span>;</span><br><span class="line">			m[i][j] = m[i][i]+m[i + <span class="number">1</span>][j] + A[i - <span class="number">1</span>] * A[i] * A[j];</span><br><span class="line">			s[i][j] = i;</span><br><span class="line">			<span class="keyword">for</span> (k = i + <span class="number">1</span>; k &lt; j; k++)<span class="comment">//变换分隔位置，逐一测试</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> t = m[i][k] + m[k + <span class="number">1</span>][j] + A[i - <span class="number">1</span>] * A[k] * A[j];</span><br><span class="line">				<span class="keyword">if</span> (t &lt; m[i][j])<span class="comment">//如果变换后的位置更优，则替换原来的分隔方法。</span></span><br><span class="line">				&#123;</span><br><span class="line">					m[i][j] = t;</span><br><span class="line">					s[i][j] = k;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (i == j)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;A[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;]&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;(&quot;</span>;</span><br><span class="line">	<span class="built_in">print</span>(i, s[i][j]);</span><br><span class="line">	<span class="built_in">print</span>(s[i][j] + <span class="number">1</span>, j);<span class="comment">//递归1到s[1][j]</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;<span class="comment">//n个矩阵</span></span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; A[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">MatrixChain</span>(n);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;最佳添加括号的方式为：&quot;</span>;</span><br><span class="line">	<span class="built_in">print</span>(<span class="number">1</span>, n);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\n最小计算量的值为：&quot;</span> &lt;&lt; m[<span class="number">1</span>][n] &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><h3 id="设计思想-2"><a href="#设计思想-2" class="headerlink" title="设计思想"></a>设计思想</h3><p>​        贪心算法总是作出在当前看来最好的选择。也就是说贪心算法并不从整体最优考虑，它所作出的选择只是在某种意义上的局部最优选择。当然，希望贪心算法得到的最终结果也是整体最优的。虽然贪心算法不能对所有问题都得到整体最优解，但对许多问题它能产生整体最优解。如单源最短路经问题，最小生成树问题等。在一些情况下，即使贪心算法不能得到整体最优解，其最终结果却是最优解的很好近似。</p>
<h3 id="解题步骤-2"><a href="#解题步骤-2" class="headerlink" title="解题步骤"></a>解题步骤</h3><ol>
<li>建立数学模型来描述问题。</li>
<li>把求解的问题分成若干个子问题。</li>
<li>对每个子问题求解，得到子问题的局部最优解。</li>
<li>把子问题的解局部最优解合成原来解问题的一个解。</li>
</ol>
<h3 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p>
<ol>
<li>算法简单</li>
<li>时间和空间复杂度低</li>
</ol>
<p>缺点：</p>
<ol>
<li>一些情况下不能得到最优解</li>
</ol>
<h3 id="特征-2"><a href="#特征-2" class="headerlink" title="特征"></a>特征</h3><ol>
<li><p>贪心选择性质：局部最优解能够得到整体最优解。（通常需要证明）</p>
</li>
<li><p>最优子结构性质：该问题可以分解为若干个规模较小的相同问题</p>
</li>
</ol>
<h3 id="与动态规划"><a href="#与动态规划" class="headerlink" title="与动态规划"></a>与动态规划</h3><ol>
<li><p>共同点：</p>
<ol>
<li><p>都需要最优子结构性质，</p>
</li>
<li><p>都用来求有优化问题。</p>
</li>
</ol>
</li>
<li><p>不同点：</p>
<ol>
<li>动态规划：每一步作一个选择—依赖于子问题的解。<br>贪心方法：每一步作一个选择—不依赖于子问题的解。</li>
<li>动态规划方法的条件：子问题的重叠性质。<br>可用贪心方法的条件：最优子结构性质；贪心选择性质。</li>
<li>动态规划：自底向上求解；<br>贪心方法： 自顶向下求解。</li>
<li>可用贪心法时，动态规划方法可能不适用；<br>可用动态规划方法时，贪心法可能不适用。</li>
</ol>
</li>
</ol>
<h3 id="会场安排问题"><a href="#会场安排问题" class="headerlink" title="会场安排问题"></a>会场安排问题</h3><h4 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h4><p>设有n个会议的集合C={1,2,…,n}，其中每个会议都要求使用同一个资源（如会议室），而在同一时间内只能有一个会议使用该资源。每个会议i都有要求使用该资源的起始时间bi和结束时间ei，且bi &lt; ei 。如果选择了会议i使用会议室，则它在半开区间[bi, ei)内占用该资源。如果[bi, ei)与[bj , ej)不相交，则称会议i与会议j是相容的。会场安排问题要求在所给的会议集合中选出最大的相容活动子集，也即尽可能地选择更多的会议来使用资源。</p>
<h4 id="贪心策略"><a href="#贪心策略" class="headerlink" title="贪心策略"></a>贪心策略</h4><p>选择最早开始时间且不与已安排会议重叠的会议</p>
<p>选择使用时间最短且不与已安排会议重叠的会议</p>
<p>选择具有最早结束时间且不与已安排会议重叠的会议  </p>
<p>这里，我们要尽可能多的安排会议，显然采取贪最早结束时间的策略。</p>
<h4 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h4><p>步骤1：初始化。开始时间存入数组B；结束时间存入数组E中且按照结束时间的非减序排序，B相应调整；集合A存储解，会议i如果在集合A中，当且仅当A[i]=true；</p>
<p>步骤2：根据贪心策略，首令A[1]=true；</p>
<p>步骤3：依次扫描每一个会议，如果会议i的开始时间不小于最后一个选入A中的会议的结束时间，则将会议i加入A中；否则，放弃，继续检查下一个会议与A中会议的相容性。</p>
<p>示例：设有11个会议等待安排，用贪心法找出满足目标要求的会议集合。这些会议按结束时间的非减序排列如表所示。</p>
<img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220110233558.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220110233558.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220110233549281" style="zoom: 33%;" />

<h4 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h4><p>设会议i的起始时间bi和结束时间ei的数据类型为整形（限制在整点）；则GreedySelector算法描述如下：</p>
<p>Void GreedySelector(int n,int b[ ],int e[ ],bool A[ ])<br>{<br>    e中元素按非递减序排列，b中对应元素做相应调整;<br>    int I,j;<br>    A[1]=true;                    //初始化选择会议的集合A，只包含会议1；<br>    j=1;i=2;                       //从第二(i)个会议开始寻找与会议1(j)相容的会议；<br>    while(i&lt;=n)<br>            if(b[i]&gt;=e[j])<br>                {A[i]=true;j=I;}<br>            else<br>                  A[i]=false;<br>}                                      </p>
<p>该算法的时间复杂度为排序的复杂度：O(nlogn)，空间复杂度为常数阶：O(1)</p>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GreedySelector</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> B[], <span class="keyword">int</span> E[], <span class="keyword">bool</span> A[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">time</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> B[], <span class="keyword">int</span> E[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;请输入会议总数:&quot;</span>;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">int</span> B[n],E[n];</span><br><span class="line">	<span class="keyword">bool</span> A[n];</span><br><span class="line"> </span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;请输入所有会议开始时间和结束时间：例如 1 4&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">	    cin&gt;&gt;B[i];</span><br><span class="line">	    cin&gt;&gt;E[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">	    A[i] = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">time</span>(n,B,E);</span><br><span class="line">	<span class="built_in">GreedySelector</span>(n,B,E,A);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">time</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> B[],<span class="keyword">int</span> E[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,temp1,temp2;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;n+<span class="number">1</span>;j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n+<span class="number">1</span>-j;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(E[i]&gt;E[i+<span class="number">1</span>])&#123;</span><br><span class="line">                temp1 = E[i];</span><br><span class="line">                E[i] = E[i+<span class="number">1</span>];</span><br><span class="line">                E[i+<span class="number">1</span>] = temp1;</span><br><span class="line">                temp2 = B[i];</span><br><span class="line">                B[i] = B[i+<span class="number">1</span>];</span><br><span class="line">                B[i+<span class="number">1</span>] = temp2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;按结束时间排序后的会议排列表:&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cout&lt;&lt;i&lt;&lt;<span class="string">&quot;  &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cout&lt;&lt;B[i]&lt;&lt;<span class="string">&quot;  &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cout&lt;&lt;E[i]&lt;&lt;<span class="string">&quot;  &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GreedySelector</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> B[], <span class="keyword">int</span> E[], <span class="keyword">bool</span> A[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    A[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">    j=<span class="number">1</span>;i=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(B[i]&gt;=E[j])&#123;</span><br><span class="line">            A[i] = <span class="literal">true</span>;</span><br><span class="line">            j = i;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            A[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;会议集合为&#123;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i])&#123;</span><br><span class="line">            cout&lt;&lt;i&lt;&lt;<span class="string">&quot;,&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;&#125;&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="程序存储问题"><a href="#程序存储问题" class="headerlink" title="程序存储问题"></a>程序存储问题</h3><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220110233929.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220110233929.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220110233922801" style="zoom:67%;" />

<h4 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h4><p>条件：磁盘空间有限；程序大小不同。</p>
<p>在有限的磁盘上存放尽可能多的程序，就要求选择的程序尽可能小。</p>
<h4 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h4><p>贪心算法：总是从可选程序中选择最小的试放入磁盘。</p>
<p>\1. 排序：对程序按大小升序排；</p>
<p>\2. 循环添加：从i = 1开始，选择排序后序列的第 i 个（即a[i]，1 &lt;= i &lt;= n）个加入暂存（sum，初始为0），判断是否满足sum小于磁盘空间，是则计数（count++），否则跳出循环；</p>
<p>反证法证明贪心选择可以推出最优解：</p>
<p>\1. 证明选择可以从贪心（最小程序）开始：选择从最小程序开始即解不为空时可以选择最小程序。假设解不为空，从这样得到的选择序列中任选一个，用最小程序替换，放入程序数（count）不变；</p>
<p>\2. 证明最优子结构性质：在解不为空、第一次可以选择最小程序的前提下，假设在最优解中去掉第一次选择的最小程序后得到的子问题的最优解的count_0大于原问题最优解的count_1-1，那么将最小程序加入选择产生的解的count_2大于count_1，此时count_1不是最优解，这不成立。故此问题具有最优子结构性质。</p>
<h4 id="时间和空间复杂度分析"><a href="#时间和空间复杂度分析" class="headerlink" title="时间和空间复杂度分析"></a>时间和空间复杂度分析</h4><p>时间复杂度：程序进行了一次快排（O(nlogn)）和循环（O(n)），故时间复杂度为O(nlogn)；</p>
<p>空间复杂度：程序new了一个一维数组（a[n]）用于存放每个程序的大小，故时间复杂度为O(n)。</p>
<h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Greedy</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n,<span class="keyword">int</span> L)</span></span>&#123;</span><br><span class="line">	<span class="built_in">sort</span>(a,a+n);</span><br><span class="line">	<span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;<span class="comment">//最后一个元素为下标n-1的元素</span></span><br><span class="line">		temp = temp + a[i];</span><br><span class="line">		<span class="keyword">if</span> (temp&gt;L) <span class="keyword">return</span> i;</span><br><span class="line">		<span class="keyword">if</span>(i==(n<span class="number">-1</span>)) <span class="keyword">return</span> n;	<span class="comment">//就是缺了这里搞了很久，没有想到还有存得完的情况。也可以为return i+1 保持上下统一性。</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">int</span> L;</span><br><span class="line">	cin&gt;&gt;L;</span><br><span class="line">	<span class="keyword">int</span> *a=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">		&#125;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">Greedy</span>(a,n,L); </span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h2><h3 id="设计思想-3"><a href="#设计思想-3" class="headerlink" title="设计思想"></a>设计思想</h3><p>回溯法也称为试探法，首先暂时放弃关于问题规模大小的限制，并将问题的候选解按某种顺序逐一枚举和检验。</p>
<ol>
<li><p>【回溯】当发现当前候选解不可能是解时，就选择下一个候选解；</p>
</li>
<li><p>【向前试探】倘若当前候选解除了还不满足问题规模要求外，满足所有其他要求时，继续扩大当前候选解的规模，并继续试探。</p>
</li>
<li><p>【找到解】如果当前候选解满足包括问题规模在内的所有要求时，该候选解就是问题的一解。</p>
</li>
</ol>
<blockquote>
<p>在解空间中搜索可行解或最优解的技术<br>以深度优先遍历进行搜索以避免遗漏可行解<br>以跳跃式搜索改善算法的运行效率 （剪枝：不满足约束条件的内节点的子树）</p>
</blockquote>
<h3 id="解题步骤-3"><a href="#解题步骤-3" class="headerlink" title="解题步骤"></a>解题步骤</h3><ol>
<li>针对具体问题，定义问题的解空间；</li>
<li>确定易于搜索的解空间结构（数据结构的选择）。</li>
<li>一般以DFS的方式搜索解空间。</li>
<li>在搜索过程中，可以使用剪枝函数等来优化算法。</li>
</ol>
<h3 id="算m点问题"><a href="#算m点问题" class="headerlink" title="算m点问题"></a>算m点问题</h3><h4 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h4><p>给定k个正整数，用算术运算符+，-，*，/将这个k接起来，使最终的复数恰为m</p>
<p>算法设计：对于任意给定的k个整数，给出计算m的算术表达式。若无解，则输出“No solution!”</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>在进行回溯的时候对于每一个数都可以选择用或者不用，如果用的话则有加、减、乘、除四种情况</p>
<p>用的时候分别对这四种进行回溯，如果最终有解的话则把当前计算的式子保存到栈中，最后一次性输出</p>
<p>用visit数组标记每个数是否使用过，用flag标记是否有解</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;             <span class="comment">//数的个数</span></span><br><span class="line"><span class="keyword">int</span> m;             <span class="comment">//目标数</span></span><br><span class="line"><span class="keyword">int</span> *nums;         <span class="comment">//n个数</span></span><br><span class="line"><span class="keyword">bool</span> *visit;       <span class="comment">//标记是否使用</span></span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">false</span>; <span class="comment">//标记是否有解</span></span><br><span class="line"></span><br><span class="line">stack&lt;string&gt; s;</span><br><span class="line">string str;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> dept, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dept &gt; n - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == m)</span><br><span class="line">        &#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (visit[i] == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            stringstream ss;</span><br><span class="line">            visit[i] = <span class="literal">true</span>; <span class="comment">//使用该数</span></span><br><span class="line">        	<span class="keyword">if</span> (<span class="built_in">backtrack</span>(dept + <span class="number">1</span>, value + nums[i]) &amp;&amp; dept != <span class="number">0</span>)</span><br><span class="line">        	&#123;</span><br><span class="line">            	ss &lt;&lt; value &lt;&lt; <span class="string">&quot;+&quot;</span> &lt;&lt; nums[i] &lt;&lt; <span class="string">&quot;=&quot;</span> &lt;&lt; value + nums[i];</span><br><span class="line">            	ss &gt;&gt; str;</span><br><span class="line">            	s.<span class="built_in">push</span>(str);</span><br><span class="line">            	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        	&#125;</span><br><span class="line">        	<span class="keyword">if</span> (<span class="built_in">backtrack</span>(dept + <span class="number">1</span>, value - nums[i]) &amp;&amp; dept != <span class="number">0</span>)</span><br><span class="line">        	&#123;</span><br><span class="line">            	ss &lt;&lt; value &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; nums[i] &lt;&lt; <span class="string">&quot;=&quot;</span> &lt;&lt; value - nums[i];</span><br><span class="line">            	ss &gt;&gt; str;</span><br><span class="line">            	s.<span class="built_in">push</span>(str);</span><br><span class="line">            	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        	&#125;</span><br><span class="line">        	<span class="keyword">if</span> (<span class="built_in">backtrack</span>(dept + <span class="number">1</span>, value * nums[i]) &amp;&amp; dept != <span class="number">0</span>)</span><br><span class="line">        	&#123;</span><br><span class="line">            	ss &lt;&lt; value &lt;&lt; <span class="string">&quot;*&quot;</span> &lt;&lt; nums[i] &lt;&lt; <span class="string">&quot;=&quot;</span> &lt;&lt; value * nums[i];</span><br><span class="line">            	ss &gt;&gt; str;</span><br><span class="line">            	s.<span class="built_in">push</span>(str);</span><br><span class="line">            	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        	&#125;</span><br><span class="line">        	<span class="keyword">if</span> (<span class="built_in">backtrack</span>(dept + <span class="number">1</span>, value / nums[i]) &amp;&amp; dept != <span class="number">0</span>)</span><br><span class="line">        	&#123;</span><br><span class="line">            	ss &lt;&lt; value &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; nums[i] &lt;&lt; <span class="string">&quot;=&quot;</span> &lt;&lt; value / nums[i];</span><br><span class="line">            	ss &gt;&gt; str;</span><br><span class="line">            	s.<span class="built_in">push</span>(str);</span><br><span class="line">            	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        	&#125;</span><br><span class="line">        	visit[i] = <span class="literal">false</span>; <span class="comment">//不使用该数</span></span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    nums = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    visit = <span class="keyword">new</span> <span class="keyword">bool</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; nums[i];</span><br><span class="line">        visit[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">backtrack</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!s.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; s.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No solution!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] nums;</span><br><span class="line">    <span class="keyword">delete</span>[] visit;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="世界名画陈列馆"><a href="#世界名画陈列馆" class="headerlink" title="世界名画陈列馆"></a>世界名画陈列馆</h3><h4 id="Description"><a href="#Description" class="headerlink" title="Description:"></a>Description:</h4><p> 世界名画陈列馆由m´n个排列成矩形阵列的陈列室组成。为了防止名画被盗，需要在陈列室中设置警卫机器人哨位。每个警卫机器人除了监视它所在的陈列室外，还可以监视与它所在的陈列室相邻的上、下、左、右4 个陈列室。试设计一个安排警卫机器人哨位的算法，<br>使得名画陈列馆中每一个陈列室都在警卫机器人的监视之下，且所用的警卫机器人数最少。</p>
<p>设计一个优先队列式分支限界法，计算警卫机器人的最佳哨位安排，使得名画陈列馆中每一个陈列室都在警卫机器人的监视之下，且所用的警卫机器人数最少。</p>
<p>Input:<br>第一行有2 个正整数m和n (1≤m,n≤20)<br>Output:<br> 将计算出的警卫机器人数及其最佳哨位安排输出。第一行是警卫机器人数；接下来的m行中每行n个数，0 表示无哨位，1 表示哨位。<br>Sample Input:<br>4 4<br>Copy<br>Sample Output:<br>4<br>0 0 1 0<br>1 0 0 0<br>0 0 0 1<br>0 1 0 0</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>当y[i][j+1]==1时，以q为根的子树的解，不优于以p为根的子树的解，</p>
<p>当y[i][j+1]==1且y[i][j+2]==1时，以r为根的子树的解，不优于以p为根的子树的解。</p>
<p>搜索时应按照p、q、r或p、r、q的顺序来扩展结点。</p>
<p><strong>剪枝策略:</strong></p>
<p>放置的机器人个数不会超过n<em>m/3+1个(按每个机器人仅辐射左右或上下考虑，堆叠这样的小长条可得)。以n</em>m/3+2为初始最优值，当放置的个数超过当前最优值时，剪去。<br>(当前最优值ans-当前已放置个数p)<em>5（最多能增加5个监视点）。如果小于未监视的格点数（n</em>m-spys），则一定达不到比当前最优值更好的情况，剪去。</p>
<h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n,m,f[<span class="number">5</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;; <span class="comment">//自己本身+上下左右 </span></span><br><span class="line"><span class="keyword">int</span> anx[<span class="number">30</span>][<span class="number">30</span>],ans; <span class="comment">//最优结果 ans-警卫个数 anx-警卫位置 </span></span><br><span class="line"><span class="keyword">int</span> put[<span class="number">30</span>][<span class="number">30</span>],p; <span class="comment">//暂时存储 p-警卫个数 put-警卫位置 </span></span><br><span class="line"><span class="keyword">int</span> spy[<span class="number">30</span>][<span class="number">30</span>],spys; <span class="comment">//spy-被监视的展柜位置 spys-被监视的展柜个数 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">puta</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p&gt;=ans) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;=n&amp;&amp;spy[i][j]) <span class="comment">//已放置的不再被搜索</span></span><br><span class="line">	&#123;</span><br><span class="line">		j++;</span><br><span class="line">		<span class="keyword">if</span>(j&gt;m)	i++,j=<span class="number">1</span>; <span class="comment">//换行 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(i&gt;n) <span class="comment">//更新答案</span></span><br><span class="line">	&#123;</span><br><span class="line">		ans=p;</span><br><span class="line">		<span class="built_in">memcpy</span>(anx, put, <span class="keyword">sizeof</span>(put)); <span class="comment">//把put内容复制给anx </span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//剪枝</span></span><br><span class="line">    <span class="keyword">if</span>((ans-p)*<span class="number">5</span>&lt;=n*m-spys) <span class="keyword">return</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span>(i&lt;n) puta(i+<span class="number">1</span>,j,i,j);</span><br><span class="line">    <span class="keyword">if</span>(spy[i][j+<span class="number">1</span>]==<span class="number">0</span>) puta(i,j,i,j);</span><br><span class="line">    <span class="keyword">if</span>(j&lt;m&amp;&amp;(spy[i][j+<span class="number">1</span>]==<span class="number">0</span>||spy[i][j+<span class="number">2</span>]==<span class="number">0</span>)) puta(i,j+<span class="number">1</span>,i,j);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">puta</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> c,<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	put[x][y]=<span class="number">1</span>;</span><br><span class="line">	p++;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> xx=x+f[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> yy=y+f[i][<span class="number">1</span>];</span><br><span class="line">        spy[xx][yy]++;</span><br><span class="line">        <span class="keyword">if</span>(spy[xx][yy]==<span class="number">1</span>) spys++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	search(c,d+<span class="number">1</span>);</span><br><span class="line">	 </span><br><span class="line">	put[x][y] = <span class="number">0</span>;</span><br><span class="line">	p--;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="keyword">int</span> xx=x+f[i][<span class="number">0</span>];</span><br><span class="line">	    <span class="keyword">int</span> yy=y+f[i][<span class="number">1</span>];</span><br><span class="line">	    spy[xx][yy]--;</span><br><span class="line">	    <span class="keyword">if</span>(spy[xx][yy]==<span class="number">0</span>) spys--;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	ans=n*m/<span class="number">3</span>+<span class="number">2</span>;</span><br><span class="line">	p=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">//设置边界 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n+<span class="number">1</span>;i++)</span><br><span class="line">	spy[i][<span class="number">0</span>]=spy[i][m+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m+<span class="number">1</span>;i++)</span><br><span class="line">	spy[<span class="number">0</span>][i]=spy[n+<span class="number">1</span>][i]=<span class="number">1</span>;</span><br><span class="line">	search(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,anx[i][j]);</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="加法链"><a href="#加法链" class="headerlink" title="加法链"></a>加法链</h3><h4 id="问题描述-5"><a href="#问题描述-5" class="headerlink" title="问题描述"></a>问题描述</h4><p>最优求幂问题:给定一个正整数n和一个实数x，如何用最少的乘法次数计算出xn 。 例如，可以用 6 次乘法逐步计算 x23 如下: x，x2，x3，x5，x10，x20，x23 。可以证明 计算 x23 最少需要 6 次乘法。计算 x23 的幂序列中各幂次 1，2，3，5，10，20，23 组成了一 个关于整数 23 的加法链。在一般情况下，计算 xn 的幂序列中各幂次组成正整数 n 的一个加法链：<br>1=a0&lt;a1&lt;a2&lt;…&lt;ar=n</p>
<p>ai=aj+ak,k≤j&lt;i,i=1,2,…,r</p>
<p>上述最优求幂问题相应于正整数 n 的最短加法链问题，即求 n 的一个加法链使其长度 r 达到最小。正整数n的最短加法链长度记为l(n)。</p>
<p>对于给定的正整数 n ，编程计算相应于正整数 n 的最短加法链。</p>
<p>数据输入：<br>第 1 行有 1 个正整数 n。</p>
<h4 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h4><p>使用深搜相对于广搜的有点之处在于空间复杂度上会有优化，每一条深度上的路径只需要保存该路径即可。但是当加法链扩散出去后，时间复杂度上会程指数增长，所以得加以剪枝函数。<br>一开始考虑较为简单的剪枝函数，即当当前搜索的层数小于已经搜出的最短答案时返回。即当l&gt;=ans的时候返回。<br>但是该剪枝效果也不是很好，当n大于200时，时间明显增长。之后我选择了另一种剪枝，剪枝效果更好。<br>假设当前搜到的层数为l，当前搜到的数为t目标数为n，则从t到n最短的加法链则是t-&gt;t<em>2-&gt;t</em>4..-&gt;n，即每次都乘2，长度是,所以当l+log2(n/t)&lt;=ans,就可以返回了。没必要每次都运算，而对于这个长度，可以实现打出从i到j的最短路径长度以供每次直接以o(1)复杂度获取。</p>
<h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 10005 </span></span><br><span class="line"><span class="keyword">int</span> a[MAX],r[MAX], b[<span class="number">2</span>*MAX];</span><br><span class="line"><span class="keyword">int</span> n,ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    ans = n;</span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=n; i&lt;=n+n; i++)</span><br><span class="line">    b[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=n<span class="number">-1</span>; i&gt;<span class="number">0</span>; i--)</span><br><span class="line">    b[i]=b[i+i]+<span class="number">1</span>;               <span class="comment">//b[i]中记录着到当前数最短的距离数</span></span><br><span class="line">&#125; </span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">printf</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> i;</span><br><span class="line">      <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;ans; i++)</span><br><span class="line">      		cout&lt;&lt;r[i]&lt;&lt;” “;</span><br><span class="line">      cout&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">			  cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> l)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> i, k;</span><br><span class="line">      <span class="keyword">if</span>(l+b[a[l]]&gt;=ans)</span><br><span class="line">      		<span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">if</span>(a[l]==n)</span><br><span class="line">      &#123;</span><br><span class="line">       		ans = l;</span><br><span class="line">      		<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;l; i++)</span><br><span class="line">      			r[i]=a[i];</span><br><span class="line">      		<span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span>(i=l; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">      		<span class="keyword">for</span>(k=i; k&gt;=<span class="number">0</span>; k--)</span><br><span class="line">      		&#123;</span><br><span class="line">       			a[l+<span class="number">1</span>]=a[i]+a[k];</span><br><span class="line">        		<span class="keyword">if</span>(a[l+<span class="number">1</span>]&gt;a[l]&amp;&amp;a[l+<span class="number">1</span>]&lt;=n)</span><br><span class="line">        		<span class="built_in">dfs</span>(l+<span class="number">1</span>);</span><br><span class="line">      		&#125; </span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="built_in">init</span>(n);</span><br><span class="line">     <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">     <span class="built_in">printf</span>();</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="分支限界法"><a href="#分支限界法" class="headerlink" title="分支限界法"></a>分支限界法</h2><h3 id="设计思想-4"><a href="#设计思想-4" class="headerlink" title="设计思想"></a>设计思想</h3><p>分支是使用广度优先策略，依次生成扩展结点的所有分支。</p>
<p>限界是在结点扩展过程中，计算结点的上界，搜索的同时剪掉某些分支。</p>
<p>分支限界法就是把问题的可行解展开，再由各个分支寻找最佳解。</p>
<p>与回溯法类似，分支限界法也是在解空间中搜索得到解；</p>
<p>不同的是，分支限界法会生成所有扩展结点，并舍弃不可能通向最优解的结点，然后根据广度优先/最小耗费优先，从活结点中选择一个作为扩展结点，使搜索向解空间上有最优解的分支推进。</p>
<h3 id="搜索策略"><a href="#搜索策略" class="headerlink" title="搜索策略"></a>搜索策略</h3><ol>
<li>队列式(FIFO)分支限界法<ul>
<li>按照队列先进先出（FIFO）原则选取下一个节点为扩展节点。</li>
</ul>
</li>
<li>优先队列式分支限界法<ul>
<li>按照优先队列中规定的优先级选取优先级最高的节点成为当前扩展节点。</li>
</ul>
</li>
</ol>
<h3 id="分支限界法与回溯法的不同"><a href="#分支限界法与回溯法的不同" class="headerlink" title="分支限界法与回溯法的不同"></a>分支限界法与回溯法的不同</h3><ol>
<li>求解目标：回溯法的求解目标是找出解空间树中满足约束条件的所有解，而分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出在某种意义下的最优解。</li>
<li>搜索方式的不同：回溯法以深度优先的方式搜索解空间树，而分支限界法则以广度优先或以最小耗费优先的方式搜索解空间树。</li>
</ol>
<h3 id="求解步骤"><a href="#求解步骤" class="headerlink" title="求解步骤"></a>求解步骤</h3><ol>
<li>针对所给问题，定义问题的解空间（对解进行编码）；</li>
<li>确定易于搜索的解空间结构（按树或图组织解） ；</li>
<li>以广度优先或以最小耗费（最大收益）优先的方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。</li>
</ol>
<h3 id="单源最短路径"><a href="#单源最短路径" class="headerlink" title="单源最短路径"></a>单源最短路径</h3><p>给定一个带权有向图G=(V,E)，其中每条边的权是非负数。给定V中的一个顶点，成为源。现在要计算从源到所有其他个顶点的最短路径长度，这里路径长度指的是各边权之和。这个问题通常被称作单源最短路径问题。</p>
<p>如图所示，每一边都有一非负权值。求图G到原点s的到t的最短路径。</p>
<img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220110235242.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220110235242.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220110235238624" style="zoom:50%;" />

<h4 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h4><p>  算法从G的源点s和空队列开始。结点s被扩展之后，他的儿子结点2,3,4倍一次插入队列当中。然后取出队头元素，进行下一步扩展。保证每一次扩展时，源到当前节点的和都是最小的。具体的解空间图如下:</p>
<img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220110235256.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220110235256.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220110235253026" style="zoom:50%;" />

<h4 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h4><p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220110235319.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220110235319.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220110235316515"></p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcCell</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> adj;<span class="comment">//保存权值</span></span><br><span class="line">    <span class="keyword">int</span> info;<span class="comment">//存储最短路径长度</span></span><br><span class="line">&#125;ArcCell,AdjMaxtrix[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;VerType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    VerType vexs[<span class="number">100</span>];<span class="comment">//顶点向量</span></span><br><span class="line">    AdjMaxtrix arcs;</span><br><span class="line">    <span class="keyword">int</span> vexnum;<span class="comment">//顶点数</span></span><br><span class="line">    <span class="keyword">int</span> arcnum;<span class="comment">//弧数</span></span><br><span class="line">&#125;Graph;</span><br><span class="line"></span><br><span class="line">Graph G;</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateGraph</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m,n,t;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入顶点数和弧数:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;G.vexnum,&amp;G.arcnum);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入顶点:&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=G.vexnum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;G.vexs[i].data);</span><br><span class="line">        G.vexs[i].length=<span class="number">10000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=G.vexnum;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=G.vexnum;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            G.arcs[i][j].adj=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入弧及权重:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=G.arcnum;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;m,&amp;n,&amp;t);</span><br><span class="line">            G.arcs[m][n].adj=<span class="number">1</span>;</span><br><span class="line">            G.arcs[m][n].info=t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NextAdj</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=w+<span class="number">1</span>;i&lt;=G.vexnum;i++)</span><br><span class="line">        <span class="keyword">if</span>(G.arcs[v][i].adj)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//not found;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShortestPaths</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;<span class="comment">//从首个节点开始访问</span></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    G.vexs[v].length=<span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(G.vexs[v].data);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        t=q.<span class="built_in">front</span>();</span><br><span class="line">        k=<span class="built_in">NextAdj</span>(t,k);</span><br><span class="line">        <span class="keyword">while</span>(k!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(G.vexs[t].length+G.arcs[t][k].info&lt;=G.vexs[k].length)<span class="comment">//减枝操作</span></span><br><span class="line">            &#123;</span><br><span class="line">                G.vexs[k].length=G.vexs[t].length+G.arcs[t][k].info;</span><br><span class="line">                q.<span class="built_in">push</span>(G.vexs[k].data);</span><br><span class="line">            &#125;</span><br><span class="line">            k=<span class="built_in">NextAdj</span>(t,k);</span><br><span class="line">        &#125;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=G.vexnum;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d------%d\n&quot;</span>,G.vexs[i].data,G.vexs[i].length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">CreateGraph</span>();</span><br><span class="line">    <span class="built_in">ShortestPaths</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">Print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最小权顶点覆盖"><a href="#最小权顶点覆盖" class="headerlink" title="最小权顶点覆盖"></a>最小权顶点覆盖</h3><h4 id="问题描述-6"><a href="#问题描述-6" class="headerlink" title="问题描述"></a>问题描述</h4><p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220110235555.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220110235555.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220110235552781"></p>
<p><img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220110235608.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220110235608.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220110235605386"></p>
<h4 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h4><p>我们先简明介绍一下题目，我们仍然需要将所有点分成U、V两个集合。什么叫做顶点覆盖呢？即为V 集合中的每个点，至少与一个U集合中的点直接相连。如图所示（红色点表示U集合中的点）：</p>
<img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220110235627.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220110235627.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220110235623779" style="zoom:50%;" />

<p>我们可以看到V集合中的顶点2、5、6，都与至少一个U集合中的顶点直接相连。反而如果按照下图分配则不满足条件：</p>
<img src="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220110235648.png" class="lazyload" data-srcset="https://gitee.com/xxxxxwj/hexo-img/raw/master/hexo-img/20220110235648.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220110235644843" style="zoom:50%;" />

<p>图中V集合的顶点2、5并没有U集合中的点与其直接相连，所以不是一种顶点覆盖。</p>
<p>那我们应该如何判断图是否被覆盖了呢？可以开辟一个数组c，如果c[j]==0，则表示U集合中没有任何一个顶点与其直接相连。<br><strong>优先级</strong><br>说完如何判断是否覆盖之后，我们来确定一下优先级。由于所有顶点都是带权的，我们的目的也是找到最小权覆盖，所以我们可以直接用权重作为优先级建立一个最小堆，从而实现优先队列。<br><strong>界限函数</strong><br>我们找的是最小点权，无法使用界限函数来对右孩子进行约束，因为如果当前结点不加入U集合中(即走右孩子路径)，一定点权和更小，但是不一定会覆盖，所以不经过判断，我们也要将右孩子加入到队列中。<br><strong>将活结点加入队列中</strong><br>将活结点加入队列时，要对点的优先级、结果向量以及cover数组进行更新。</p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeapNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">VC</span>;</span><span class="comment">//求解最小权覆盖问题的类,融合了所有函数和所需的参数</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in"><span class="keyword">operator</span></span> ()(<span class="keyword">int</span> x,<span class="keyword">int</span> y) <span class="keyword">const</span>&#123;<span class="keyword">return</span> x &lt; y;&#125;<span class="comment">//定义优先级</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> i,cn,*x,*c;<span class="comment">//i表示结点序号,cn表示当前权重,x表示结果数组,c数组表示此时是否有一点i属于U,且i与j相连,如果有,则c[j]!=0</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//解最小权顶点覆盖大类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VC</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="title">MinCover</span><span class="params">(<span class="keyword">int</span> **,<span class="keyword">int</span> [],<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">BBVC</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">cover</span><span class="params">(HeapNode E)</span></span>;<span class="comment">//判断图是否已经被全部覆盖了</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">AddLiveNode</span><span class="params">(priority_queue&lt;HeapNode&gt; &amp;H,HeapNode E,<span class="keyword">int</span> cn,<span class="keyword">int</span> i,<span class="keyword">bool</span> ch)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> **a,n,*w,*bestx,bestn;<span class="comment">//邻接矩阵,节点数目,每个点的权重,结果向量,最优解</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VC::BBVC</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">priority_queue&lt;HeapNode&gt; <span class="title">H</span><span class="params">(<span class="number">100000</span>)</span></span>;</span><br><span class="line">    HeapNode E<span class="comment">//扩展结点</span></span><br><span class="line">    E.x = <span class="keyword">new</span> <span class="keyword">int</span> [n+<span class="number">1</span>];<span class="comment">//开辟结果向量</span></span><br><span class="line">    E.c = <span class="keyword">new</span> <span class="keyword">int</span> [n+<span class="number">1</span>];<span class="comment">//开辟一数组,用于判断图是否被完全覆盖</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        E.x[j] = E.c[j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>,cn = <span class="number">0</span>;<span class="comment">//初始化当前点权总和为0</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">cover</span>(E))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)</span><br><span class="line">                    bestx[j]=E.x[j];</span><br><span class="line">                bestn = cn;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">cover</span>(E))<span class="comment">//如果当前没有完全覆盖,就将这个点加入到U集合中</span></span><br><span class="line">                <span class="built_in">AddLiveNode</span>(H,E,cn,i,<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">AddLiveNode</span>(H,E,cv,i,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(H.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        E = H.<span class="built_in">top</span>();</span><br><span class="line">        H.<span class="built_in">pop</span>();</span><br><span class="line">        cn = E.cn;</span><br><span class="line">        i = E.i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断图是否完全覆盖</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">VC::cover</span><span class="params">(HeapNode E)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(E.x[j]==<span class="number">0</span> &amp;&amp; E.c[j]==<span class="number">0</span>)<span class="comment">//如果此时j结点既不是U中的点,而且也没有U中的点与其相连,则至少这个点未被覆盖</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VC::AddLiveNode</span><span class="params">(priority_queue&lt;HeapNode&gt; &amp;H,HeapNode E,<span class="keyword">int</span> cn,<span class="keyword">int</span> i,<span class="keyword">bool</span> ch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HeapNode N;<span class="comment">//创建一个新的堆结点</span></span><br><span class="line">    N.x = <span class="keyword">new</span> <span class="keyword">int</span> [n+<span class="number">1</span>];</span><br><span class="line">    N.c = <span class="keyword">new</span> <span class="keyword">int</span> [n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        N.x[j] = E.x[j];</span><br><span class="line">        N.c[j] = E.c[j];</span><br><span class="line">    &#125;</span><br><span class="line">    N.x[i] = ch;</span><br><span class="line">    <span class="keyword">if</span>(ch)</span><br><span class="line">    &#123;</span><br><span class="line">        N.cn = cn + w[i];<span class="comment">//此时i要加入集合U,所以其权重应该加上cn</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i][j])</span><br><span class="line">                N.c[j]++;<span class="comment">//表明此时对于结点j来说,有一节点i属于U与其连接,表明这个点被覆盖了</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        N.cn = cn;</span><br><span class="line">    N.i = i;</span><br><span class="line">    H.<span class="built_in">push</span>(N);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//MinCover完成最小覆盖计算</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MinCover</span><span class="params">(<span class="keyword">int</span> **a,<span class="keyword">int</span> v[],<span class="keyword">int</span> n)</span><span class="comment">//v表示的是结点权重数组</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    VC Y;</span><br><span class="line">    Y.w = <span class="keyword">new</span> <span class="keyword">int</span> [n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)</span><br><span class="line">        Y.w[j] = v[j];</span><br><span class="line">    Y.a = a;</span><br><span class="line">    Y.n = n;</span><br><span class="line">    Y.bestx = v;</span><br><span class="line">    Y.<span class="built_in">BBVC</span>();</span><br><span class="line">    <span class="keyword">return</span> Y.bestn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,e,u,v;<span class="comment">//结点数,边数,u,v为结点编号</span></span><br><span class="line">    cin&gt;&gt;n&gt;&gt;e;</span><br><span class="line">    <span class="keyword">int</span> a[n+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            a[i][j] = <span class="number">0</span>;<span class="comment">//初始化为0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    p = <span class="keyword">new</span> <span class="keyword">int</span> [n+<span class="number">1</span>];<span class="comment">//定义结果向量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= e;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        a[u][v] = <span class="number">1</span>;</span><br><span class="line">        a[v][u] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">MinCover</span>(a,p,n)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        cout&lt;&lt;p[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


            </div>

            <!-- Post Comments -->
            
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'http-miccall-tech'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://xucoud.github.io/2022/01/26/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://xucoud.github.io/2022/01/26/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//http-miccall-tech.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a target="_blank" rel="noopener" href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
                <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
